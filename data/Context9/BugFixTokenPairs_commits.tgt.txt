<S2SV_ModStart> int fd , len ; struct sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> >= sizeof ( unix_addr . sun_path ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> ; } snprintf ( unix_addr . sun_path , sizeof <S2SV_ModStart> & unix_addr , len ) < 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> } if ( chmod ( unix_addr . sun_path , <S2SV_ModStart> . sun_path , S_IRWXU ) < 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> ; } memset ( & unix_addr , 0 , <S2SV_ModStart> & unix_addr , len ) < 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> ; } hdl -> client_fd = fd ; hdl <S2SV_ModStart> HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> strcpy ( hdl -> c_path , client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
<S2SV_ModStart> res = FM_CONF_INIT_ERR ; goto cleanup ; } } cleanup : <S2SV_ModEnd> return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; char * mgr_prefix ; p_hsm_com_client_hdl_t * mgr_hdl ; <S2SV_ModEnd> memset ( s_path , 0 , sizeof ( s_path <S2SV_ModStart> ( c_path , 0 , sizeof ( c_path ) <S2SV_ModEnd> ) ; switch ( mgr ) { case FM_MGR_SM <S2SV_ModStart> hdl -> instance ) ; sprintf ( c_path , "%s%s%d_C_XXXXXX" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance <S2SV_ModEnd> ) ; if ( * mgr_hdl == NULL )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , TPM2B * key , char * <S2SV_ModStart> UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr <S2SV_ModStart> ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> . size = 0 ; i = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> resultKey -> t . size < bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> ( tpm2bBits . b ) ; bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = string_bytes_concat_buffer ( resultKey , & ( <S2SV_ModStart> ) ) ; if ( ! res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; } else { rval = tpm_kdfa ( <S2SV_ModEnd> session -> authHash , & ( key . b
<S2SV_ModStart> ; return 0 ; } i += 2 ; if ( i + 1 < data_size )
<S2SV_ModStart> free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void test_parser ( void ) { test_parser_param ( 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rid = 0 ; if ( sync_reply ) { if ( client_obj -> ipc ) { <S2SV_ModStart> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; } else { crm_trace ( "Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s" , client_obj -> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; }
<S2SV_ModStart> ) ; if ( client -> ipc == NULL && client -> session == NULL
<S2SV_ModStart> , uid_t uid_client , gid_t gid_client ) { static <S2SV_ModEnd> gid_t gid_cluster = 0 ; crm_client_t * client = <S2SV_ModStart> ; } if ( gid_cluster == 0 ) { <S2SV_ModEnd> if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & <S2SV_ModStart> have_error = TRUE ; } } } if ( uid_client != 0 ) { crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , - 1 <S2SV_ModEnd> , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP |
<S2SV_ModStart> ) ) { xmlAttr * xIter = NULL ; char * path = xml_get_path ( xml ) ; <S2SV_ModStart> ( strcmp ( prop_name , XML_ATTR_ID ) == 0 && strstr ( path , "/" XML_CIB_TAG_ACLS "/" ) == NULL <S2SV_ModStart> xml ) ) ; break ; } else { <S2SV_ModEnd> crm_trace ( "Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s" , crm_element_name ( xml ) , <S2SV_ModStart> free ( path ) ; return ; } } free ( path ) ;
<S2SV_ModStart> ERROR_INT ( "safiles<S2SV_blank>not<S2SV_blank>made" , procName , 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s.html" , dirout , rootname ) ; mainname <S2SV_ModStart> ) ; mainname = stringNew ( charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s-links.html" , dirout , rootname ) ; linkname <S2SV_ModStart> pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s_thumb_%03d" , rootname , index ) ; sarrayAddString
<S2SV_ModStart> const char * plottitle ) { char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char emptystring [ ] = "" ; <S2SV_ModStart> gplot -> nplots ++ ; snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.data.%d" , gplot -> rootname , gplot -> <S2SV_ModStart> , & valy ) ; snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%f<S2SV_blank>%f\\n" , valx , valy ) ; sarrayAddString
<S2SV_ModStart> ) { char * newroot ; char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 badchar ; GPLOT * gplot ; <S2SV_ModStart> -> outformat = outformat ; snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.cmd" , rootname ) ; gplot -> cmdname <S2SV_ModStart> ( outformat == GPLOT_PNG ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.png" , newroot ) ; else if ( <S2SV_ModStart> ( outformat == GPLOT_PS ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.ps" , newroot ) ; else if ( <S2SV_ModStart> ( outformat == GPLOT_EPS ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.eps" , newroot ) ; else if ( <S2SV_ModStart> ( outformat == GPLOT_LATEX ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.tex" , newroot ) ; gplot -> outname
<S2SV_ModStart> ( GPLOT * gplot ) { char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char * cmdstr , * plottitle , <S2SV_ModStart> gplot -> title ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>title<S2SV_blank>\'%s\'" , gplot -> title ) ; sarrayAddString <S2SV_ModStart> gplot -> xlabel ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>xlabel<S2SV_blank>\'%s\'" , gplot -> xlabel ) ; sarrayAddString <S2SV_ModStart> gplot -> ylabel ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>ylabel<S2SV_blank>\'%s\'" , gplot -> ylabel ) ; sarrayAddString <S2SV_ModStart> outformat == GPLOT_PNG ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , gplot -> outname ) ; } <S2SV_ModStart> outformat == GPLOT_PS ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , gplot -> outname ) ; } <S2SV_ModStart> outformat == GPLOT_EPS ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , gplot -> outname ) ; } <S2SV_ModStart> outformat == GPLOT_LATEX ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , gplot -> outname ) ; } <S2SV_ModStart> scaling == GPLOT_LOG_SCALE_X_Y ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>x" ) ; sarrayAddString ( gplot -> cmddata <S2SV_ModStart> scaling == GPLOT_LOG_SCALE_X_Y ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>y" ) ; sarrayAddString ( gplot -> cmddata <S2SV_ModStart> nplots == 1 ) { snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , dataname , plottitle , gplotstylenames [ <S2SV_ModStart> ( i == 0 ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , dataname , plottitle , gplotstylenames [ <S2SV_ModStart> < nplots - 1 ) snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , dataname , plottitle , gplotstylenames [ <S2SV_ModStart> plotstyle ] ) ; else snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , dataname , plottitle , gplotstylenames [
<S2SV_ModStart> ( GPLOT * gplot ) { char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char * cmdname ; l_int32 ignore ; <S2SV_ModStart> ) ; # ifndef _WIN32 snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "gnuplot<S2SV_blank>%s" , cmdname ) ; # else snprintf <S2SV_ModStart> cmdname ) ; # else snprintf ( buf , L_BUFSIZE <S2SV_ModEnd> , "wgnuplot<S2SV_blank>%s" , cmdname ) ; # endif #
<S2SV_ModStart> const char * filename ) { char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char * rootname , * title , <S2SV_ModStart> ) ; } ignore = fscanf ( fp , "Rootname:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) ; rootname = stringNew ( buf <S2SV_ModStart> outformat ) ; ignores = fgets ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) ; title = stringNew ( buf <S2SV_ModStart> = '\\0' ; ignores = fgets ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) ; xlabel = stringNew ( buf <S2SV_ModStart> = '\\0' ; ignores = fgets ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) ; ylabel = stringNew ( buf <S2SV_ModStart> plotstyles ) ; ignore = fscanf ( fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) ; stringReplace ( & gplot -> <S2SV_ModStart> nplots ) ; ignore = fscanf ( fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) ; stringReplace ( & gplot ->
<S2SV_ModStart> NULL ) ; if ( fscanf ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n" <S2SV_ModEnd> , & n , typestr ) != 2 )
<S2SV_ModStart> ) { char * selname ; char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 sy , sx , cy , <S2SV_ModStart> NULL ) ; if ( fgets ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) == NULL ) return ( SEL <S2SV_ModStart> stringNew ( linebuf ) ; sscanf ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------" <S2SV_ModEnd> , selname ) ; if ( fscanf ( fp
<S2SV_ModStart> ) { char * selname ; char combname [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 i , nsels , sx , <S2SV_ModStart> ( direction == L_HORIZ ) snprintf ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dh" , size ) ; else snprintf ( <S2SV_ModStart> , size ) ; else snprintf ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dv" , size ) ; found = FALSE
<S2SV_ModStart> != \'\\"\' && * end_ptr && ++ len ) { if ( * end_ptr ++ == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = ( char * ) cJSON_malloc ( len
<S2SV_ModStart> "X345" , == , result -> str ) ; <S2SV_ModEnd> g_string_free ( result , TRUE ) ; } <S2SV_null>
<S2SV_ModStart> WebKitWebFrame * frame ; JSGlobalContextRef context ; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string <S2SV_ModStart> ( frame ) ; globalobject = JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; <S2SV_ModStart> ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_ModEnd> JSStringRelease ( js_script ) ; } void ru <S2SV_null>
<S2SV_ModStart> Ustrcmp ( argrest , "Mr" ) == 0 ) if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> ( * argrest != 0 ) { uschar * hn ; if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_ModStart> 8 ] ) ; if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height <S2SV_ModEnd> ) ) < 0 ) { s -> width
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i + 47 >= dctx
<S2SV_ModStart> 0 ; j < len ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> , "%X" , avio_r8 ( pb ) ) ; }
<S2SV_ModStart> ( ! proto_name ) return AVERROR_INVALIDDATA ; if ( av_strstart ( proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , "http" , NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name
<S2SV_ModStart> == 6 || c -> bpp == 8 ) && c -> format != CHUNKY
<S2SV_ModStart> ; s -> partitioned_frame = 0 ; s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> w_align = 4 ; h_align = 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> ; } if ( s -> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
<S2SV_ModStart> else break ; c ++ ; } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> 2 ; if ( src_end - src < zsize + ( sub_type != 2 ) <S2SV_ModStart> ++ ) { if ( ! bits ) { if ( src >= src_end ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> else { if ( ctx -> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> mb_height << frame -> interlaced_frame ) <S2SV_ModStart> ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size < ctx -> data_offset ) {
<S2SV_ModStart> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr -> tf . owner == h0 <S2SV_ModStart> h -> picture_structure == last_pic_structure ) { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME ) { ff_thread_report_progress ( & h0 <S2SV_ModStart> frame_num != h -> frame_num ) { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME ) { ff_thread_report_progress ( & h0
<S2SV_ModStart> s -> buf_ptr += len ; } else { uint64_t <S2SV_ModEnd> target_end = s -> end_off ? s -> end_off <S2SV_ModStart> ( ! s -> willclose || s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> off >= target_end ) return AVERROR_EOF <S2SV_ModStart> ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_ModStart> ) { av_log ( h , AV_LOG_ERROR , "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRIu64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\\n" , s -> off , target_end ) ;
<S2SV_ModStart> authstr = NULL , * proxyauthstr = NULL ; uint64_t <S2SV_ModEnd> off = s -> off ; int len = <S2SV_ModStart> , sizeof ( headers ) - len , "Range:<S2SV_blank>bytes=%" PRIu64 <S2SV_ModEnd> "-" , s -> off ) ; if ( <S2SV_ModStart> -> icy_data_read = 0 ; s -> filesize = UINT64_MAX <S2SV_ModEnd> ; s -> willclose = 0 ; s ->
<S2SV_ModStart> -> is_streamed = 1 ; s -> filesize = UINT64_MAX <S2SV_ModEnd> ; s -> location = av_strdup ( uri )
<S2SV_ModStart> int err = 0 ; s -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for ( ; ; ) { if (
<S2SV_ModStart> return err ; } if ( s -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { if ( ! s -> chunksize ) <S2SV_ModStart> ! * line ) ; s -> chunksize = strtoull <S2SV_ModEnd> ( line , NULL , 16 ) ; av_log <S2SV_ModStart> line , NULL , 16 ) ; av_log ( h , AV_LOG_TRACE , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\'\\n" , s -> chunksize ) ; if ( <S2SV_ModStart> ( ! s -> chunksize ) return 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , "Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%" PRIu64 "\\n" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> is_streamed || s -> reconnect_streamed ) ) ) { uint64_t <S2SV_ModEnd> target = h -> is_streamed ? 0 : s <S2SV_ModStart> ) ; av_log ( h , AV_LOG_INFO , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "<S2SV_blank>error=%s.\\n" , s -> off , av_err2str ( read_ret <S2SV_ModStart> ) { av_log ( h , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> ".\\n" , target ) ; return read_ret ; }
<S2SV_ModStart> ; URLContext * old_hd = s -> hd ; uint64_t <S2SV_ModEnd> old_off = s -> off ; uint8_t old_buf [ <S2SV_ModStart> ; else if ( ( s -> filesize == UINT64_MAX <S2SV_ModEnd> && whence == SEEK_END ) ) return AVERROR (
<S2SV_ModStart> { p += 6 ; s -> off = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; if <S2SV_ModStart> slash ) > 0 ) s -> filesize = strtoull <S2SV_ModEnd> ( slash + 1 , NULL , 10 )
<S2SV_ModStart> tag , "Content-Length" ) && s -> filesize == UINT64_MAX ) { s -> filesize = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; } <S2SV_ModStart> , 7 ) ) { s -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , & s -> <S2SV_ModEnd> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , <S2SV_ModStart> , "Icy-MetaInt" ) ) { s -> icy_metaint = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; }
<S2SV_ModStart> { HTTPContext * s = h -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s -> icy_metaint - s -> icy_data_read <S2SV_ModStart> remaining = s -> icy_metaint - s -> icy_data_read <S2SV_ModEnd> ; if ( ! remaining ) { uint8_t ch
<S2SV_ModStart> } else if ( startcode == VOS_STARTCODE ) { int profile , level ; mpeg4_decode_profile_level ( s , gb , & profile , & level ) ; if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( level > 0 && <S2SV_ModEnd> level < 9 ) ) { s -> studio_profile <S2SV_ModStart> ( s , gb , 0 ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> low_delay ; if ( s -> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
<S2SV_ModStart> mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits ( gb , 4 ) ; <S2SV_ModStart> profile = get_bits ( gb , 4 ) ; * <S2SV_ModEnd> level = get_bits ( gb , 4 ) ; <S2SV_ModStart> get_bits ( gb , 4 ) ; if ( * profile == 0 && * level == 8 ) { * <S2SV_ModEnd> level = 0 ; } return 0 ; }
<S2SV_ModStart> , size_bmp ) ; if ( size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i >= dctx -> remaining
<S2SV_ModStart> ; int row_ptr = 0 ; int pixel_ptr = - 4 <S2SV_ModEnd> ; int block_ptr ; int pixel_x , pixel_y ; <S2SV_ModStart> += 2 ; while ( n_blocks -- ) { ADVANCE_BLOCK ( ) <S2SV_ModStart> block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_ModEnd> } break ; case 0xc0 : colorA = AV_RB16 <S2SV_ModStart> ) return ; while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; <S2SV_ModStart> block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_ModEnd> } break ; case 0x00 : if ( s <S2SV_ModStart> -> size - stream_ptr < 16 ) return ; ADVANCE_BLOCK ( ) ; <S2SV_ModStart> block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_ModEnd> break ; default : av_log ( s -> avctx
<S2SV_ModStart> trk -> sample_size ; else samples_in_chunk = 1 ; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> bpp != 8 ) return AVERROR_INVALIDDATA ; if ( bpp == 1 && <S2SV_ModStart> -> pix_fmt = AV_PIX_FMT_MONOWHITE ; } else if ( bpp == 8 &&
<S2SV_ModStart> ( i = 0 ; i <= w - ( int )
<S2SV_ModStart> ( i = 0 ; i <= w - ( int )
<S2SV_ModStart> ) ; uint32_t vsize = avio_rb32 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> if ( ret < 0 ) return ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> sh . first_slice_in_pic_flag ) { if ( s -> <S2SV_ModEnd> max_ra == INT_MAX ) { if ( s ->
<S2SV_ModStart> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> if ( f -> version < 2 ) { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart> get_symbol ( c , state , 0 ) ; <S2SV_ModEnd> chroma_planes = get_rac ( c , state ) ; <S2SV_ModStart> chroma_planes = get_rac ( c , state ) ; <S2SV_ModEnd> chroma_h_shift = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; <S2SV_ModEnd> chroma_v_shift = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency <S2SV_ModEnd> ; f -> plane_count = 2 + f ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb <S2SV_ModStart> ; if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < 64 ; i ++ ) { get_bits ( gb , 8 ) ; } } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> for ( i = 0 ; i < 64 <S2SV_ModStart> } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; } } next_start_code_studio ( gb ) ; return 0 ;
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i + 47 >= dctx
<S2SV_ModStart> av_free ( sc -> drefs ) ; sc -> drefs_count = 0 ; sc ->
<S2SV_ModStart> VP8Frame * av_uninit ( curframe ) , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> ; int64_t cur_offset = avio_tell ( pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> = bytestream2_get_be16u ( & s -> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> ; while ( run -- > 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> prev_pkt [ channel_id ] . timestamp ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> i < st -> duration ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> i , 0 , 0 , AVINDEX_KEYFRAME ) ; }
<S2SV_ModStart> priv_data ; int ret , i ; int just_opened = 0 ; int reload_count <S2SV_ModStart> reload_interval = default_reload_interval ( v ) ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
<S2SV_ModStart> ) ; name_len = avio_rl16 ( pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for ( i = 0 ; i <S2SV_ModStart> i ++ ) { int64_t pres_time ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 <S2SV_ModEnd> ; aligned_height = FFALIGN ( c -> tile_height ,
<S2SV_ModStart> -> wavheaderlength , SEEK_CUR ) ; } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , "No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n" ) ; return AVERROR ( EINVAL ) ; } if (
<S2SV_ModStart> , av_color_space_name ( frame -> colorspace ) ) ; print_primaries ( w , frame -> color_primaries <S2SV_ModEnd> ) ; if ( frame -> color_trc != AVCOL_TRC_UNSPECIFIED
<S2SV_ModStart> , av_color_transfer_name ( par -> color_trc ) ) ; print_primaries ( w , par -> color_primaries <S2SV_ModEnd> ) ; if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED
<S2SV_ModStart> ( i = 0 ; i <= w - ( int )
<S2SV_ModStart> = get_bits ( & gb , 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , "Block<S2SV_blank>parameters<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 <S2SV_ModEnd> ) { av_log ( s -> avctx , AV_LOG_ERROR
<S2SV_ModStart> if ( s -> width != avctx -> width || <S2SV_ModEnd> s -> height != avctx -> height ) {
<S2SV_ModStart> length = avio_rb32 ( pb ) ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> < segment -> nb_index_entries ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> * reslevel -> num_precincts_y ; precno ++ ) { if ( band -> prec ) { <S2SV_ModStart> ; av_freep ( & prec -> cblk ) ; }
<S2SV_ModStart> reslevel -> log2_prec_height ) ; reslevel -> band = av_calloc <S2SV_ModEnd> ( reslevel -> nbands , sizeof ( * reslevel <S2SV_ModStart> ] , dy ) ; band -> prec = av_calloc <S2SV_ModEnd> ( reslevel -> num_precincts_x * ( uint64_t ) reslevel
<S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> [ i ] = avio_rl32 ( pb ) ; } <S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> [ i ] = avio_rl32 ( pb ) ; } <S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] = avio_rl32 ( pb ) & 0xFFFF ; }
<S2SV_ModStart> pes_header_data_length = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> ; int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
<S2SV_ModStart> AV_LOG_ERROR , "cblk<S2SV_blank>size<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> ) { int64_t time , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> return AVERROR_PATCHWELCOME ; } if ( item_num > 65536 || item_num < 0
<S2SV_ModStart> return AVERROR_INVALIDDATA ; } if ( c -> nreslevels <= s -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , "reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode = c -> nreslevels - s
<S2SV_ModStart> , 16 ) ; if ( c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> c -> buffer_ptr = c -> buffer ; break <S2SV_ModStart> len == 0 ) goto fail ; else { av_assert0 ( len <= c -> chunk_size ) ;
<S2SV_ModStart> ( ! sub_demuxer ) goto error ; if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ; if (
<S2SV_ModStart> , st2 , st2 -> priv_data , size2 , NULL <S2SV_ModEnd> ) ; if ( ret < 0 ) return
<S2SV_ModStart> asf -> hdr . preroll , 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
<S2SV_ModStart> { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample <S2SV_ModStart> + c -> one_state [ i ] ; } <S2SV_ModEnd> colorspace = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; bits_per_raw_sample = f -> version > 0 ? get_symbol ( c , state , 0 ) : f -> avctx -> bits_per_raw_sample ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModEnd> = get_symbol ( c , state , 0 ) <S2SV_ModStart> get_symbol ( c , state , 0 ) ; chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; <S2SV_ModEnd> if ( f -> plane_count ) { if ( <S2SV_ModStart> if ( f -> plane_count ) { if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;
<S2SV_ModStart> avctx -> bits_per_raw_sample == 9 ) { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c -> idct_put = ff_simple_idct_put_int32_10bit ; else {
<S2SV_ModStart> av_cold void ff_mpv_idct_init ( MpegEncContext * s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> int i , ch , ret ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> } if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> < 3930 ) blockstodecode = s -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if ( ! s -> decoded_buffer )
<S2SV_ModStart> , EssenceContainerData ) ) ) { av_log ( mxf -> fc
<S2SV_ModStart> cur_pic . f || s -> cur_pic . field_picture <S2SV_ModEnd> ) return 0 ; return 1 ; } <S2SV_null>
<S2SV_ModStart> s -> bitstream_buffer_size == 0 ) ; frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> avctx -> bits_per_raw_sample > 8 ) { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return avctx -> pix_fmt ; } if
<S2SV_ModStart> low_delay ; if ( s -> studio_profile ) { <S2SV_ModEnd> if ( ! s -> avctx -> bits_per_raw_sample )
<S2SV_ModStart> 0 ; i < table_entries_used ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] = avio_rl32 ( pb ) + size ; }
<S2SV_ModStart> "sprop-parameter-sets" ) ) { int ret ; if ( * value == 0 ||
<S2SV_ModStart> size ) ; if ( ! * ptrptr && nmemb && size <S2SV_ModEnd> ) return AVERROR ( ENOMEM ) ; return 0
<S2SV_ModStart> * entry ; char color_name [ 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> ; av_freep ( & x -> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> data ; const uint8_t * end , * ptr <S2SV_ModEnd> ; int ncolors , cpp , ret , i <S2SV_ModStart> * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf + avpkt -> size ; while ( end - ptr > 9 && memcmp ( ptr , "/*<S2SV_blank>XPM<S2SV_blank>*/" , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log ( avctx , AV_LOG_ERROR , "missing<S2SV_blank>signature\\n" <S2SV_ModStart> i < cpp ; i ++ ) size *= 95 <S2SV_ModEnd> ; if ( ncolors <= 0 || ncolors > <S2SV_ModStart> mod_strcspn ( ptr , "," ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ptr , "\\"" ) + 1 ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; index = ptr ; ptr <S2SV_ModStart> mod_strcspn ( ptr , "," ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> * p -> linesize [ 0 ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> += mod_strcspn ( ptr , "\\"" ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA <S2SV_ModStart> -> width ; j ++ ) { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; if ( ( ret =
<S2SV_ModStart> ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 <S2SV_ModStart> , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; return AVERROR_INVALIDDATA ; } } } <S2SV_ModStart> ff_asf_guid ) ) ) { chunksize = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> ; } if ( buf -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
<S2SV_ModStart> ) ) + code ; idx += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> group >= 13 && group <= 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } else if ( group == 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3 ; aligned_height = c -> height + 15 <S2SV_ModEnd> ; av_free ( c -> framebuf ) ; c
<S2SV_ModStart> static void mpeg4_encode_gop_header ( MpegEncContext * s ) { int64_t <S2SV_ModEnd> hours , minutes , seconds ; int64_t time ;
<S2SV_ModStart> c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY
<S2SV_ModStart> avail_in > 0 ) { av_bprint_get_buffer ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret = AVERROR ( ENOMEM ) ; <S2SV_ModStart> next_out = buf ; zstream . avail_out = buf_size - 1
<S2SV_ModStart> in ) ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) hblur ( out -> data <S2SV_ModStart> temp ) ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) vblur ( out -> data
<S2SV_ModStart> 0 ; plane < 4 && in -> data [ plane ] && in -> linesize
<S2SV_ModStart> 0 ; plane < 4 && src -> data [ plane ] && src -> linesize
<S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> < 4 && in -> data [ p ] && in -> linesize [ p ]
<S2SV_ModStart> < 4 && in -> data [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> = 0 ; for ( plane = 0 ; plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) { h = plane ==
<S2SV_ModStart> < 4 && in -> data [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> < 4 && out -> data [ i ] && out -> linesize [ i ]
<S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> 0 ; plane < 4 && frame -> data [ plane ] && frame -> linesize <S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> 0 ; plane < 4 && in -> data [ plane ] && in -> linesize
<S2SV_ModStart> bpp - byte_depth ; unsigned x , y ; av_assert0 ( s -> bit_depth > 1 ) ;
<S2SV_ModStart> ) { int v , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>before<S2SV_blank>IHDR\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>after<S2SV_blank>IDAT\\n" ) ; return AVERROR_INVALIDDATA ; } if ( <S2SV_ModStart> -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) || s -> bit_depth == 1
<S2SV_ModStart> & h -> DPB [ i ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;
<S2SV_ModStart> = s -> pb ; AVStream * st ; int ret ; <S2SV_ModStart> s , AV_LOG_DEBUG , "HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; ret = <S2SV_ModStart> ] , & header_key_part [ 3 ] ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> + FF_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! new_buffer ) { pc -> index = 0 ; return AVERROR ( ENOMEM ) ; } <S2SV_ModEnd> pc -> buffer = new_buffer ; memcpy ( & <S2SV_ModStart> + FF_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; return AVERROR ( ENOMEM ) ; } <S2SV_ModEnd> pc -> buffer = new_buffer ; if ( next
<S2SV_ModStart> { if ( frame_end - frame < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; frame [ 0 ] =
<S2SV_ModStart> ) { if ( track -> timescale > UINT16_MAX || ! track -> par -> channels
<S2SV_ModStart> = picture -> data [ plane ] + y / s -> cdy [ compno ] <S2SV_ModStart> s -> image_offset_x ; dst = line + x / s -> cdx [ compno ] <S2SV_ModStart> ) picture -> data [ plane ] + y / s -> cdy [ compno ] <S2SV_ModStart> -> image_offset_x ; dst = linel + ( x / s -> cdx [ compno ]
<S2SV_ModStart> , uint8_t * dst , int dst_size ) { GetByteContext gb ; if ( data >= data_end ) return - 1 ; bytestream2_init ( & gb , data , data_end - data ) ; return amf_get_field_value2 ( & gb , name , dst , dst_size ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( & attr_args ) ; break ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret
<S2SV_ModStart> s , attr , BGP_ATTR_ENCAP ) ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp , peer , s , attr
<S2SV_ModStart> = 1 + 1 ; break ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC : attrname = "VNC" ; subtlvs =
<S2SV_ModStart> plinux_opts , "mountpoint" , NULL ) ; rc = foreach_shareopt <S2SV_ModEnd> ( shareopts , get_linux_shareopts_cb , plinux_opts ) ; if
<S2SV_ModStart> & credssp -> authInfo , sizeof ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
<S2SV_ModStart> rdp -> nego -> transport -> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
<S2SV_ModStart> ) ; credssp_free ( transport -> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> ) ; credssp_free ( transport -> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> ; rdpGdi * gdi = context -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> ; bitmap -> format = gdi -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; bitmap -> length = size <S2SV_ModEnd> ; bitmap -> data = ( BYTE * )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> if ( fields -> Len > 0 ) { const UINT64 offset = ( UINT64 ) fields -> BufferOffset + ( UINT64 ) fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length ( s ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> bitmapUpdate -> number > bitmapUpdate -> count ) { UINT32 count = bitmapUpdate -> number * 2 ; BITMAP_DATA * <S2SV_ModEnd> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate
<S2SV_ModStart> ) ; length -= sizeof ( wmac ) ; if ( ! <S2SV_ModStart> ( s -> p , length , rdp ) ) return FALSE
<S2SV_ModStart> , int length , rdpRdp * rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_decode ( NSC_CONTEXT * context ) { UINT16 x <S2SV_ModStart> { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart> ROUND_UP_TO ( context -> width , 8 ) ; shift = context -> ColorLossLevel - 1 ; bmpdata = context -> BitmapData ; if ( ! bmpdata ) return FALSE <S2SV_ModEnd> ; for ( y = 0 ; y < <S2SV_ModStart> INT16 b_val = y_val - co_val - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> : 1 ) ; aplane ++ ; } } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE * in , BYTE * out <S2SV_ModStart> nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize <S2SV_ModStart> ++ ; if ( left == 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> ) in ) ; in += 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> len ; left -= len ; } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT * context ) { UINT16 i <S2SV_ModStart> BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; if ( ! context ) return FALSE <S2SV_ModStart> i ] ; if ( planeSize == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> [ i ] , originalSize , 0xFF ) ; } else if ( planeSize < originalSize ) { if ( ! <S2SV_ModEnd> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers <S2SV_ModStart> context -> priv -> PlaneBuffers [ i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context -> priv -> PlaneBuffers [ i <S2SV_ModStart> [ i ] , rle , originalSize ) ; } rle += planeSize ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT * context , const BYTE * <S2SV_ModStart> const BYTE * bmpdata , UINT32 rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ; if ( context -> ChromaSubsamplingLevel ) { if ( ! nsc_encode_subsampling ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * <S2SV_ModStart> INT16 b_val ; BYTE a_val ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE ; <S2SV_ModStart> -> width ) ; ccl = context -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE <S2SV_ModStart> , cgplane - rw , rw ) ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT * context ) { UINT16 x <S2SV_ModStart> context ) { UINT16 x ; UINT16 y ; UINT32 tempWidth ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModEnd> ; tempWidth = ROUND_UP_TO ( context -> width , <S2SV_ModStart> ROUND_UP_TO ( context -> height , 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> < tempHeight >> 1 ; y ++ ) { BYTE * <S2SV_ModStart> + y * ( tempWidth >> 1 ) ; BYTE * <S2SV_ModStart> + y * ( tempWidth >> 1 ) ; const INT8 * <S2SV_ModStart> + ( y << 1 ) * tempWidth ; const INT8 * co_src1 = co_src0 + tempWidth ; const INT8 * <S2SV_ModEnd> cg_src0 = ( INT8 * ) context -> priv <S2SV_ModStart> + ( y << 1 ) * tempWidth ; const INT8 * <S2SV_ModStart> += 2 ; cg_src1 += 2 ; } } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static UINT32 nsc_rle_encode ( const
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * <S2SV_ModStart> 0 ) { nsc_encode_subsampling_sse2 ( context ) ; } return TRUE ;
<S2SV_ModStart> -> command_usage = GNAUNRAR ; return TRUE ; } <S2SV_ModEnd> } else if ( g_content_type_is_a ( mime_type , "application/x-cbz" <S2SV_ModStart> -> command_usage = P7ZIP ; return TRUE ; } <S2SV_ModEnd> } else if ( g_content_type_is_a ( mime_type , "application/x-cb7" <S2SV_ModStart> -> selected_command ) { comics_document -> command_usage = P7ZIP <S2SV_ModEnd> ; return TRUE ; } } else { g_set_error
<S2SV_ModStart> loaded_image ; GimpPlugInProcedure * proc ; gchar * filename = NULL ; gint file_handle <S2SV_ModStart> image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; file_handle = g_file_open_tmp ( "gimp-test-XXXXXX.xcf" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> ) ; file = g_file_new_for_path ( filename ) ;
<S2SV_ModStart> { client -> priv -> conn = conn ; <S2SV_ModEnd> g_debug ( "GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s" , client -> priv -> description
<S2SV_ModStart> ( client -> priv -> ice_connection ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , client ) ; g_io_channel_unref ( channel ) ; <S2SV_ModEnd> set_description ( client ) ; g_debug ( "GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'" ,
<S2SV_ModStart> * server ; IceListenObj listener ; } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection ( ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> char * * failure_reason_ret ) { IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( server -> priv -> xsmp_sockets == <S2SV_ModStart> ; } ice_conn = SmsGetIceConnection ( sms_conn ) ; data = ice_conn -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn , mask_ret , callbacks_ret ) ; return
<S2SV_ModStart> , dirname ) ; if ( subdir ) { dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; g_object_unref <S2SV_ModEnd> ( subdir ) ; } else dir = tar_create_dir
<S2SV_ModStart> xmlPushInput ( ctxt , input ) < 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) {
<S2SV_ModStart> + 1 , input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1 ) ; }
<S2SV_ModStart> ) ; c = CUR_CHAR ( l ) ; <S2SV_ModEnd> } } if ( ( len > XML_MAX_NAME_LENGTH ) <S2SV_ModStart> ) { xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "Name" ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , "unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"
<S2SV_ModStart> ) { GFile * location ; gboolean res ; g_autofree gchar * trusted = NULL ; <S2SV_ModStart> ( ! is_launcher ) { return TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; if ( nautilus_file_can_execute ( file ) && trusted != NULL <S2SV_ModEnd> ) { return TRUE ; } res = FALSE
<S2SV_ModStart> ( src , job -> cancellable ) ) { mark_desktop_file_executable <S2SV_ModEnd> ( job , job -> cancellable , dest ,
<S2SV_ModStart> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if ( nautilus_file_can_set_permissions ( file ) ) <S2SV_ModStart> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( "Trust<S2SV_blank>and<S2SV_blank>_Launch" ) , GTK_RESPONSE_OK ) ; } <S2SV_ModEnd> g_signal_connect ( dialog , "response" , G_CALLBACK ( untrusted_launcher_response_callback
<S2SV_ModStart> * file ; switch ( response_id ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , "yes" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window <S2SV_ModStart> -> parent_window ) ; g_free ( uri ) ; <S2SV_ModEnd> g_object_unref ( file ) ; } break ; default
<S2SV_ModStart> break ; } case ASF_DEMUX_DATA_TYPE_DWORD : { guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> break ; } case ASF_DEMUX_DATA_TYPE_BOOL : { gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
<S2SV_ModStart> pixels ; register ssize_t i ; size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) <S2SV_ModEnd> ; pixels = ( PixelChannels * * ) AcquireQuantumMemory <S2SV_ModStart> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows <S2SV_ModEnd> , sizeof ( * pixels ) ) ; if <S2SV_ModStart> ( ( PixelChannels * * ) NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 ; i < ( ssize_t ) rows <S2SV_ModEnd> ; i ++ ) { register ssize_t j ;
<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image ) ; { Image * p <S2SV_ModStart> ) ) { p = p -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
<S2SV_ModStart> ) { image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> rows = ( size_t ) floor <S2SV_ModStart> 0 ) image -> rows = ( size_t ) floor
<S2SV_ModStart> viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image -> columns + 7UL ) >> <S2SV_ModStart> image -> rows ; } else { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels , viff_info . number_data_bands ) != MagickFalse
<S2SV_ModStart> , size ; void * memory ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count , quantum ) != MagickFalse ) return
<S2SV_ModStart> size_t quantum ) { size_t extent ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count , quantum ) != MagickFalse ) return
<S2SV_ModStart> ) ( ( MagickOffsetType ) length ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , <S2SV_ModStart> layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "UnexpectedEndOfFile" , image -> filename <S2SV_ModEnd> ) ; } } length = ( MagickSizeType )
<S2SV_ModStart> void ) { return "DPC" # if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) "<S2SV_blank>Debug" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) "<S2SV_blank>Cipher" <S2SV_ModEnd> # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" <S2SV_ModStart> # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) "<S2SV_blank>Modules" <S2SV_ModStart> # if defined ( MAGICKCORE_OPENMP_SUPPORT ) "<S2SV_blank>OpenMP" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) "<S2SV_blank>Zero-configuration" # endif
<S2SV_ModStart> , & q , 10 ) ; if ( ( p == q ) || ( size < 16 ) || ( size > 256 ) <S2SV_ModEnd> ) return ( ( Image * ) NULL )
<S2SV_ModStart> = icon_file . directory [ i ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if ( imbuf == NULL ) { <S2SV_ModStart> ( void ) ResetMagickMemory ( imbuf , background_color_index , ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if ( dmbuf == ( unsigned char <S2SV_ModStart> ( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) <S2SV_ModStart> ( dmbuf + dmsx * y , imbuf + ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if ( dmbuf == ( unsigned char <S2SV_ModStart> ( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) <S2SV_ModStart> ( dmbuf + dmsx * y , imbuf + ( size_t ) <S2SV_ModStart> ) { ( void ) ResetMagickMemory ( imbuf + ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) == NULL ) { imbuf = (
<S2SV_ModStart> assert ( image -> signature == MagickCoreSignature ) ; pixel = 0 ;
<S2SV_ModStart> } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( CheckMemoryOverflow <S2SV_ModEnd> ( ( image -> columns + 7UL ) >> <S2SV_ModStart> ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModEnd> max_packets = ( size_t ) ( number_pixels * viff_info <S2SV_ModStart> ) ( number_pixels * viff_info . number_data_bands ) ; }
<S2SV_ModStart> size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if (
<S2SV_ModStart> char * p ; size_t bytes_per_line , extent , height , <S2SV_ModStart> length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; <S2SV_ModEnd> height = sun_info . height ; if ( ( <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> unsigned char * ) RelinquishMagickMemory ( sun_data ) ; <S2SV_ModEnd> p = sun_pixels ; if ( sun_info . depth
<S2SV_ModStart> unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> unsigned char * ) RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
<S2SV_ModStart> . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> hex_digits ) ; if ( c < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ = ( unsigned char ) c <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ = ( unsigned char ) c
<S2SV_ModStart> == MagickFalse ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> ; pixel = ScaleShortToQuantum ( nibble ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t bit , number_bits ; number_bits = image <S2SV_ModStart> ; bit < number_bits ; bit ++ ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( ( ( unsigned char ) pixel ) <S2SV_ModStart> ) != 0 ? 0 : 255 , q , exception <S2SV_ModEnd> ) ; q += GetPixelChannels ( image ) ; <S2SV_ModStart> GetPixelChannels ( image ) ; x ++ ; } if ( x != image -> columns ) x -- ; continue ; } } <S2SV_ModEnd> return ( SyncAuthenticPixels ( image , exception ) )
<S2SV_ModStart> size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , <S2SV_ModStart> ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModStart> = image -> columns * image -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof (
<S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( pixels_length + image -> rows
<S2SV_ModStart> ( ssize_t ) length ; j ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ( * compact_pixels ) ; break ; } } <S2SV_ModEnd> compact_pixels ++ ; } } return ( i )
<S2SV_ModStart> OptionError , "InvalidGeometry" , "`%s\'" , option ) ; page_geometry = DestroyString ( page_geometry ) ;
<S2SV_ModStart> ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof ( * pixels ) ) ; if <S2SV_ModStart> = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels = ( unsigned char * ) GetVirtualMemoryBlob
<S2SV_ModStart> ( unsigned char * ) AcquireQuantumMemory ( packets + 257UL <S2SV_ModEnd> , image -> rows * sizeof ( * pixels
<S2SV_ModStart> x < ( ssize_t ) number_pixels ; x += 4 <S2SV_ModEnd> ) { for ( i = 0 ; i
<S2SV_ModStart> ( CoderEvent , GetMagickModule ( ) , "enter" ) ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if <S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" ) ; <S2SV_ModEnd> status = PersistPixelCache ( image , cache_filename , MagickTrue
<S2SV_ModStart> } switch ( sun_info . maptype ) { case RMT_NONE : break ; case
<S2SV_ModStart> = width ; image -> rows = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> + 1 ) < max_value ; depth ++ ) <S2SV_ModEnd> ; image -> depth = depth ; status =
<S2SV_ModStart> ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> if ( tga_info . colormap_type != 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> ) { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( depth <S2SV_ModEnd> ) ; i ++ ) scale [ i ] <S2SV_ModStart> scale != ( Quantum * ) NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red = scale [ pixel . red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green = scale [ pixel . green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
<S2SV_ModStart> image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) <S2SV_ModEnd> ) ; else return ( image -> columns *
<S2SV_ModStart> ) image -> columns ; x ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> ( k >= MaxHashTable ) k -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if ( hash_code [ k ] > 0
<S2SV_ModStart> ! sun_info . length ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; number_pixels = ( MagickSizeType ) image -> <S2SV_ModStart> sun_info . width ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 <S2SV_ModStart> depth + 15 ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line >>= 4 ; sun_pixels = ( <S2SV_ModStart> length , sun_pixels , bytes_per_line * height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
<S2SV_ModStart> = ReadBlobByte ( image ) ) != EOF ) if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; ( void ) fclose ( file ) ;
<S2SV_ModStart> , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } ( void ) fclose ( file )
<S2SV_ModStart> ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } } ( void ) fclose ( file
<S2SV_ModStart> ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } ( void ) fclose ( file )
<S2SV_ModStart> , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; unsigned char background_color [ 256 ] <S2SV_ModStart> number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_ModStart> number_planes ) + x * number_planes + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } p = pixels + offset ; <S2SV_ModEnd> for ( i = 0 ; i < (
<S2SV_ModStart> ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;
<S2SV_ModStart> ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) <S2SV_ModEnd> , sizeof ( * sun_data ) ) ; if <S2SV_ModStart> { size_t height ; height = sun_info . height <S2SV_ModEnd> ; if ( ( height == 0 ) ||
<S2SV_ModStart> 1 ? 65535 : 256 ; } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> if ( count != ( ssize_t ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } <S2SV_ModEnd> ( void ) ImportQuantumPixels ( image , ( CacheView
<S2SV_ModStart> page . height , MagickFalse , exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> -> matte = MagickFalse ; channel_image = mask ; }
<S2SV_ModStart> image -> number_meta_channels = StringToUnsignedLong ( options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) return ( DestroyImageList ( image ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ; do { image -> page . x = ( ssize_t ) <S2SV_ModStart> image ) ; image -> page . y = ( ssize_t ) <S2SV_ModStart> 22 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> colormap = ( unsigned char * ) NULL ; <S2SV_ModStart> < ( ssize_t ) map_length ; x ++ ) { <S2SV_ModStart> ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> if ( ( image_info -> ping != MagickFalse ) <S2SV_ModStart> 0 ; opcode = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> x = 0 ; y += operand ; break <S2SV_ModStart> : { operand = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> x += operand ; break ; } case ByteDataOp <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image -> rows - y - 1 <S2SV_ModStart> * number_planes ) + x * number_planes + plane ) <S2SV_ModStart> if ( ( offset < 0 ) || ( ( offset + operand * number_planes ) > ( ssize_t ) <S2SV_ModEnd> pixel_info_length ) ) { if ( number_colormaps != 0 <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> pixel = ( unsigned char ) ReadBlobByte ( image <S2SV_ModStart> ( image ) ; operand ++ ; offset = ( ssize_t ) ( <S2SV_ModStart> * number_planes ) + x * number_planes + plane ) <S2SV_ModStart> if ( ( offset < 0 ) || ( ( offset + operand * number_planes ) > ( ssize_t ) <S2SV_ModEnd> pixel_info_length ) ) { if ( number_colormaps != 0 <S2SV_ModStart> ; } opcode = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) ( * p & mask ) <S2SV_ModEnd> , & index , exception ) == MagickFalse ) <S2SV_ModStart> ) { if ( IsValidColormapIndex ( image , ( ssize_t <S2SV_ModEnd> ) ( x * map_length + ( * p <S2SV_ModStart> ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) <S2SV_ModStart> red ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) <S2SV_ModStart> green ) ; if ( IsValidColormapIndex ( image , ( ssize_t )
<S2SV_ModStart> exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> != 1 ) continue ; length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> MATLAB_HDR . identific , "MATLAB" , 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> filepos = TellBlob ( image ) ; while (
<S2SV_ModStart> , "MultidimensionalMatricesAreNotSupported" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_ModEnd> if ( image == ( Image * ) NULL <S2SV_ModStart> else AppendImageToList ( & image , screen ) ; status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> * p ; size_t bytes_per_line , extent , height <S2SV_ModEnd> ; ssize_t count , y ; SUNInfo sun_info ; <S2SV_ModStart> if ( image -> storage_class == PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ <S2SV_ModEnd> ; if ( SyncAuthenticPixels ( image , exception ) <S2SV_ModStart> 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( y = 0 ; y <
<S2SV_ModStart> iris_info . sans = ReadBlobMSBLong ( image ) ; count = <S2SV_ModEnd> ReadBlob ( image , sizeof ( iris_info . name <S2SV_ModStart> , ( unsigned char * ) iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" <S2SV_ModStart> . filler ) , iris_info . filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) <S2SV_ModEnd> ; image -> columns = iris_info . columns ; <S2SV_ModStart> 1 ? 65535 : 256 ; } if ( <S2SV_ModEnd> ( image_info -> ping != MagickFalse ) && (
<S2SV_ModStart> ) { FILE * input , * output ; MagickBooleanType status ; <S2SV_ModStart> ] ) ; return ( MagickFalse ) ; } status = MagickTrue ; <S2SV_ModStart> argc - 1 ) ; i ++ ) { <S2SV_ModEnd> input = fopen_utf8 ( argv [ i ] , <S2SV_ModStart> EOF ; c = fgetc ( input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; ( void ) fclose ( input ) ; ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; return ( status <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> c != '\\n' ) && ( c != '\\0' ) && ( c != EOF <S2SV_ModStart> [ 6 ] , white_point [ 2 ] ; if ( <S2SV_ModEnd> sscanf ( value , "%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g" , & chromaticity [ <S2SV_ModStart> 0 ] , & white_point [ 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity . red_primary . x = chromaticity <S2SV_ModStart> white_point . y = white_point [ 1 ] ; } <S2SV_ModStart> == 0 ) { int height , width ; if ( <S2SV_ModEnd> sscanf ( value , "%d<S2SV_blank>+X<S2SV_blank>%d" , & height , <S2SV_ModStart> , "%d<S2SV_blank>+X<S2SV_blank>%d" , & height , & width ) == 2 ) { <S2SV_ModEnd> image -> columns = ( size_t ) width ; <S2SV_ModStart> image -> rows = ( size_t ) height ; }
<S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ~
<S2SV_ModStart> * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> ) NULL ) goto FINISH_UNL ; ( void ) strncpy <S2SV_ModEnd> ( clone_info -> magick , magic_info -> name ,
<S2SV_ModStart> ; xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof ( * xcfdata ) ) ; if
<S2SV_ModStart> exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * pixels ; register ssize_t i ; <S2SV_ModStart> * * pixels ; register ssize_t i ; size_t columns , <S2SV_ModStart> 0 , number_threads * sizeof ( * pixels ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns <S2SV_ModStart> i ] = ( PixelChannels * ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof ( * * pixels ) ) <S2SV_ModStart> j = 0 ; j < ( ssize_t ) <S2SV_ModEnd> columns ; j ++ ) { register ssize_t k
<S2SV_ModStart> UndefinedGravity ? metrics . ascent : 0.0 ) ; ( void ) CloneString ( & draw_info -> geometry , <S2SV_ModEnd> geometry ) ; status = AnnotateImage ( image ,
<S2SV_ModStart> UndefinedGravity ? metrics . ascent : 0.0 ) ; ( void ) CloneString ( & draw_info -> geometry , <S2SV_ModEnd> geometry ) ; status = AnnotateImage ( image ,
<S2SV_ModStart> case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( <S2SV_ModStart> ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> : { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> ) { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ReadBlobMSBLong ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length > <S2SV_ModStart> ) { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> ( code >> 7 ) & 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> image -> columns - 1 ) ; x += 4 <S2SV_ModEnd> ) { index = ConstrainColormapIndex ( image , (
<S2SV_ModStart> , name [ MaxTextExtent ] ; Image * image ; int c <S2SV_ModStart> byte , bytes_per_line , height , length , padding <S2SV_ModEnd> , version , width ; assert ( image_info != <S2SV_ModStart> ) ; ( i += 2 ) ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) break <S2SV_ModEnd> ; * p ++ = ( unsigned char ) <S2SV_ModStart> ; * p ++ = ( unsigned char ) c <S2SV_ModEnd> ; if ( ( padding == 0 ) || <S2SV_ModStart> * p ++ = ( unsigned char ) ( c <S2SV_ModEnd> >> 8 ) ; } else for ( i <S2SV_ModStart> value = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) break ; * p ++ = ( unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) <S2SV_ModEnd> ; } p = data ; for ( y <S2SV_ModStart> if ( bit == 0 ) byte = ( unsigned int <S2SV_ModEnd> ) ( * p ++ ) ; SetPixelIndex (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( Image * image , short int <S2SV_ModStart> ; if ( c == EOF ) return ( - 1 <S2SV_ModEnd> ) ; } while ( ( c == '<S2SV_blank>' <S2SV_ModStart> ; if ( c == EOF ) return ( - 1 ) ; } return ( ( int ) <S2SV_ModEnd> value ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) <S2SV_ModEnd> ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> length = image -> rows * ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 ) ; if ( ( ( sun_info
<S2SV_ModStart> < 24 ) { size_t one ; image -> <S2SV_ModEnd> colors = sun_info . maplength ; one = 1 <S2SV_ModStart> -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } switch ( sun_info . maptype ) { case RMT_EQUAL_RGB : { unsigned char * sun_colormap <S2SV_ModEnd> ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory
<S2SV_ModStart> char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1
<S2SV_ModStart> pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) <S2SV_ModEnd> , bytes_per_pixel * sizeof ( * pixels ) )
<S2SV_ModStart> char * ) AcquireQuantumMemory ( ( size_t ) count + 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static MagickBooleanType InsertRow ( Image * image , ssize_t bpp <S2SV_ModEnd> , unsigned char * p , ssize_t y , <S2SV_ModStart> , ssize_t y , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) ; switch ( bpp ) { case 1 : { <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> 8 ; bit ++ ) { index = ( <S2SV_ModEnd> ( * p ) & ( 0x80 >> bit <S2SV_ModStart> ( * p ) & ( 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 : 0x00 ) ; SetPixelIndex ( <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> for ( bit = 0 ; bit < ( ssize_t ) ( <S2SV_ModStart> ) ; bit ++ ) { index = ( <S2SV_ModEnd> ( * p ) & ( 0x80 >> bit <S2SV_ModStart> ( * p ) & ( 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 : 0x00 ) ; SetPixelIndex ( <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } break ; } case 2 : { for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_ModEnd> index , q ) ; q += GetPixelChannels ( <S2SV_ModStart> index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) <S2SV_ModEnd> ; } if ( ( image -> columns % <S2SV_ModStart> image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } break ; } case 8 : { for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( BImgBuff == NULL ) goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> clone_info -> magick , magic_info -> name , MaxTextExtent - 1
<S2SV_ModStart> } ( void ) CloseBlob ( image ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )
<S2SV_ModStart> + w . w ; a = 1.0f / MagickMax ( w . x , MagickMax <S2SV_ModEnd> ( w . y , w . z )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static MagickBooleanType ConstructOrdering ( const size_t , const DDSVector4 * , const DDSVector3 , DDSVector4 * , DDSVector4 * , unsigned char * , size_t ) , <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> exception ) == MagickFalse ) return MagickFalse ; } return ( SkipRGBMipmaps ( image , dds_info , 4 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> exception ) == MagickFalse ) return MagickFalse ; } return ( SkipRGBMipmaps ( image , dds_info , 3 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> DDSVector3 * value ) { value -> x = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> x ) ) ; <S2SV_ModStart> -> x ) ) ; value -> y = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> y ) ) ; <S2SV_ModStart> -> y ) ) ; value -> z = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> z ) ) ;
<S2SV_ModStart> DDSVector4 * value ) { value -> x = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> x ) ) ; <S2SV_ModStart> -> x ) ) ; value -> y = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> y ) ) ; <S2SV_ModStart> -> y ) ) ; value -> z = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> z ) ) ; <S2SV_ModStart> -> z ) ) ; value -> w = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> w ) ) ;
<S2SV_ModStart> * entry ) + 2 ) ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ) ReadPropertySignedLong ( endian , q + 4 ) ; if ( components < 0 ) break
<S2SV_ModStart> i ; unsigned char buffer [ 4 ] ; unsigned int <S2SV_ModEnd> value ; if ( * length < 4 ) <S2SV_ModStart> unsigned char ) c ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 ] << 16 ; value |= <S2SV_ModStart> buffer [ 1 ] << 16 ; value |= ( unsigned int ) <S2SV_ModStart> buffer [ 2 ] << 8 ; value |= ( unsigned int ) <S2SV_ModStart> buffer [ 3 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> c ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 1 ] ; quantum . unsigned_value = <S2SV_ModStart> buffer [ 1 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned int ) buffer [ 3 ] << 24 ; value |= ( unsigned int ) buffer [ 2 ] << 16 ; value |= ( unsigned int ) buffer [ 1 ] << 8 ; value |= ( unsigned int ) buffer [ 0 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; } <S2SV_ModStart> ) ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 1 ] << 16 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ; value |= ( unsigned int ) buffer [ 3 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned short ) buffer [ 1 ] << 8 ; value |= ( unsigned short ) buffer [ 0 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; } <S2SV_ModStart> ) ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) buffer [ 1 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned int ) buffer [ 3 ] << 24 ; value |= ( unsigned int ) buffer [ 2 ] << 16 ; value |= ( unsigned int ) buffer [ 1 ] << 8 ; value |= ( unsigned int ) buffer [ 0 ] ; return ( value & 0xffffffff <S2SV_ModEnd> ) ; } value = ( unsigned int ) <S2SV_ModStart> ) ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 1 ] << 16 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ; value |= ( unsigned int ) buffer [ 3 ] ; return ( value & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> LSBEndian ) { value = ( unsigned short ) buffer [ 1 ] << 8 ; value |= ( unsigned short ) buffer [ 0 ] ; return ( value & 0xffff <S2SV_ModEnd> ) ; } value = ( unsigned short ) <S2SV_ModStart> ) ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) buffer [ 1 ] ; return ( value & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < ( ( ssize_t ) image -> columns - 3 <S2SV_ModEnd> ) ; x += 4 ) { index = <S2SV_ModStart> -> colormap + ( ssize_t ) index ) ; q ++ ; p <S2SV_ModEnd> ++ ; } if ( ( image -> columns <S2SV_ModStart> if ( ( image -> columns % 4 ) > <S2SV_ModEnd> 1 ) { index = ConstrainColormapIndex ( image , <S2SV_ModStart> if ( ( image -> columns % 4 ) > <S2SV_ModEnd> 2 ) { index = ConstrainColormapIndex ( image ,
<S2SV_ModStart> ; image -> columns = image -> rows = 1 <S2SV_ModEnd> ; image -> colors = 0 ; break ; <S2SV_ModStart> ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) <S2SV_ModEnd> ; break ; } case 1 : { if
<S2SV_ModStart> number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) <S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob ( image , 2 , magick
<S2SV_ModStart> ; ssize_t count , y ; unsigned char * last_row <S2SV_ModEnd> , * one_row , * ptr ; unsigned short <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; last_row <S2SV_ModEnd> = ( unsigned char * ) NULL ; if <S2SV_ModStart> NULL ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned char * ) AcquireQuantumMemory ( MagickMax <S2SV_ModStart> * image -> columns ) , sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned char * ) NULL ) ThrowReaderException <S2SV_ModStart> ; else one_row [ i + bit ] = last_row <S2SV_ModEnd> [ i + bit ] ; } } ( <S2SV_ModStart> ] ; } } ( void ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , bytes_per_row ) ; } } ptr <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if ( EOFBlob ( image ) !=
<S2SV_ModStart> info , & length ) ; if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
<S2SV_ModStart> . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception <S2SV_ModEnd> ) , q ) ; q += GetPixelChannels (
<S2SV_ModStart> image ) ; return ( image ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> , "MATLAB" , 6 ) ) { MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
<S2SV_ModStart> ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_ModEnd> if ( EOFBlob ( image ) != MagickFalse )
<S2SV_ModStart> ( chroma_image == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } <S2SV_ModEnd> if ( ( image_info -> ping != MagickFalse ) <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ( resize_image == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } <S2SV_ModEnd> for ( y = 0 ; y < ( <S2SV_ModStart> ) == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
<S2SV_ModStart> ( size_t ) ( ldblk ) , sizeof ( double <S2SV_ModEnd> ) ) ; if ( BImgBuff == NULL )
<S2SV_ModStart> ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModEnd> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap <S2SV_ModStart> ( volume ) num_images = dds_info . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> blend_dest = ReadBlobLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } if (
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ] . lines_per_image ; if ( image_info -> ping != MagickFalse <S2SV_ModStart> ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_ModEnd> if ( ( clone_info = CloneImageInfo ( image_info )
<S2SV_ModStart> ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ) image -> rows = geometry . height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) )
<S2SV_ModStart> ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ( size_t ) ( level * cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = 240 ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ldblk = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> filepos = TellBlob ( image ) ; while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> ) { Frames = 1 ; if ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break ; if ( SeekBlob ( image , <S2SV_ModStart> MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= <S2SV_ModEnd> GetBlobSize ( image ) ) goto MATLAB_KO ; filepos <S2SV_ModStart> . SizeY - i - 1 ) ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; } } <S2SV_ModEnd> Finish : ( void ) CloseBlob ( image )
<S2SV_ModStart> * ) NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image = SyncNextImageInList ( image ) ;
<S2SV_ModStart> ) == ( Image * ) NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image = SyncNextImageInList ( image ) ;
<S2SV_ModStart> ) image -> columns ; x ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> ( k >= MaxHashTable ) k -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if ( hash_code [ k ] > 0
<S2SV_ModStart> if ( BImgBuff == NULL ) goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * pixels ; register ssize_t i , <S2SV_ModStart> pixels ; register ssize_t i , j ; size_t columns , <S2SV_ModStart> number_threads * sizeof ( * pixels ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 ; i < ( ssize_t ) <S2SV_ModStart> i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof ( * * pixels ) ) <S2SV_ModStart> j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels [ i ] [ j ]
<S2SV_ModStart> OptionError , "InvalidGeometry" , "`%s\'" , option ) ; geometry = DestroyString ( geometry ) ;
<S2SV_ModStart> register ssize_t i , j ; size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) <S2SV_ModEnd> ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory <S2SV_ModStart> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( rows <S2SV_ModEnd> , sizeof ( * pixels ) ) ; if <S2SV_ModStart> ( ( MagickPixelPacket * * ) NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 ; i < ( ssize_t ) rows <S2SV_ModEnd> ; i ++ ) { pixels [ i ]
<S2SV_ModStart> base_uri ) { gchar * absolute_filename ; if ( <S2SV_ModEnd> g_path_is_absolute ( filename ) ) { absolute_filename = g_strdup
<S2SV_ModStart> i ] = tolower ( mechbuf [ i ] ) ; log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf
<S2SV_ModStart> ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
<S2SV_ModStart> - 1 , "type" , "valid" ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> , "valid" ) ; if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PHP_FUNCTION ( radius_get_vendor_attr ) { const void * data , * raw ; int len ; u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModEnd> ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC <S2SV_ModStart> ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & raw <S2SV_ModEnd> , & len ) == FAILURE ) { return <S2SV_ModStart> len ) == FAILURE ) { return ; } if ( rad_get_vendor_attr ( & vendor , & type , & data , & data_len , raw , len ) <S2SV_ModEnd> == - 1 ) { RETURN_FALSE ; } else <S2SV_ModStart> return_value ) ; add_assoc_long ( return_value , "attr" , type <S2SV_ModEnd> ) ; add_assoc_long ( return_value , "vendor" , vendor <S2SV_ModStart> , "data" , ( char * ) data , data_len <S2SV_ModEnd> , 1 ) ; return ; } } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int rad_get_vendor_attr ( u_int32_t * vendor , unsigned char * type <S2SV_ModStart> const void * * data , size_t * len , const void * raw , size_t raw_len ) { struct vendor_attribute * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } attr = ( struct vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor = ntohl ( attr -> vendor_value <S2SV_ModStart> * vendor = ntohl ( attr -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> * len = attr -> attrib_len - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }
<S2SV_ModStart> array = NULL ; struct unfold_elm * ue ; if ( tree_root == NULL ) return 0 <S2SV_ModEnd> ; fprintf ( stdout , "<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>" ) ; fflush
<S2SV_ModStart> argc , char * argv [ ] ) { int ret_value = 0 ; <S2SV_ModStart> ; else fprintf ( stdout , "\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n" ) ; ret_value = write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled." , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>" <S2SV_ModEnd> , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( )
<S2SV_ModStart> if ( fop == NULL ) return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
<S2SV_ModStart> * mdi ; uint32_t tmp_val ; uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; <S2SV_ModStart> sizeof ( uint8_t * ) * no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data ++ ; midi_size -= 4 ; <S2SV_ModStart> ; midi_size -= 4 ; if ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT <S2SV_ModStart> 0 ) ; goto _end ; } if ( tmp_val <S2SV_ModEnd> < 3 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ <S2SV_ModStart> goto _end ; } if ( ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] != 0xFF ) || ( midi_data <S2SV_ModStart> 3 ] != 0xFF ) || ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] != 0x2F ) || ( midi_data <S2SV_ModStart> 2 ] != 0x2F ) || ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] != 0x00 ) ) { _WM_GLOBAL_ERROR <S2SV_ModStart> ; } tracks [ i ] = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ i ] = 0 ; running_event <S2SV_ModStart> 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> & 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- <S2SV_ModStart> _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , <S2SV_ModStart> 1 ; tracks [ i ] += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> } } tracks [ i ] += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> [ i ] > 0x7f ) { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> tracks [ i ] > 0x7f ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> & 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- <S2SV_ModStart> _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , <S2SV_ModStart> } } tracks [ i ] += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> [ i ] > 0x7f ) { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> tracks [ i ] > 0x7f ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> & 0x7F ) ; tracks [ i ] ++ ; track_size [ i ] -- <S2SV_ModStart> ( running_event ) ; free ( tracks ) ; free ( track_size ) ;
<S2SV_ModStart> = 0 ; size_t offset ; M_fs_error_t res ; <S2SV_ModEnd> res = M_fs_file_open ( & fd_old , path_old ,
<S2SV_ModStart> unsigned long long ) program_start ) ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> ( ) == ERROR ) { exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; } logit ( NSLOG_PROCESS_INFO , TRUE ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int open_debug_log ( void ) { int fh ; struct stat st ; <S2SV_ModStart> == DEBUGL_NONE ) return OK ; if ( ( fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ; if ( ( debug_file_fp = fdopen ( fh <S2SV_ModEnd> , "a+" ) ) == NULL ) return ERROR <S2SV_ModStart> "a+" ) ) == NULL ) return ERROR ; if ( ( fstat ( fh , & st ) ) == - 1 ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } ( void ) fcntl ( fh <S2SV_ModEnd> , F_SETFD , FD_CLOEXEC ) ; return OK ;
<S2SV_ModStart> <S2SV_null> static FILE * open_log_file ( void ) { int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , log_file ) ; return NULL ; } log_fp = fdopen ( fh <S2SV_ModEnd> , "a+" ) ; if ( log_fp == NULL <S2SV_ModStart> NULL ) { if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , log_file ) ; return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>fstat<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>mode\\n" , log_file ) ; <S2SV_ModEnd> return NULL ; } ( void ) fcntl (
<S2SV_ModStart> if ( res != TEE_SUCCESS ) return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; params = malloc ( alloc_size <S2SV_ModEnd> ) ; if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY
<S2SV_ModStart> , & tee_mm_sec_ddr ) ; if ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> mobj_get_va ( mobj , 0 ) , 0 , ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> return mobj ; # endif } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> uaddr , size_t len ) { uaddr_t a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> if ( ADD_OVERFLOW ( uaddr , len , & end_addr <S2SV_ModEnd> ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags <S2SV_ModStart> ) ) return TEE_ERROR_ACCESS_DENIED ; for ( a = ROUNDDOWN ( uaddr , addr_incr ) ; a < end_addr <S2SV_ModEnd> ; a += addr_incr ) { uint32_t attr ;
<S2SV_ModStart> if ( res != TEE_SUCCESS ) return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; params = malloc ( alloc_size <S2SV_ModEnd> ) ; if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY
<S2SV_ModStart> key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; params = malloc ( alloc_size <S2SV_ModEnd> ) ; if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY
<S2SV_ModStart> ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; attrs = malloc ( alloc_size <S2SV_ModEnd> ) ; if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY
<S2SV_ModStart> if ( res != TEE_SUCCESS ) return res ; res = utee_param_to_param ( utc , param , callee_params ) ; if ( res != TEE_SUCCESS ) return res <S2SV_ModEnd> ; } if ( called_sess && is_pseudo_ta_ctx ( called_sess
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * p , struct utee_params * up <S2SV_ModStart> vals [ n * 2 + 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> TEE_PARAM_TYPE_GET ( types , n ) ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> u [ n ] . mem <S2SV_ModStart> n ] . mem . size = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> n ] ) ) ; break ; } } return TEE_SUCCESS ;
<S2SV_ModStart> * rmem , struct param_mem * mem ) { size_t req_size = 0 ; <S2SV_ModStart> size = READ_ONCE ( rmem -> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
<S2SV_ModStart> ( serial -> value , priv -> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL
<S2SV_ModStart> . array [ x ] . objectId . id ; if ( bufLen < 2 ) break <S2SV_ModStart> ; buf += 2 ; count += 2 ; bufLen -= 2 ;
<S2SV_ModStart> . resp [ i + 1 ] ) { size_t <S2SV_ModEnd> j , len = apdu . resp [ i <S2SV_ModStart> [ 1 ] ; break ; case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; memcpy ( file -> name , d , file -> namelen ) <S2SV_ModEnd> ; break ; case 0x86 : sc_file_set_sec_attr ( file
<S2SV_ModStart> SC_LOG_DEBUG_NORMAL , r , "read<S2SV_blank>document<S2SV_blank>number<S2SV_blank>failed" ) ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0' ; set_string ( & p15card ->
<S2SV_ModStart> ; while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max
<S2SV_ModStart> card -> ctx , r , "Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut" ) ; if ( len > 0 ) { <S2SV_ModStart> = ptr ; priv -> EF_C_DevAut_len = len ; }
<S2SV_ModStart> return SC_ERROR_INVALID_ARGUMENTS ; } if ( sec_attr == NULL || sec_attr_len
<S2SV_ModStart> method == SC_AC_NEVER ) return 10 ; bufsize = MIN ( file -> size , sizeof buf ) <S2SV_ModEnd> ; sc_file_free ( file ) ; r = sc_read_binary
<S2SV_ModStart> ) ) ; return 2 ; } bufsize = MIN ( file -> size , sizeof buf ) <S2SV_ModEnd> ; sc_file_free ( file ) ; r = sc_read_binary
<S2SV_ModStart> ) { goto err ; } len = file && file -> size > 0
<S2SV_ModStart> ( buf , "????" ) ; break ; } strncat ( line , buf , sizeof line ) ; strncat ( line , "<S2SV_blank>" , sizeof line <S2SV_ModEnd> ) ; e = e -> next ; } <S2SV_ModStart> e = e -> next ; } line [ ( sizeof line ) - 1 ] = '\\0' ; line [ strlen ( line ) - 1 ] = <S2SV_ModEnd> 0 ; return line ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> out = ( u8 * ) outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left <S2SV_ModEnd> ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL <S2SV_ModStart> ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; zero_bits = * in & 0x07 ; octets_left = inlen - 1 ; in ++ ; memset ( outbuf , 0 , outlen )
<S2SV_ModStart> ( ( entry -> flags & SC_ASN1_UNSIGNED ) && objlen > 1 && obj [ 0 ] == 0x00 <S2SV_ModEnd> ) { objlen -- ; obj ++ ; }
<S2SV_ModStart> unsigned char challenge [ 30 ] ; unsigned char * signature = NULL ; unsigned int siglen <S2SV_ModEnd> ; const EVP_MD * md = EVP_sha1 ( ) <S2SV_ModStart> pubkey = PKCS11_get_public_key ( authkey ) ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> err ; } ok = 1 ; err : free ( signature ) ;
<S2SV_ModStart> * sud ) { size_t size , len ; <S2SV_ModEnd> WCHAR * data = NULL ; DWORD bytes , <S2SV_ModStart> ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; goto err <S2SV_ModEnd> ; } size = bytes / sizeof ( * <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } data = malloc ( bytes ) ; <S2SV_ModStart> ; ReturnLastError ( pipe , L"malloc" ) ; goto err <S2SV_ModEnd> ; } read = ReadPipeAsync ( pipe , data <S2SV_ModStart> ; ReturnLastError ( pipe , L"ReadPipeAsync" ) ; goto err <S2SV_ModEnd> ; } if ( data [ size - 1 <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> directory = data ; len <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> options = sud -> directory <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> std_input = sud -> options <S2SV_ModStart> -> std_input = sud -> options + len ; return TRUE ; err : sud -> directory = NULL ; free ( data ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , err_name_ptr ) ; if ( ( fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) == - 1 ) { error ( <S2SV_ModStart> ) ) == - 1 ) { error ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied" , path_name <S2SV_ModEnd> ) ; return ; } snprintf ( err_name ,
<S2SV_ModStart> 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE <S2SV_ModEnd> ) ; strcpy ( t1_line_array , t1_buf_array ) ;
<S2SV_ModStart> t1_buf_array , t1_line_array ) ; t1_getline ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE <S2SV_ModEnd> ) ; strcpy ( t1_line_array , t1_buf_array ) ;
<S2SV_ModStart> 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE <S2SV_ModEnd> ) ; strcpy ( t1_line_array , t1_buf_array ) ;
<S2SV_ModStart> * me , const char * s ) { HTChunk * target = NULL ; <S2SV_ModStart> { case HTML_COMMENT : break ; case HTML_TITLE : target = & me -> title ; break ; case HTML_STYLE : target = & me -> style_block ; break ; case HTML_SCRIPT : target = & me -> script <S2SV_ModEnd> ; break ; case HTML_PRE : case HTML_LISTING : <S2SV_ModStart> , s ) ; break ; case HTML_OBJECT : target = & me -> object ; break ; case HTML_TEXTAREA : target = & me -> textarea <S2SV_ModEnd> ; break ; case HTML_SELECT : case HTML_OPTION : <S2SV_ModStart> ; break ; case HTML_SELECT : case HTML_OPTION : target = & me -> option ; break ; case HTML_MATH : target = & me -> math <S2SV_ModEnd> ; break ; default : if ( ! me <S2SV_ModStart> text , c ) ; } } } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , "BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }
<S2SV_ModStart> r , "Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; }
<S2SV_ModStart> ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break ; case OBJECT_TYPE_FUNCTION : func = (
<S2SV_ModStart> assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule (
<S2SV_ModStart> ( yyn ) { case 2 : # line 113 <S2SV_ModEnd> "hex_grammar.y" { RE_AST * re_ast = yyget_extra ( yyscanner <S2SV_ModStart> 1 ] . re_node ) ; } # line 1337 "hex_grammar.c" break ; case 3 : # line 122 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> 0 ] . re_node ) ; } # line 1345 "hex_grammar.c" break ; case 4 : # line 126 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT <S2SV_ModStart> == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } # line 1360 "hex_grammar.c" break ; case 5 : # line 137 <S2SV_ModEnd> "hex_grammar.y" { RE_NODE * new_concat ; RE_NODE * leftmost_concat <S2SV_ModStart> = ( yyvsp [ - 1 ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } # line 1424 "hex_grammar.c" break ; case 6 : # line 201 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> 0 ] . re_node ) ; } # line 1432 "hex_grammar.c" break ; case 7 : # line 205 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT <S2SV_ModStart> == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } # line 1447 "hex_grammar.c" break ; case 8 : # line 220 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> 0 ] . re_node ) ; } # line 1455 "hex_grammar.c" break ; case 9 : # line 224 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> ) -> greedy = FALSE ; } # line 1464 "hex_grammar.c" break ; case 10 : # line 233 <S2SV_ModEnd> "hex_grammar.y" { lex_env -> token_count ++ ; if ( <S2SV_ModStart> 0 ] . re_node ) ; } # line 1481 "hex_grammar.c" break ; case 11 : # line 246 <S2SV_ModEnd> "hex_grammar.y" { lex_env -> inside_or ++ ; } # <S2SV_ModStart> { lex_env -> inside_or ++ ; } # line 1489 "hex_grammar.c" break ; case 12 : # line 250 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> ; lex_env -> inside_or -- ; } # line 1498 "hex_grammar.c" break ; case 13 : # line 259 <S2SV_ModEnd> "hex_grammar.y" { if ( ( yyvsp [ - 1 <S2SV_ModStart> 1 ] . integer ) ; } # line 1525 "hex_grammar.c" break ; case 14 : # line 282 <S2SV_ModEnd> "hex_grammar.y" { if ( lex_env -> inside_or && ( <S2SV_ModStart> 1 ] . integer ) ; } # line 1561 "hex_grammar.c" break ; case 15 : # line 314 <S2SV_ModEnd> "hex_grammar.y" { if ( lex_env -> inside_or ) { <S2SV_ModStart> ) -> end = INT_MAX ; } # line 1587 "hex_grammar.c" break ; case 16 : # line 336 <S2SV_ModEnd> "hex_grammar.y" { if ( lex_env -> inside_or ) { <S2SV_ModStart> ) -> end = INT_MAX ; } # line 1607 "hex_grammar.c" break ; case 17 : # line 356 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = ( <S2SV_ModStart> 0 ] . re_node ) ; } # line 1615 "hex_grammar.c" break ; case 18 : # line 360 "hex_grammar.y" { mark_as_not_fast_regexp ( ) ; incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT <S2SV_ModStart> == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } # line 1631 "hex_grammar.c" break ; case 19 : # line 375 <S2SV_ModEnd> "hex_grammar.y" { ( yyval . re_node ) = yr_re_node_create <S2SV_ModStart> 0 ] . integer ) ; } # line 1643 "hex_grammar.c" break ; case 20 : # line 383 <S2SV_ModEnd> "hex_grammar.y" { uint8_t mask = ( uint8_t ) ( <S2SV_ModStart> -> mask = mask ; } } # line 1667 "hex_grammar.c" break ; # line 1671 <S2SV_ModEnd> "hex_grammar.c" default : break ; } YY_SYMBOL_PRINT ( "-><S2SV_blank>$$<S2SV_blank>="
<S2SV_ModStart> ( yytype ) { case 16 : # line 101 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 "hex_grammar.c" break ; case 17 : # line 102 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 "hex_grammar.c" break ; case 18 : # line 103 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 "hex_grammar.c" break ; case 19 : # line 104 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 "hex_grammar.c" break ; case 21 : # line 107 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 "hex_grammar.c" break ; case 22 : # line 106 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 "hex_grammar.c" break ; case 23 : # line 105 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "hex_grammar.c" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END
<S2SV_ModStart> ; if ( text [ 1 ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ] = RE_YY_INPUT ( yyscanner ) ; if ( ! isxdigit ( text [ 2 ] ) <S2SV_ModEnd> ) return 0 ; text [ 3 ] = <S2SV_ModStart> ] = RE_YY_INPUT ( yyscanner ) ; if ( ! isxdigit ( text [ 3 ] ) <S2SV_ModEnd> ) return 0 ; } * escaped_char = escaped_char_value
<S2SV_ModStart> assert_true_regexp ( "whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x" , "<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x" , "<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x" ) ; assert_regexp_syntax_error ( "\\\\x0" ) ; assert_regexp_syntax_error ( "\\\\x" ) ; assert_regexp_syntax_error ( "\\\\xxy" ) ;
<S2SV_ModStart> 2 , module_object , "integer_array[%i]" , 2 ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> array -> items == NULL ) { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> items = ( YR_ARRAY_ITEMS * ) <S2SV_ModStart> = array -> items -> count * 2 ; while ( count <= index ) count *= 2 ;
<S2SV_ModStart> assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule (
<S2SV_ModStart> uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags , RE_MATCH_CALLBACK_FUNC callback , void * <S2SV_ModStart> ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog { if ( ( bytes_matched >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } } # define fail_if_error ( e ) { <S2SV_ModEnd> switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return <S2SV_ModStart> 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_ModStart> character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> -= character_size ; input_incr = - input_incr ; } else { max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ; } <S2SV_ModEnd> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched <S2SV_ModStart> break ; case RE_OPCODE_WORD_CHAR : prolog ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action = match ? ACTION_NONE : ACTION_KILL <S2SV_ModStart> ; case RE_OPCODE_NON_WORD_CHAR : prolog ; match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action = match ? ACTION_NONE : ACTION_KILL <S2SV_ModStart> case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && input_backwards_size < character_size ) { match = TRUE ; } else if ( bytes_matched >= max_bytes_matched ) { match = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert ( input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) match = <S2SV_ModStart> : if ( flags & RE_FLAGS_BACKWARDS ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t ) bytes_matched ; else kill = <S2SV_ModStart> > ( size_t ) bytes_matched ; else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched != 0 ) ; action = <S2SV_ModStart> case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t ) bytes_matched ; action = kill <S2SV_ModStart> ( error ) ; fiber = next_fiber ; } <S2SV_ModEnd> } input += input_incr ; bytes_matched += character_size ;
<S2SV_ModStart> uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags , RE_MATCH_CALLBACK_FUNC callback , void * <S2SV_ModStart> sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1
<S2SV_ModStart> * ) target , strlen ( target ) , 0 ,
<S2SV_ModStart> data + offset , data_size - offset , offset , <S2SV_ModEnd> flags , NULL , NULL ) ; } if <S2SV_ModStart> data + offset , data_size - offset , offset , <S2SV_ModEnd> flags , NULL , NULL ) ; } switch <S2SV_ModStart> = exec ( ac_match -> backward_code , data + offset , data_size -
<S2SV_ModStart> ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>8<S2SV_blank>}" , "a\\0x\\0x\\0b\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\ta\\0b\\0c\\0" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\ta\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0x\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0b\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "abc" ) ;
<S2SV_ModStart> flags = 0 ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) ->
<S2SV_ModStart> <= repeat_any_args -> max ; i ++ ) { <S2SV_ModEnd> if ( bytes_matched + i >= max_bytes_matched ) break <S2SV_ModStart> if ( bytes_matched + i >= max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched += repeat_any_args -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
<S2SV_ModStart> callback_args -> data ; match_length += callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
<S2SV_ModStart> resp , & resplen ) == U2FH_OK ) { int offs = sizeof ( nonce ) ; if ( resplen < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } dev -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 ; dev -> versionInterface = resp [ offs ++ ] ; dev -> versionMajor = resp [ offs ++ ] ; dev -> versionMinor = resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] ; dev -> capFlags = resp [ offs ++ ] <S2SV_ModEnd> ; } else { return U2FH_TRANSPORT_ERROR ; } return
<S2SV_ModStart> open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> , pam_strerror ( pamh , retval ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
<S2SV_ModStart> * * argv , cfg_t * cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> FILE * ) - 1 ; } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd , & st ) == 0 ) && <S2SV_ModEnd> S_ISREG ( st . st_mode ) ) { file <S2SV_ModStart> ( st . st_mode ) ) { file = fdopen ( fd <S2SV_ModEnd> , "a" ) ; if ( file != NULL <S2SV_ModStart> NULL ) { cfg -> debug_file = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } } } } if ( cfg -> <S2SV_ModStart> ? cfg -> prompt : "(null)" ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;
<S2SV_ModStart> 0 ; fd = open ( authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; if ( fd < 0 ) { <S2SV_ModStart> , strerror ( errno ) ) ; goto err ; } else { fd = - 1 <S2SV_ModStart> if ( opwfile ) fclose ( opwfile ) ; if ( fd != - 1 <S2SV_ModEnd> ) close ( fd ) ; return retval ;
<S2SV_ModStart> NULL ; unsigned n_devices = 0 ; int openasuser = 0 <S2SV_ModStart> int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> ; retval = PAM_IGNORE ; goto done ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> authfile_dir_len , "%s%s" , authfile_dir , DEFAULT_AUTHFILE ) ; if ( ! openasuser ) { DBG ( "WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>" "consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration" , buf ) ; } } DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" <S2SV_ModEnd> , buf ) ; cfg -> auth_file = buf <S2SV_ModStart> ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; } if ( ! openasuser ) { openasuser <S2SV_ModEnd> = geteuid ( ) == 0 && cfg -> <S2SV_ModStart> ( ) == 0 && cfg -> openasuser ; } if ( openasuser ) { DBG ( "Dropping<S2SV_blank>privileges" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw ) ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> pw_uid ) <S2SV_ModEnd> ; retval = PAM_IGNORE ; goto done ; } <S2SV_ModStart> ; goto done ; } DBG ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) ; } retval = get_devices_from_authfile ( cfg <S2SV_ModStart> ) ; if ( openasuser ) { if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( "could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges" <S2SV_ModEnd> ) ; retval = PAM_IGNORE ; goto done ; <S2SV_ModStart> = PAM_IGNORE ; goto done ; } DBG ( "Restored<S2SV_blank>privileges" <S2SV_ModEnd> ) ; } if ( retval != 1 )
<S2SV_ModStart> debug_file , "Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s" , username , otp_id ) ; fclose ( opwfile ) ;
<S2SV_ModStart> user_pwd ) ; unlink ( core_basename ) ; } # if 0 <S2SV_ModStart> ; } close ( src_fd ) ; } } # endif
<S2SV_ModStart> pid ) ; dd_create_basic_files ( dd , fsuid , <S2SV_ModEnd> NULL ) ; char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name"
<S2SV_ModStart> = xasprintf ( "/proc/self/fd/%d" , build_ids_fd ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR "/abrt-tmp-debuginfo.XXXXXX" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory" ) ; log_info ( "Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; { const char * verbs [ ] <S2SV_ModStart> args [ i ++ ] = repo ; } args [ i ++ ] = "--tmpdir" ; args [ i ++ ] = tmp_directory ; <S2SV_ModStart> path_env ) ; umask ( 0022 ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( "fork" ) ; if ( pid == 0 ) { <S2SV_ModStart> ) ; error_msg_and_die ( "Can\'t<S2SV_blank>execute<S2SV_blank>%s" , EXECUTABLE ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( "waitpid" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( "Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( "Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( "Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d" , WTERMSIG ( status ) ) ; error_msg_and_die ( "Child<S2SV_blank>exit<S2SV_blank>failed" ) ;
<S2SV_ModStart> * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid <S2SV_ModStart> ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; }
<S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( source_filename + source_base_ofs , "limits" <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( source_filename + source_base_ofs , "cgroup" <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid <S2SV_ModEnd> ) ; free ( dest_filename ) ; dd_save_text (
<S2SV_ModStart> struct dump_dir * dd = dd_create ( path , g_settings_privatereports ? 0 :
<S2SV_ModStart> dirname , g_settings_dump_location ) ; return 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( "abrt" ) ; if ( ! gr ) { error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; return 403 ; } } else
<S2SV_ModStart> "ShortenedReporting" ) ; } else g_settings_shortenedreporting = 0 ; value = get_map_string_item_or_NULL ( settings , "PrivateReports" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , "PrivateReports" ) ; }
<S2SV_ModStart> DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> { FILE * fp = fopen ( dest_filename , "wx" <S2SV_ModEnd> ) ; if ( ! fp ) return false
<S2SV_ModStart> save_items_from_notepad ( ) ; save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0
<S2SV_ModStart> , new_value ) ; dd_close ( dd ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) { <S2SV_ModStart> ( GTK_TEXT_VIEW ( textview ) , item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }
<S2SV_ModStart> open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW
<S2SV_ModStart> FILE * pidfile = NULL ; int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH )
<S2SV_ModStart> = NULL ; f = fopen ( filepath , "r" <S2SV_ModEnd> ) ; if ( f ) { fseek (
<S2SV_ModStart> debug ) ) { if ( ( tf = fopen_safe <S2SV_ModEnd> ( tfile -> file_path , "w" ) ) )
<S2SV_ModStart> vrrp_print_data ( void ) { FILE * file = fopen_safe <S2SV_ModEnd> ( dump_file , "w" ) ; if ( !
<S2SV_ModStart> prog , namespace , instance ) ; log_file = fopen_safe <S2SV_ModEnd> ( file_name , "a" ) ; if ( log_file
<S2SV_ModStart> fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
<S2SV_ModStart> ( stderr , "Invalid<S2SV_blank>--umask<S2SV_blank>option<S2SV_blank>%s" , optarg ) ; return 0
<S2SV_ModStart> curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val <S2SV_ModStart> "no-syslog" , no_argument , NULL , 'G' } , { "umask" , required_argument , NULL , 'u' } , <S2SV_ModStart> ( c = getopt_long ( argc , argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" <S2SV_ModEnd> # if defined _WITH_VRRP_ && defined _WITH_LVS_ "PC" # <S2SV_ModStart> ) ; reopen_log = true ; break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case
<S2SV_ModStart> ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n" ) ;
<S2SV_ModStart> void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; ACPI_OPERAND_OBJECT * Prev ; ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModEnd> ; Next = AcpiGbl_ModuleCodeList ; while ( Next ) <S2SV_ModStart> = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex (
<S2SV_ModStart> len ) ; assert ( plen <= * len && plen > 0
<S2SV_ModStart> * pid ; plen = len - 2 ; if ( plen < 0 ) return 0 ;
<S2SV_ModStart> LPCSTR arg , bool format ) { LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> = s + 1 ; if ( s ) { tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> , ds * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> : 4 ; ds += len - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> tmp , ds * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> : 4 ; ds += len - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> tmp , ds * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> break ; case '\\'' : ds += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> tmp , ds * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> break ; case \'"\' : ds += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> tmp , ds * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> break ; case '&' : ds += 4 ; tmp2 <S2SV_ModEnd> = ( LPSTR ) realloc ( tmp , ds <S2SV_ModStart> * sizeof ( CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
<S2SV_ModStart> L , 3 , 1 ) - 1 ; int n = 0 ; defaultoptions ( & h <S2SV_ModEnd> ) ; while ( * fmt ) { int <S2SV_ModStart> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; luaL_checkstack ( L , 2 <S2SV_ModEnd> , "too<S2SV_blank>many<S2SV_blank>results" ) ; switch ( opt ) { <S2SV_ModStart> ) ; lua_pushnumber ( L , res ) ; n ++ ; <S2SV_ModStart> ) ; lua_pushnumber ( L , f ) ; n ++ ; <S2SV_ModStart> ) ; lua_pushnumber ( L , d ) ; n ++ ; <S2SV_ModStart> if ( size == 0 ) { if ( n == 0 || <S2SV_ModStart> , - 1 ) ) luaL_error ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" <S2SV_ModEnd> ) ; size = lua_tonumber ( L , - <S2SV_ModStart> ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size <S2SV_ModEnd> , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; } lua_pushlstring ( <S2SV_ModStart> ( L , data + pos , size ) ; n ++ <S2SV_ModStart> data + pos , size - 1 ) ; n ++ ; <S2SV_ModStart> ( L , pos + 1 ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> case '!' : { int a = getnum ( <S2SV_ModEnd> fmt , MAXALIGN ) ; if ( ! isp2
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int getnum ( <S2SV_ModEnd> const char * * fmt , int df ) <S2SV_ModStart> else { int a = 0 ; do { <S2SV_ModEnd> a = a * 10 + * ( (
<S2SV_ModStart> return 1 ; case 'c' : return getnum ( <S2SV_ModEnd> fmt , 1 ) ; case 'i' : case <S2SV_ModStart> case 'I' : { int sz = getnum ( <S2SV_ModEnd> fmt , sizeof ( int ) ) ; if
<S2SV_ModStart> ) return luaL_argerror ( L , 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."
<S2SV_ModStart> ; int index = 1 ; lua_newtable ( L ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"
<S2SV_ModStart> mp_encode_array ( L , buf , len ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array" ) ;
<S2SV_ModStart> , int level ) { size_t len = 0 ; luaL_checkstack ( L , 3 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map" )
<S2SV_ModStart> ; i <= nargs ; i ++ ) { luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_check" ) ;
<S2SV_ModStart> int offset = len - c . left ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_unpack_full" ) ;
<S2SV_ModStart> ( j % 4 ) == 0 ) { int class = getClientTypeByName ( v [ j ] ) ; if ( class == - 1 || class == CLIENT_TYPE_MASTER <S2SV_ModEnd> ) { sdsfreesplitres ( v , vlen ) ;
<S2SV_ModStart> int soft_seconds ; if ( class == - 1 || class == CLIENT_TYPE_MASTER ) { err = "Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>" "an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits." <S2SV_ModEnd> ; goto loaderr ; } hard = memtoll (
<S2SV_ModStart> ) break ; if ( c -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break ; if ( ! c -> reqtype
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void cliRefreshPrompt ( void ) { if ( config . eval_ldb ) return ; sds prompt = sdsempty ( ) <S2SV_ModEnd> ; if ( config . hostsocket != NULL ) <S2SV_ModStart> ; if ( config . hostsocket != NULL ) { prompt = sdscatfmt ( prompt , "redis<S2SV_blank>%s" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , "[%i]" , config . dbnum ) ; prompt = sdscatlen ( prompt , "><S2SV_blank>" , 2 ) ; <S2SV_ModEnd> snprintf ( config . prompt , sizeof ( config <S2SV_ModStart> prompt , sizeof ( config . prompt ) , "%s" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> . nokeyerr ) ; if ( o == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> = luaL_optinteger ( L , 3 , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , "offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater" ) ; pos -- <S2SV_ModEnd> ; int n = 0 ; defaultoptions ( & <S2SV_ModStart> opt , size ) ; luaL_argcheck ( L , size <= ld && pos <= ld - size <S2SV_ModEnd> , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; luaL_checkstack ( L
<S2SV_ModStart> ; luaC_checkGC ( L ) ; tf = ( <S2SV_ModEnd> luaY_parser ) ( L , p -> z ,
<S2SV_ModStart> ( ! stream ) { ap_log_cerror ( APLOG_MARK , APLOG_DEBUG <S2SV_ModEnd> , 0 , session -> c , APLOGNO ( <S2SV_ModStart> const char * ) value , valuelen ) ; if ( status == APR_ECONNRESET ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , "h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream" , session -> id , stream -> id ) ; nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ; } else
<S2SV_ModStart> const char * value , size_t vlen ) { int error = 0 ; ap_assert ( stream ) ; if ( stream -> has_response ) { return APR_EINVAL ; } ++ stream -> request_headers_added ; <S2SV_ModEnd> if ( name [ 0 ] == ':' ) <S2SV_ModStart> id , stream -> id , name ) ; error = HTTP_REQUEST_URI_TOO_LARGE <S2SV_ModEnd> ; } } else if ( ( nlen + <S2SV_ModStart> id , stream -> id , name ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } <S2SV_ModEnd> if ( stream -> request_headers_added > stream -> session <S2SV_ModStart> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) { if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) { return APR_ECONNRESET ; } <S2SV_ModEnd> ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream <S2SV_ModStart> session -> id , stream -> id ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else if ( error ) { return h2_stream_set_error ( stream , error <S2SV_ModEnd> ) ; } else { if ( ! stream
<S2SV_ModStart> apr_table_setn ( r -> notes , "ssl-renegotiate-forbidden" , "verify-client" ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify
<S2SV_ModStart> r -> per_dir_config , & lua_module ) ; const lua_authz_provider_func * prov_func = parsed_require_line ; const lua_authz_provider_spec * prov_spec = prov_func -> spec <S2SV_ModEnd> ; int result ; int nargs = 0 ; <S2SV_ModStart> ap_lua_run_lua_request ( L , r ) ; if ( prov_func <S2SV_ModEnd> -> args ) { int i ; if ( <S2SV_ModStart> i ; if ( ! lua_checkstack ( L , prov_func <S2SV_ModEnd> -> args -> nelts ) ) { ap_log_rerror ( <S2SV_ModStart> } for ( i = 0 ; i < prov_func <S2SV_ModEnd> -> args -> nelts ; i ++ ) { <S2SV_ModStart> ) { const char * arg = APR_ARRAY_IDX ( prov_func <S2SV_ModEnd> -> args , i , const char * ) <S2SV_ModStart> ( L , arg ) ; } nargs = prov_func <S2SV_ModEnd> -> args -> nelts ; } if ( lua_pcall
<S2SV_ModStart> { const char * provider_name ; lua_authz_provider_spec * spec ; lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) <S2SV_ModStart> ) ; ap_assert ( spec != NULL ) ; func -> spec = spec ; <S2SV_ModStart> * require_line ) { const char * arg ; func <S2SV_ModEnd> -> args = apr_array_make ( cmd -> pool , <S2SV_ModStart> ) ) && * arg ) { APR_ARRAY_PUSH ( func <S2SV_ModEnd> -> args , const char * ) = arg <S2SV_ModStart> ) = arg ; } } * parsed_require_line = func <S2SV_ModEnd> ; return NULL ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { apr_socket_t * sock ; apr_status_t rv ; int do_read = 1 ; int <S2SV_ModStart> ; sock = ap_get_conn_socket ( r -> connection ) ; while ( do_read ) { do_read = 0 <S2SV_ModStart> ( sock , frame , & plen ) ; do_read = 1 ; } <S2SV_ModEnd> } } } return 0 ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , f -> r , APLOGNO ( 02555 ) "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>" "using<S2SV_blank>read-until-close" <S2SV_ModEnd> , tenc ) ; tenc = NULL ; } <S2SV_ModStart> , APLOGNO ( 01587 ) "Invalid<S2SV_blank>Content-Length" ) ; return APR_EINVAL <S2SV_ModEnd> ; } if ( ctx -> limit && ctx <S2SV_ModStart> = ap_pass_brigade ( f -> c -> output_filters , bb ) ; apr_brigade_cleanup ( <S2SV_ModStart> BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv = ap_get_brigade ( f -> next <S2SV_ModStart> if ( ctx -> state == BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } break ; } case BODY_NONE : <S2SV_ModStart> rv ; } break ; } default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) "Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } } } while ( again ) ;
<S2SV_ModStart> ) ; if ( ctx -> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> == LF ) { ctx -> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ( ! apr_isxdigit ( c ) ) { return APR_EINVAL <S2SV_ModEnd> ; } else { ctx -> state = BODY_CHUNK_PART <S2SV_ModStart> = 0 ; ctx -> chunkbits = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 ; ctx -> chunk_used = 0 <S2SV_ModStart> chunk_used = 0 ; } if ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx -> state = BODY_CHUNK_EXT ; } <S2SV_ModStart> -> state = BODY_CHUNK_EXT ; } else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART ) { int xvalue <S2SV_ModEnd> ; if ( ! ctx -> remaining && c <S2SV_ModStart> c == '0' ) { i ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> - 'a' + 0xa ; } else { return APR_EINVAL <S2SV_ModEnd> ; } ctx -> remaining = ( ctx -> <S2SV_ModStart> ctx -> remaining << 4 ) | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining < 0 ) { return APR_ENOSPC <S2SV_ModStart> remaining < 0 ) { return APR_ENOSPC ; } } else { return APR_EGENERAL ;
<S2SV_ModStart> = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } attr = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> ( job ) ; apply_printer_defaults ( printer , job <S2SV_ModEnd> ) ; if ( con -> username [ 0
<S2SV_ModStart> _cups_strcasecmp ( con -> clientname , "localhost." ) || <S2SV_ModEnd> ! strcmp ( con -> clientname , "127.0.0.1" )
<S2SV_ModStart> caplen = pcap_ph . caplen ; } if ( caplentoobig ) { printf ( "\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n" "Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> "File<S2SV_blank>truncated!<S2SV_blank><S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>jump<S2SV_blank>to<S2SV_blank>next<S2SV_blank>packet.\\n" ) ; } close ( fd ) ; break <S2SV_ModEnd> ; } printf ( "\\t%x\\t" , do_checksum_math ( (
<S2SV_ModStart> append_char ( s , c ) ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer , s -> str , XMLRPC_BUFSIZE )
<S2SV_ModStart> { service_named_unbind_command ( "chanserv" , & cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table ) ;
<S2SV_ModStart> { service_named_bind_command ( "chanserv" , & cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
<S2SV_ModStart> flags ) ; return ; } else if ( anope_flags_compat && <S2SV_ModStart> target ) ; return ; } else if ( anope_flags_compat && <S2SV_ModStart> name ) ; return ; } else if ( anope_flags_compat &&
<S2SV_ModStart> ; if ( ( '%' == in ) && ( alloc > 2 ) &&
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool tailmatch ( const char * cooke_domain , const char * hostname ) { size_t cookie_domain_len = strlen ( cooke_domain ) ; size_t hostname_len = strlen ( hostname ) ; if ( hostname_len < cookie_domain_len ) return FALSE ; if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> unsigned char in ; size_t newlen = alloc ; size_t <S2SV_ModEnd> strindex = 0 ; size_t length ; CURLcode res
<S2SV_ModStart> , int length , int * olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen ; CURLcode res = Curl_urldecode ( handle , string , inputlen , & str , & outputlen , FALSE ) ; if ( res ) return NULL ; if ( olen ) * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * path = data -> state . path ; <S2SV_ModEnd> if ( ! * path ) path = "INBOX" <S2SV_ModStart> ( ! * path ) path = "INBOX" ; return Curl_urldecode ( data , path , 0 , & imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * path = data -> state . path ; return Curl_urldecode ( data , path , 0 , & pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> path = conn -> data -> state . path <S2SV_ModEnd> ; char localhost [ HOSTNAME_MAX + 1 ] ; <S2SV_ModStart> = localhost ; else path = "localhost" ; } result = Curl_urldecode ( conn -> data , path , 0 , & smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state ( conn , SMTP_SERVERGREET ) ; if
<S2SV_ModStart> xfer -> filename , xfer -> size ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> ) ; if ( bee -> ui -> ft_in_start && bu
<S2SV_ModStart> ( cp , cp + 2 , strlen ( cp <S2SV_ModEnd> ) - 1 ) ; for ( ; ;
<S2SV_ModStart> , r -> req . tag , r -> qiov . size ) ; n = r -> qiov . size <S2SV_ModEnd> / 512 ; r -> sector += n ; <S2SV_ModStart> scsi_req_data ( & r -> req , r -> qiov . size <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> r , - EINVAL ) ; return ; } <S2SV_ModEnd> if ( s -> tray_open ) { scsi_read_complete ( <S2SV_ModStart> scsi_read_complete ( r , - ENOMEDIUM ) ; } n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ; if ( r -> req . aiocb <S2SV_ModEnd> == NULL ) { scsi_read_complete ( r , -
<S2SV_ModStart> , qdev , r -> req . dev ) <S2SV_ModEnd> ; uint32_t n ; if ( r -> req <S2SV_ModStart> { return ; } } n = r -> qiov . size <S2SV_ModEnd> / 512 ; r -> sector += n ; <S2SV_ModStart> -> req , GOOD ) ; } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( "Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n" , r -> req . <S2SV_ModStart> ( "Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n" , r -> req . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data ( & r -> req , <S2SV_ModStart> ) ; scsi_req_data ( & r -> req , r -> qiov . size <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; return ; } n = r -> qiov . size <S2SV_ModEnd> / 512 ; if ( n ) { if <S2SV_ModStart> scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_ModEnd> bdrv_acct_start ( s -> bs , & r ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int scsi_disk_emulate_command ( SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; uint8_t * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch ( req -> cmd . buf [
<S2SV_ModStart> ; case SCSI_REQ_STATUS_RETRY_FLUSH : ret = scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if ( ret == 0 ) {
<S2SV_ModStart> DO_UPCAST ( SCSIDiskReq , req , req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> qemu_vfree ( r -> iov . iov_base ) ; }
<S2SV_ModStart> static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> = MIN ( r -> sector_count * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external ( & r -> qiov ,
<S2SV_ModStart> qdev , d ) ; SCSIRequest * req ; <S2SV_ModEnd> req = scsi_req_alloc ( & scsi_disk_reqops , & s <S2SV_ModStart> qdev , tag , lun , hba_private ) ; <S2SV_ModEnd> return req ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> dev ) ; int32_t len ; uint8_t command ; <S2SV_ModEnd> int rc ; command = buf [ 0 ] <S2SV_ModStart> int rc ; command = buf [ 0 ] <S2SV_ModEnd> ; DPRINTF ( "Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x" , req -> lun , <S2SV_ModStart> : case VERIFY_10 : rc = scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if ( rc < 0 ) {
<S2SV_ModStart> ] ; size_t size ; unsigned int blksize ; size_t blocks ; unsigned int range_count ; unsigned int <S2SV_ModEnd> i ; if ( fgets ( block_dev , sizeof <S2SV_ModStart> ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>block<S2SV_blank>map<S2SV_blank>header\\n" ) ; return - 1 ; } if ( blksize != 0 ) { <S2SV_ModStart> - 1 ) / blksize ) + 1 ; } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( "invalid<S2SV_blank>data<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%zu,<S2SV_blank>blksize<S2SV_blank>%u,<S2SV_blank>range_count<S2SV_blank>%u\\n" , size , blksize , range_count ) ; return - 1 ; } <S2SV_ModStart> -> range_count = range_count ; pMap -> ranges = calloc ( range_count , sizeof ( MappedRange ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( "calloc(%u,<S2SV_blank>%zu)<S2SV_blank>failed:<S2SV_blank>%s\\n" , range_count , sizeof ( MappedRange ) , strerror ( errno ) ) ; return - 1 ; } <S2SV_ModEnd> unsigned char * reserve ; reserve = mmap64 ( <S2SV_ModStart> ( "failed<S2SV_blank>to<S2SV_blank>reserve<S2SV_blank>address<S2SV_blank>space:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; free ( pMap -> ranges ) ; return - 1 ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>block<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%s\\n" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , "%zu<S2SV_blank>%zu\\n" , & start , & end ) != 2 ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>range<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map\\n" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( "unexpected<S2SV_blank>range<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map:<S2SV_blank>%zu<S2SV_blank>%zu\\n" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>block<S2SV_blank>%d:<S2SV_blank>%s\\n" , i , strerror ( errno ) ) ; success = false ; break ; } pMap -> ranges [ i ] . addr = addr ; pMap -> ranges [ i ] . length = length ; next += length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( "ranges<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>are<S2SV_blank>invalid:<S2SV_blank>remaining_size<S2SV_blank>=<S2SV_blank>%zu\\n" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } close ( fd ) ; <S2SV_ModEnd> pMap -> addr = reserve ; pMap -> length
<S2SV_ModStart> = malloc ( sizeof ( MappedRange ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( "malloc<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
<S2SV_ModStart> ) { LOGW ( "Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n" , fn ) ; fclose ( mapf ) ;
<S2SV_ModStart> log_warning ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message." ) ; return TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( "Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> ) ; Jid * jid_to = jid_create ( to <S2SV_ModEnd> ) ; char * enc_message = NULL ; xmpp_stanza_t
<S2SV_ModStart> ( prof_output_exact ( "unencrypted" ) ) ; stbbr_send ( "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>" <S2SV_ModEnd> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>" "<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>" "<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>" "</message>" "</forwarded>" "</received>" "</message>" )
<S2SV_ModStart> { if ( string -> space == 0 ) { string -> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) string -> space * 2 ; if ( more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n" , G_STRLOC , new_len ) ; } } string -> space = more_space <S2SV_ModEnd> ; } } string -> glyphs = g_realloc (
<S2SV_ModStart> * re ; const char * text ; int result ; int <S2SV_ModStart> -> last ; opts |= REG_NOTBOL ; } } result = <S2SV_ModEnd> js_regexec ( re -> prog , text , & <S2SV_ModStart> prog , text , & m , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> re , const char * text ) { int result ; int <S2SV_ModStart> -> last ; opts |= REG_NOTBOL ; } } result = <S2SV_ModEnd> js_regexec ( re -> prog , text , & <S2SV_ModStart> prog , text , & m , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> while ( a <= e ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , a , & m ,
<S2SV_ModStart> js_toregexp ( J , 1 ) ; if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , source , & m , <S2SV_ModStart> ; else goto end ; } if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog , source , & m ,
<S2SV_ModStart> J , - 1 ) ; if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog , text , & m ,
<S2SV_ModStart> if ( e == text ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , text , & m , <S2SV_ModStart> while ( a < e ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , a , & m ,
<S2SV_ModStart> * bol , int flags , Resub * out , int depth ) { Resub scratch ; int result ; int i ; Rune c ; if ( depth > MAXREC ) return - 1 ; <S2SV_ModEnd> for ( ; ; ) { switch ( pc <S2SV_ModStart> pc -> opcode ) { case I_END : return 0 <S2SV_ModEnd> ; case I_JUMP : pc = pc -> x <S2SV_ModStart> ; case I_SPLIT : scratch = * out ; result = <S2SV_ModEnd> match ( pc -> x , sp , bol <S2SV_ModStart> , sp , bol , flags , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) { * out = scratch ; return 0 <S2SV_ModEnd> ; } pc = pc -> y ; break <S2SV_ModStart> pc -> y ; break ; case I_PLA : result = <S2SV_ModEnd> match ( pc -> x , sp , bol <S2SV_ModStart> x , sp , bol , flags , out , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> ; pc = pc -> y ; break ; <S2SV_ModStart> ; case I_NLA : scratch = * out ; result = <S2SV_ModEnd> match ( pc -> x , sp , bol <S2SV_ModStart> , sp , bol , flags , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> ; pc = pc -> y ; break ; <S2SV_ModStart> ) ; if ( c == 0 ) return 1 <S2SV_ModEnd> ; pc = pc + 1 ; break ; <S2SV_ModStart> ) ; if ( c == 0 ) return 1 <S2SV_ModEnd> ; if ( isnewline ( c ) ) return <S2SV_ModStart> ; if ( isnewline ( c ) ) return 1 <S2SV_ModEnd> ; pc = pc + 1 ; break ; <S2SV_ModStart> ) ; if ( c == 0 ) return 1 <S2SV_ModEnd> ; if ( flags & REG_ICASE ) c = <S2SV_ModStart> if ( c != pc -> c ) return 1 <S2SV_ModEnd> ; pc = pc + 1 ; break ; <S2SV_ModStart> ) ; if ( c == 0 ) return 1 <S2SV_ModEnd> ; if ( flags & REG_ICASE ) { if <S2SV_ModStart> cc , canon ( c ) ) ) return 1 <S2SV_ModEnd> ; } else { if ( ! incclass ( <S2SV_ModStart> ( pc -> cc , c ) ) return 1 <S2SV_ModEnd> ; } pc = pc + 1 ; break <S2SV_ModStart> ) ; if ( c == 0 ) return 1 <S2SV_ModEnd> ; if ( flags & REG_ICASE ) { if <S2SV_ModStart> cc , canon ( c ) ) ) return 1 <S2SV_ModEnd> ; } else { if ( incclass ( pc <S2SV_ModStart> ( pc -> cc , c ) ) return 1 <S2SV_ModEnd> ; } pc = pc + 1 ; break <S2SV_ModStart> n ] . sp , i ) ) return 1 <S2SV_ModEnd> ; } else { if ( strncmp ( sp <S2SV_ModStart> n ] . sp , i ) ) return 1 <S2SV_ModEnd> ; } if ( i > 0 ) sp <S2SV_ModStart> pc + 1 ; break ; } } return 1 <S2SV_ModEnd> ; case I_EOL : if ( * sp == <S2SV_ModStart> pc + 1 ; break ; } } return 1 <S2SV_ModEnd> ; case I_WORD : i = sp > bol <S2SV_ModStart> ] ) ; if ( ! i ) return 1 <S2SV_ModEnd> ; pc = pc + 1 ; break ; <S2SV_ModStart> 0 ] ) ; if ( i ) return 1 <S2SV_ModEnd> ; pc = pc + 1 ; break ; <S2SV_ModStart> pc + 1 ; break ; default : return 1 <S2SV_ModEnd> ; } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> [ i ] . ep = NULL ; return <S2SV_ModEnd> match ( prog -> start , sp , sp <S2SV_ModStart> sp , prog -> flags | eflags , sub , 0
<S2SV_ModStart> emit ( J , F , OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> ( js_State * J ) { char buf [ 100 <S2SV_ModEnd> ] ; js_Object * self = js_toobject ( J <S2SV_ModStart> static const char digits [ ] = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_ModEnd> double number = self -> u . number ;
<S2SV_ModStart> w , double n ) { char buf [ 50 <S2SV_ModEnd> ] , * e ; sprintf ( buf ,
<S2SV_ModStart> exit_client ( client_p , client_p , client_p , "Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , "Malformed<S2SV_blank>AUTHENTICATE"
<S2SV_ModStart> cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
<S2SV_ModStart> ] != \'"\' ) ) end ++ ; } if ( pattern [ end ] == 0 ) break ;
<S2SV_ModStart> reordered [ len + 1 ] = Mymr_C_VIRAMA ; if ( len > 0 )
<S2SV_ModStart> -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> xmlParseStartTag ( ctxt ) ; # endif if ( ctxt -> instate == XML_PARSER_EOF ) return ; if (
<S2SV_ModStart> ctxt -> userData , target , NULL ) ; if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; } if ( ctxt -> instate != XML_PARSER_EOF )
<S2SV_ModStart> unsigned char quitOption = 0 ; Browser_Window * window ; char * window_size_string = NULL <S2SV_ModStart> [ ] = { ECORE_GETOPT_VALUE_STR ( evas_engine_name ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> ewk_context_favicon_database_directory_set ( context , NULL ) ; if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if (
<S2SV_ModStart> url ) ; evas_object_resize ( app_data -> window , window_width , window_height <S2SV_ModEnd> ) ; evas_object_show ( app_data -> window ) ;
<S2SV_ModStart> output != 0 && output_size > count ) { png_size_t copy = output_size - count ; if ( ( png_size_t ) avail < copy ) copy = ( png_size_t ) <S2SV_ModEnd> avail ; png_memcpy ( output + count , png_ptr
<S2SV_ModStart> * db = pParse -> db ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse -> pNewTable , sqlite3DbStrNDup ( db ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void addModuleArgument ( Parse * pParse <S2SV_ModEnd> , Table * pTable , char * zArg ) <S2SV_ModStart> Table * pTable , char * zArg ) { sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof ( char * ) * ( <S2SV_ModStart> -> nModuleArg ) ; char * * azModuleArg ; sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s" , pTable -> zName ) ; }
<S2SV_ModStart> p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = ( v -> nOpAlloc >= 512 ? <S2SV_ModStart> nNew = ( v -> nOpAlloc >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> nOpAlloc + nOp ) ; # else <S2SV_ModStart> v -> nOpAlloc + nOp ) ; # else sqlite3_int64 nNew = ( v -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) 1024 / sizeof ( Op <S2SV_ModEnd> ) ) ; UNUSED_PARAMETER ( nOp ) ; #
<S2SV_ModStart> == 0 ) { VTable * * aVTrans ; sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof ( sqlite3_vtab * ) * ( <S2SV_ModStart> nBytes = sizeof ( sqlite3_vtab * ) * ( ( sqlite3_int64 )
<S2SV_ModStart> ( ) ; pStart = sqlite3Malloc ( sz * ( sqlite3_int64 )
<S2SV_ModStart> nAlloc < nByte ) { u8 * aNew ; sqlite3_int64 nNew = MAX ( 128 , 2 * ( sqlite3_int64 ) p -> nAlloc <S2SV_ModEnd> ) ; while ( nByte > nNew ) nNew
<S2SV_ModStart> char * zMatchinfo ) { MatchinfoBuffer * pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = sizeof ( u32 ) * ( 2 <S2SV_ModStart> = sizeof ( u32 ) * ( 2 * ( sqlite3_int64 ) <S2SV_ModStart> + 1 ) + sizeof ( MatchinfoBuffer ) ; sqlite3_int64 nStr = strlen ( zMatchinfo ) ; pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte + nStr + 1 ) ; if
<S2SV_ModStart> [ 0 ] ) ; pCsr -> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte + 1 ) ; if ( pCsr
<S2SV_ModStart> z , & n ) ) ) ) { sqlite3_int64 <S2SV_ModEnd> nNew = sizeof ( char * ) * ( <S2SV_ModStart> * aNew = ( const char * * ) sqlite3_realloc64 <S2SV_ModEnd> ( ( void * ) aArg , nNew )
<S2SV_ModStart> ) && ( normalize ) ) { while ( ( len > 0 ) && ( buf [ len - 1 ] == 0x20 ) <S2SV_ModEnd> ) len -- ; } buf [ len ]
<S2SV_ModStart> 32 , short_months [ ( ptime -> month - 1U <S2SV_ModEnd> ) % 12 ] , ptime -> year , <S2SV_ModStart> 32 , short_months [ ( ptime -> month - 1U <S2SV_ModEnd> ) % 12 ] , ptime -> year , <S2SV_ModStart> 32 , short_months [ ( ptime -> month - 1U <S2SV_ModEnd> ) % 12 ] , ptime -> year ,
<S2SV_ModStart> # ifdef __STDC__ return ( ( png_charp ) PNG_STRING_NEWLINE "libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015" PNG_STRING_NEWLINE "Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson" <S2SV_ModEnd> PNG_STRING_NEWLINE "Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger" PNG_STRING_NEWLINE "Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc." PNG_STRING_NEWLINE ) ; # else <S2SV_ModStart> ) ; # else return ( ( png_charp ) "libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc." <S2SV_ModEnd> ) ; # endif # endif } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( PNG_STRUCT_INFO ) ; * ptr_ptr = info_ptr ; if ( info_ptr == NULL ) return ;
<S2SV_ModStart> uInt size ) { png_voidp ptr ; png_structp p ; png_uint_32 save_flags ; png_uint_32 num_bytes ; if ( png_ptr == NULL ) return ( NULL ) ; p = ( png_structp ) png_ptr ; save_flags = p -> flags <S2SV_ModEnd> ; if ( items > PNG_UINT_32_MAX / size )
<S2SV_ModStart> 1 , novar , 0 ) ; if ( ctxt -> error ) return ; if (
<S2SV_ModStart> i - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , i +
<S2SV_ModStart> xmlXPathParserContextPtr ctxt , int nargs ) { xmlNodePtr cur = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart> } else if ( nargs == 1 ) { <S2SV_ModEnd> xmlNodeSetPtr nodelist ; int i , ret ; if <S2SV_ModStart> = nodelist -> nodeTab [ i ] ; } <S2SV_ModEnd> } else { xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) <S2SV_ModStart> doc = ctxt -> context -> doc ; } if ( obj ) xmlXPathFreeObject ( obj ) ;
<S2SV_ModStart> -> bitcnt - bit_start ) ; if ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
<S2SV_ModStart> buf [ len ] = 0 ; if ( ( len > 12 ) && ! memcmp ( buf + 5 , "include" , 7 ) ) { do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN ) } else if ( ( len > 9 ) && ! memcmp ( buf + 5 , "exec" , 4 ) ) { do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , "%s:<S2SV_blank>unknown<S2SV_blank>SSI<S2SV_blank>" "command:<S2SV_blank>\\"%s\\"" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf <S2SV_ModEnd> , "<!--#" , 5 ) ) { in_ssi_tag =
<S2SV_ModStart> ( res_val , 1 ) ; if ( ! valid_hex ( nonce1 ) ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free ( sessionid ) ; goto out <S2SV_ModStart> ( res_val , 2 ) ) ; if ( n2size < 2 || n2size > 16 ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free ( sessionid ) ; free (
<S2SV_ModStart> val , 8 ) ) ; if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free ( job_id ) ; free ( coinbase1 ) ; <S2SV_ModEnd> free ( coinbase2 ) ; goto out ; }
<S2SV_ModStart> ! port ) port = pool -> stratum_port ; snprintf ( address , 254 <S2SV_ModEnd> , "%s:%s" , url , port ) ; if
<S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ;
<S2SV_ModStart> ( oid_list_todo_num == 0 ) { DEBUG ( "snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree" ) ; snmp_free_pdu ( req <S2SV_ModStart> snmp_free_pdu ( res ) ; res = NULL ; <S2SV_ModEnd> sfree ( errstr ) ; csnmp_host_close_session ( host ) <S2SV_ModStart> res ) ; res = NULL ; if ( <S2SV_ModEnd> status == 0 ) csnmp_dispatch_table ( host , data
<S2SV_ModStart> length == 5 ) ; if ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( result != buf ) ; ASSERT <S2SV_ModStart> != buf ) free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , "DEADBEEF" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , "%2.0f" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & "DEADBEEF" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
<S2SV_ModStart> . type = siBuffer ; hash_param . data = instance -> private_key ; hash_param . len = instance -> private_key_len <S2SV_ModEnd> ; hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance ->
<S2SV_ModStart> ptr ) { if ( '%' == * ptr && ptr [ 1 ]
<S2SV_ModStart> 0 ; if ( width >= 0 ) { if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ; <S2SV_ModStart> ; } if ( prec >= 0 ) { size_t maxprec = sizeof ( work ) - 2 ; double val = p -> data . dnum ; while ( val >= 10.0 ) { val /= 10 ; maxprec -- ; } if ( prec > ( long ) maxprec ) prec = maxprec - 1 ; <S2SV_ModStart> formatbuf , p -> data . dnum ) ; # ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ; # endif
<S2SV_ModStart> ( ) ; errors += test_string_formatting ( ) ; errors += test_float_formatting ( ) ;
<S2SV_ModStart> data ) ; if ( data -> multi_easy ) { curl_multi_cleanup ( data -> multi_easy ) ; data -> multi_easy = NULL ; } <S2SV_ModEnd> Curl_llist_destroy ( & data -> state . timeoutlist ,
<S2SV_ModStart> ; scratch = newscratch = malloc ( 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; if ( ! newscratch ) { failf <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!" ) ; return CURLE_OUT_OF_MEMORY ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
<S2SV_ModStart> ptr += cut + 1 ; len -= cut + 1
<S2SV_ModStart> ) ; if ( ( ulen > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || ( plen > ( SIZE_T_MAX / 2
<S2SV_ModStart> ( cmd . s , "Syncapply" ) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> ( cmd . s , "Syncget" ) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> . s , "Syncrestart" ) ) { if ( ! imapd_userisadmin ) goto badcmd ; if ( <S2SV_ModStart> ( cmd . s , "Syncrestore" ) ) { if ( ! imapd_userisadmin ) goto badcmd ;
<S2SV_ModStart> buf [ MAX_MAILBOX_PATH ] ; const char * base <S2SV_ModEnd> = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir <S2SV_ModStart> ( part ) : config_partitiondir ( part ) ; <S2SV_ModEnd> assert ( base != NULL ) ; snprintf (
<S2SV_ModStart> , prefixlen ) ) ) { if ( prefixlen <= <S2SV_ModEnd> len ) { strlcpy ( domainpat + domainlen ,
<S2SV_ModStart> , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
<S2SV_ModStart> { case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :
<S2SV_ModStart> case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :
<S2SV_ModStart> ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> num_chans = config -> num_channels ; int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> , "RF64" , 4 ) , got_ds64 = 0 , format_chunk = 0 <S2SV_ModStart> ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> WaveHeader ; int format_chunk = 0 ; uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> -> channel_reordering = NULL ; } if ( bytecnt >= 2 <S2SV_ModStart> channel_reordering [ i ] = * byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
<S2SV_ModStart> = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 <S2SV_ModStart> if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 <S2SV_ModStart> . ckID , "DSD<S2SV_blank>" , 4 ) ) { if ( ! config -> num_channels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> 1 ) & ~ 1L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> "chan" , 4 ) ) { CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( caf_chunk_header . mChunkSize < sizeof ( <S2SV_ModStart> caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_ModStart> ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> meta_bc == 4 ) { if ( * dp != ( csum & 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( csum >> 8 ) & 0xff <S2SV_ModStart> ( csum >> 8 ) & 0xff ) || dp [ 2 ] <S2SV_ModEnd> != ( ( csum >> 16 ) & 0xff <S2SV_ModStart> ( csum >> 16 ) & 0xff ) || dp [ 3 ] <S2SV_ModEnd> != ( ( csum >> 24 ) & 0xff <S2SV_ModStart> ^= csum >> 16 ; if ( * dp != ( csum & 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( csum >> 8 ) & 0xff
<S2SV_ModStart> , chansSpecified , chanMask = 0 ; uint32_t sampleRate = 0 <S2SV_ModStart> ) ) { if ( ! config -> num_channels || ! config -> sample_rate
<S2SV_ModStart> || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; <S2SV_ModStart> && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) { error_line ( "%s" , WavpackGetErrorMessage (
<S2SV_ModStart> { int do_rf64 = 0 , write_junk = 1 , table_length = 0 <S2SV_ModStart> datahdr , fmthdr ; RiffChunkHeader riffhdr ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ( ds64hdr ) + sizeof ( ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk ) ; strncpy ( fmthdr . <S2SV_ModStart> ; ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> dataSize64 = total_data_bytes ; ds64_chunk . sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> . ckSize = ( uint32_t ) total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , "dmmy" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> || bcount != sizeof ( ds64_chunk ) ) ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk && ( ! DoWriteFile ( outfile ,
<S2SV_ModStart> wpc , WavpackConfig * config ) { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> ; } WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> ) ) { uint32_t mEditCount ; if ( ! desc_chunk || !
<S2SV_ModStart> { static char * message = NULL ; static size_t <S2SV_ModEnd> len = 0 ; char buff [ 13 ]
<S2SV_ModStart> sizeof ( buf ) - 1 && str [ j <S2SV_ModEnd> ] ; i ++ , j ++ ) {
<S2SV_ModStart> ] . shift = ARM_ASR ; } if ( strlen ( token ) > 4 &&
<S2SV_ModStart> * group ; int r ; int res ; clist * list ; <S2SV_ModStart> { res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list ) ; goto free_display_name ; }
<S2SV_ModStart> subseqEntry ; if ( cluster != fs -> clusters + <S2SV_ModEnd> 1 ) get_fat ( & subseqEntry , fs ->
<S2SV_ModStart> fats , fs -> fat_bits ) ; printf ( "%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n" , ( long long ) fs -> fat_size , ( long long ) <S2SV_ModEnd> fs -> fat_size / lss ) ; if (
<S2SV_ModStart> unsigned total_sectors ; unsigned short logical_sector_size , sectors ; off_t <S2SV_ModEnd> fat_length ; unsigned total_fat_entries ; off_t data_size ; fs_read <S2SV_ModStart> ) : le32toh ( b . fat32_length ) ; if ( ! fat_length ) die ( "FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; <S2SV_ModStart> off_t ) total_sectors * logical_sector_size - fs -> data_start ; if ( data_size < fs -> cluster_size ) die ( "Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters" )
<S2SV_ModStart> config -> listener_count - 1 ] . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
<S2SV_ModStart> , & out , NULL , NULL , NULL ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> , & out ) ; return NULL ; } gss_release_buffer ( & min , & out ) ;
<S2SV_ModStart> "%s" , strerror ( errno ) ) ) ; goto bail <S2SV_ModEnd> ; } if ( ret == 0 ) { <S2SV_ModStart> LOG ( LOG_INFO , ( "EOF<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>len" ) ) ; goto bail <S2SV_ModEnd> ; } len_buf_pos += ret ; } if ( <S2SV_ModStart> LOG_ERR , ( "ridiculous<S2SV_blank>length,<S2SV_blank>%ld" , len ) ) ; goto bail <S2SV_ModEnd> ; } if ( ! tmpbuf ) { if <S2SV_ModStart> LOG_CRIT , ( "malloc<S2SV_blank>failure,<S2SV_blank>%ld<S2SV_blank>bytes" , len ) ) ; goto bail <S2SV_ModEnd> ; } } ret = timed_read ( fd , <S2SV_ModStart> "%s" , strerror ( errno ) ) ) ; goto bail <S2SV_ModEnd> ; } if ( ret == 0 ) { <S2SV_ModStart> LOG_ERR , ( "EOF<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>(len=%d)" , len ) ) ; goto bail <S2SV_ModEnd> ; } tmpbuf_pos += ret ; if ( tmpbuf_pos <S2SV_ModStart> ; return 1 ; } return - 2 ; bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ;
<S2SV_ModStart> ) ) * c = '\\0' ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen ( fname ) + strlen ( dirname
<S2SV_ModStart> [ 0 ] == '(' ) { ascii = safe_calloc <S2SV_ModEnd> ( strlen ( str ) + 1 ) ; <S2SV_ModStart> 4 ; } else return NULL ; ascii = safe_calloc <S2SV_ModEnd> ( str_len ) ; for ( ; idx <
<S2SV_ModStart> char * get_header ( FILE * fp ) { char * header = safe_calloc ( 1024 ) ; long <S2SV_ModEnd> start = ftell ( fp ) ; fseek (
<S2SV_ModStart> = 0 ; n_blks = 1 ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks ) ; stream = 0 ;
<S2SV_ModStart> ( "ize<S2SV_blank>" ) ) ; xref -> entries = safe_calloc ( <S2SV_ModEnd> xref -> n_entries * sizeof ( struct _xref_entry )
<S2SV_ModStart> "Trapped" , "" } , } ; daddy = safe_calloc <S2SV_ModEnd> ( sizeof ( creator_template ) ) ; memcpy (
<S2SV_ModStart> end - ftell ( fp ) ; buf = safe_calloc <S2SV_ModEnd> ( sz + 1 ) ; SAFE_E ( fread
<S2SV_ModStart> 0 , SEEK_SET ) ; pdf -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t ) * pdf -> n_xrefs )
<S2SV_ModStart> * n ; pdf_t * pdf ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t ) ) ; if ( name <S2SV_ModStart> else n = name ; pdf -> name = safe_calloc <S2SV_ModEnd> ( strlen ( n ) + 1 ) ; <S2SV_ModStart> ) ; } else { pdf -> name = safe_calloc <S2SV_ModEnd> ( strlen ( "Unknown" ) + 1 ) ;
<S2SV_ModStart> NULL ; if ( name ) { dst_name = safe_calloc <S2SV_ModEnd> ( strlen ( name ) * 2 + 16
<S2SV_ModStart> -> use_ssl ? net_connect_ip_ssl ( ip , port , server -> connrec -> address ,
<S2SV_ModStart> ) { sf_count_t total = 0 ; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
<S2SV_ModStart> . type_offset = rsrc . map_offset + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>map<S2SV_blank>offset.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> < rsrc . type_count ; k ++ ) { if ( rsrc . type_offset + k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 <S2SV_ModEnd> ) ; if ( marker == STR_MARKER ) {
<S2SV_ModStart> -> channel_map != NULL ) { size_t chanmap_size = SF_MIN ( psf -> sf . channels , layout_tag & 0xffff ) <S2SV_ModEnd> * sizeof ( psf -> channel_map [ 0 ]
<S2SV_ModStart> if ( lex -> tk == LEX_ID ) { espruino_snprintf ( str , len , "ID:%s" , jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } else if ( lex -> tk <S2SV_ModStart> if ( lex -> tk == LEX_STR ) { espruino_snprintf ( str , len , "String:\'%s\'" , jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } else jslTokenAsString ( lex -> tk
<S2SV_ModStart> ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; # endif # endif } else { strcpy ( result , "undefined" <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> len , int radix , int fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> 0.0000001 ; if ( isnan ( val ) ) strcpy ( str , "NaN" <S2SV_ModEnd> ) ; else if ( ! isfinite ( val <S2SV_ModStart> ) ) { if ( val < 0 ) strcpy ( str , "-Infinity" ) ; else strcpy ( str , "Infinity" <S2SV_ModEnd> ) ; } else { if ( val <
<S2SV_ModStart> . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else { jsExceptionHere ( JSET_ERROR , "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; } <S2SV_ModEnd> } JsVar * colorv = jsvObjectGetChild ( options ,
<S2SV_ModStart> gfx -> data . bpp ) : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> STACK_BASE - ( size_t ) & ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ; # else return 1000000 ; #
<S2SV_ModStart> , char * str , size_t len ) { assert ( len > 28 ) ; <S2SV_ModStart> } switch ( token ) { case LEX_EOF : strcpy ( str , "EOF" ) ; return ; case LEX_ID : strcpy ( str , "ID" ) ; return ; case LEX_INT : strcpy ( str , "INT" ) ; return ; case LEX_FLOAT : strcpy ( str , "FLOAT" ) ; return ; case LEX_STR : strcpy ( str , "STRING" ) ; return ; case LEX_UNFINISHED_STR : strcpy ( str , "UNFINISHED<S2SV_blank>STRING" ) ; return ; case LEX_TEMPLATE_LITERAL : strcpy ( str , "TEMPLATE<S2SV_blank>LITERAL" ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" ) ; return ; case LEX_REGEX : strcpy ( str , "REGEX" ) ; return ; case LEX_UNFINISHED_REGEX : strcpy ( str , "UNFINISHED<S2SV_blank>REGEX" ) ; return ; case LEX_UNFINISHED_COMMENT : strcpy ( str , "UNFINISHED<S2SV_blank>COMMENT" <S2SV_ModEnd> ) ; return ; } if ( token >= <S2SV_ModStart> ; } assert ( n == 0 ) ; strcpy ( str , & tokenNames [ p ] ) ; return ; } espruino_snprintf ( str , len <S2SV_ModEnd> , "?[%d]" , token ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( first ) { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if ( <S2SV_ModStart> else { if ( first ) { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if (
<S2SV_ModStart> -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec ->
<S2SV_ModStart> ) , u1_nal_ref_idc , ps_dec ) ; if ( <S2SV_ModEnd> i_status != OK ) { return i_status ; }
<S2SV_ModStart> ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } <S2SV_ModEnd> } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice =
<S2SV_ModStart> ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; ps_dec -> u4_first_slice_in_pic = 0 ;
<S2SV_ModStart> ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec ->
<S2SV_ModStart> ps_dec -> ps_cur_slice ; WORD32 ret ; ps_dec -> <S2SV_ModEnd> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0
<S2SV_ModStart> 0 ; buflen = MIN ( buflen , buf_size - 8
<S2SV_ModStart> > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
<S2SV_ModStart> = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> , u1_frm ) ; if ( ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT ( "SPS:<S2SV_blank>mb_adaptive_frame_field_flag" , ps_seq -> u1_mb_aff_flag )
<S2SV_ModStart> 1 ; ps_dec -> i4_content_type = - 1 ; <S2SV_ModEnd> ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec <S2SV_ModStart> ) { ret = ih264d_deblock_display ( ps_dec ) ; <S2SV_ModEnd> } if ( ps_dec -> i4_header_decoded == 3 ) <S2SV_ModStart> ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } }
<S2SV_ModStart> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; <S2SV_ModStart> { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; <S2SV_ModEnd> { WORD32 i , j , poc = 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec <S2SV_ModEnd> ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice <S2SV_ModStart> * ps_cur_slice = ps_dec -> ps_cur_slice ; WORD32 ret <S2SV_ModEnd> ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status <S2SV_ModStart> if ( ret != OK ) return ret ; <S2SV_ModEnd> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return
<S2SV_ModStart> ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs <S2SV_ModEnd> ++ ; } u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - <S2SV_ModStart> , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> >> u1_mbaff ) ) ; } u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 <S2SV_ModStart> , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs <S2SV_ModEnd> ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next <S2SV_ModStart> , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> , ! uc_more_data_flag ) ; } u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs <S2SV_ModStart> , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs <S2SV_ModEnd> ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next <S2SV_ModStart> , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> void * pv_api_ip , void * pv_api_op ) { ih264d_create_ip_t * ps_create_ip ; ih264d_create_op_t * ps_create_op ; WORD32 ret ; ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip <S2SV_ModEnd> ; ps_create_op = ( ih264d_create_op_t * ) pv_api_op ; <S2SV_ModStart> ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; dec_hdl = NULL ; <S2SV_ModStart> dec_hdl , pv_api_ip , pv_api_op ) ; if ( IV_FAIL == ret ) { if ( dec_hdl ) { if ( dec_hdl -> pv_codec_handle ) { ih264d_free_static_bufs ( dec_hdl ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ; } } <S2SV_ModEnd> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op
<S2SV_ModStart> -> ps_cur_slice ; ps_pic_params = ps_dec -> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps = 0 ; ps_dpb_mgr = ps_dec -> ps_dpb_mgr
<S2SV_ModStart> = ps_dec -> ps_bitstrm ; dpb_commands_t * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ;
<S2SV_ModStart> prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;
<S2SV_ModStart> == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME <S2SV_ModStart> ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T
<S2SV_ModStart> ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { ALOGE ( "b/25818142" ) ; android_errorWriteLog ( 0x534e4554 , "25818142" ) ; ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; }
<S2SV_ModStart> if ( j == - 1 ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if ( ps_dec -> u4_pic_buf_got == 0
<S2SV_ModStart> = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ;
<S2SV_ModStart> ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }
<S2SV_ModStart> ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> "Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } <S2SV_ModEnd> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec
<S2SV_ModStart> -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart> [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded <S2SV_ModEnd> = 0 ; ps_dec -> u2_cur_slice_num_dec_thread = 0 ;
<S2SV_ModStart> ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data
<S2SV_ModStart> ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data
<S2SV_ModStart> ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data
<S2SV_ModStart> MAX_DISP_BUFS_NEW ) * sizeof ( UWORD32 ) ) ; memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ;
<S2SV_ModStart> j = i ; { ps_dec -> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc
<S2SV_ModStart> ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
<S2SV_ModStart> ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; }
<S2SV_ModStart> u1_is_valid == TRUE ) j = i ; { ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; <S2SV_ModStart> -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ;
<S2SV_ModStart> = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
<S2SV_ModStart> ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size + EXTRA_BS_OFFSET
<S2SV_ModStart> , 8 ) ; while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> , 8 ) ; while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
<S2SV_ModStart> * ps_cur_slice ; pocstruct_t * ps_prev_poc , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
<S2SV_ModStart> ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; <S2SV_ModEnd> { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec
<S2SV_ModStart> 1 ; u4_sym = 0 ; while ( bin && ( numones <= 16 ) <S2SV_ModStart> bin << numones ++ ; } numones -= 1 <S2SV_ModEnd> ; if ( numones ) { UWORD32 u4_suffix ;
<S2SV_ModStart> ( value ) cu_qp_delta_abs = - cu_qp_delta_abs ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> ai1_sps_max_dec_pic_buffering [ i ] = value + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <S2SV_ModStart> ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
<S2SV_ModStart> void * pv_api_ip , void * pv_api_op ) { ihevcd_cxa_create_ip_t * ps_create_ip ; <S2SV_ModStart> * ps_create_op ; WORD32 ret ; codec_t * ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip <S2SV_ModStart> ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; ps_codec_obj = NULL ; <S2SV_ModStart> ps_codec_obj , pv_api_ip , pv_api_op ) ; if ( IV_FAIL == ret ) { if ( NULL != ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle ) { ihevcd_free_static_bufs ( ps_codec_obj ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } } <S2SV_ModEnd> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op
<S2SV_ModStart> "sps_extension_flag" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> -> i1_sps_max_sub_layers - 1 ] ; max_dpb_size ++ ; ps_codec -> i4_max_dpb_size = max_dpb_size ;
<S2SV_ModStart> : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ; } <S2SV_ModEnd> break ; default : for ( i = 0 <S2SV_ModStart> : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ; } <S2SV_ModEnd> break ; default : for ( i = 0
<S2SV_ModStart> ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; } return ( ( IHEVCD_ERROR_T ) <S2SV_ModEnd> IHEVCD_SUCCESS ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols <S2SV_ModEnd> ) || ( ps_pps -> i1_num_tile_rows < 1 ) <S2SV_ModStart> < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows <S2SV_ModEnd> ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( "uniform_spacing_flag" ,
<S2SV_ModStart> , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; } <S2SV_ModStart> , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; }
<S2SV_ModStart> if ( ps_dec -> u2_is_mpeg2 == 0 ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
<S2SV_ModStart> ; ps_dec -> u2_frame_rate_extension_d = 0 ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) { stream_t * <S2SV_ModStart> ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> { ps_dec -> u2_cbp = 0 ; } } return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) { stream_t * <S2SV_ModStart> ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> { ps_dec -> u2_cbp = 0 ; } } return 0 ;
<S2SV_ModStart> |= 1 << ( u4_pos >> 0x3 ) ; <S2SV_ModEnd> if ( u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR <S2SV_ModStart> u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR ; } } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) <S2SV_ModStart> |= 1 << ( u4_pos >> 0x3 ) ; <S2SV_ModEnd> if ( u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR <S2SV_ModStart> ( u4_numCoeffs > 64 ) { return IMPEG2D_MB_TEX_DECODE_ERR ; }
<S2SV_ModStart> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream
<S2SV_ModStart> ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
<S2SV_ModStart> ( temp <= 0xAF ) ) ; if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , "26070014" ) ; } if (
<S2SV_ModStart> break ; i4_row -= 1 ; if ( i4_prev_row < <S2SV_ModEnd> i4_row ) { if ( i4_start_row != - 1 <S2SV_ModStart> i4_prev_row = i4_row ; i4_start_row = i4_row ; } else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , "26070014" ) ; }
<S2SV_ModStart> = u2_width ; ps_dec -> u2_vertical_size = u2_height ; <S2SV_ModEnd> } else { if ( 0 == ps_dec -> <S2SV_ModStart> u2_reinit_max_width = u2_width ; return e_error ; } else if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS ; } else <S2SV_ModStart> -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS
<S2SV_ModStart> } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
<S2SV_ModStart> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
<S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> USER_DATA_START_CODE ) && ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> USER_DATA_START_CODE ) && ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <S2SV_ModEnd> ) { impeg2d_bit_stream_flush ( ps_stream , 8 ) ;
<S2SV_ModStart> impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <S2SV_ModEnd> ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> u4_start_code_val ) && ( ps_dec -> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream . u4_max_offset ) ) { if
<S2SV_ModStart> START_CODE_PREFIX ) && ( ps_dec -> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream . u4_max_offset ) ) { impeg2d_bit_stream_get
<S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> ] = silk_max_int ( NLSF_Q15 [ i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> ) ; NLSF_Q15 [ L - 1 ] =
<S2SV_ModStart> -> common . error . setjmp = 0 ; ctx -> si . w = 0 ; ctx -> si . h = 0 ;
<S2SV_ModStart> 0x3fff ; if ( ! ( si -> h && si -> w ) ) res = VPX_CODEC_CORRUPT_FRAME ; } else { res = VPX_CODEC_UNSUP_BITSTREAM ; } <S2SV_ModEnd> } return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { int intra_only_flag = 0 ; uint8_t clear_buffer [ 10 <S2SV_ModEnd> ] ; if ( data + data_sz <= data <S2SV_ModStart> , data_sz ) ; data = clear_buffer ; } if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModStart> profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( vpx_rb_read_bit ( & rb ) ) { if ( profile > 2 && data_sz < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModEnd> vpx_rb_read_literal ( & rb , 3 ) ; return <S2SV_ModStart> ) ; return VPX_CODEC_OK ; } if ( data_sz < 10 <S2SV_ModEnd> ) return VPX_CODEC_UNSUP_BITSTREAM ; si -> is_kf = !
<S2SV_ModStart> default : ycs = 0 ; break ; } w = d_w ; h = d_h <S2SV_ModEnd> ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? <S2SV_ModStart> = img_data ; if ( ! img_data ) { uint64_t alloc_size ; align = ( 1 << xcs ) - 1 ; w = ( d_w + align ) & ~ align ; align = ( 1 << ycs ) - 1 ; h = ( d_h + align ) & ~ align ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_ModEnd> alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void usage ( <S2SV_ModEnd> ) { printf ( "Usage:\\n" ) ; printf ( <S2SV_ModStart> printf ( "Usage:\\n" ) ; printf ( "%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>" , exec_name <S2SV_ModEnd> ) ; printf ( "<output_yuv><S2SV_blank>[<frames>]\\n" ) ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img <S2SV_ModStart> , int frame_index , VpxVideoWriter * writer ) { int got_pkts = 0 ; <S2SV_ModStart> , & iter ) ) != NULL ) { got_pkts = 1 ; <S2SV_ModStart> ) ; fflush ( stdout ) ; } } return got_pkts ;
<S2SV_ModStart> { unsigned int i ; vpx_active_map_t map = { 0 , 0 ,
<S2SV_ModStart> codec ) { unsigned int i ; vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi . rows = ( cfg -> g_h
<S2SV_ModStart> vpx_codec_ctx_t * codec ) { vpx_active_map_t map = { 0 , 0 ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img <S2SV_ModStart> , int flags , VpxVideoWriter * writer ) { int got_pkts = 0 ; <S2SV_ModStart> , & iter ) ) != NULL ) { got_pkts = 1 ; <S2SV_ModStart> ) ; fflush ( stdout ) ; } } return got_pkts ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * <S2SV_ModStart> unsigned int deadline , VpxVideoWriter * writer ) { int got_pkts = 0 ; <S2SV_ModStart> , & iter ) ) != NULL ) { got_pkts = 1 ; <S2SV_ModStart> ) ; fflush ( stdout ) ; } } return got_pkts ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * <S2SV_ModStart> unsigned int deadline , vpx_fixed_buf_t * stats ) { int got_pkts = 0 ; <S2SV_ModStart> , & iter ) ) != NULL ) { got_pkts = 1 ; <S2SV_ModStart> ; stats -> sz += pkt_size ; } } return got_pkts ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img <S2SV_ModStart> , int frame_index , VpxVideoWriter * writer ) { int got_pkts = 0 ; <S2SV_ModStart> , & iter ) ) != NULL ) { got_pkts = 1 ; <S2SV_ModStart> ) ; fflush ( stdout ) ; } } return got_pkts ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ( now < cfg -> rc_buf_initial_sz ) return ; if ( ! cfg -> rc_target_bitrate ) return ;
<S2SV_ModStart> plane = 0 ; int shortread = 0 ; const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> { uint8_t * ptr ; const int w = vpx_img_plane_width ( yuv_frame , plane ) ; const int h = vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> ) ; int r ; switch ( plane ) <S2SV_ModStart> ; ++ r ) { size_t needed = w * bytespp
<S2SV_ModStart> int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) <S2SV_ModStart> buf , 1 , w , file ) != ( size_t )
<S2SV_ModStart> int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> goto allocation_fail ; oci -> post_proc_buffer_int_used = 0 ; memset <S2SV_ModEnd> ( & oci -> postproc_state , 0 , sizeof <S2SV_ModStart> , sizeof ( oci -> postproc_state ) ) ; memset <S2SV_ModEnd> ( oci -> post_proc_buffer . buffer_alloc , 128 ,
<S2SV_ModStart> = ONE_PARTITION ; oci -> clamp_type = RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci -> ref_frame_sign_bias , 0 , sizeof (
<S2SV_ModStart> , d27u8 , d28u8 , d29u8 , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <S2SV_ModEnd> d28u32 = vld1_lane_u32 ( ( const uint32_t * ) <S2SV_ModStart> d4u8 , d5u8 ) ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> vld1q_u8 ( src_ptr ) ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> ; src_ptr += src_pixels_per_line ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> <S2SV_null> void vp8_init_mbmode_probs ( VP8_COMMON * x ) { memcpy <S2SV_ModEnd> ( x -> fc . ymode_prob , vp8_ymode_prob , <S2SV_ModStart> , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; memcpy <S2SV_ModEnd> ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , <S2SV_ModStart> , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; memcpy <S2SV_ModEnd> ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob ,
<S2SV_ModStart> ; i < h ; i ++ ) { memset <S2SV_ModEnd> ( dest_ptr1 , src_ptr1 [ 0 ] , el <S2SV_ModStart> , src_ptr1 [ 0 ] , el ) ; memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 [ 0 ] , er <S2SV_ModStart> ; i < et ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , src_ptr1 , linesize ) ; dest_ptr1 <S2SV_ModStart> ; i < eb ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 , linesize ) ; dest_ptr2
<S2SV_ModStart> dst , stride , dst , stride ) ; memset <S2SV_ModEnd> ( q , 0 , 2 * sizeof (
<S2SV_ModStart> ( blksize == 16 ) { actd = ( vpx_variance16x16 <S2SV_ModEnd> ( yd , yd_stride , VP8_ZEROS , 0 , <S2SV_ModStart> + 128 ) >> 8 ; act = ( vpx_variance16x16 <S2SV_ModEnd> ( y , y_stride , VP8_ZEROS , 0 , <S2SV_ModStart> + 128 ) >> 8 ; # ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse <S2SV_ModEnd> ) ; sad = ( sse + 128 ) <S2SV_ModStart> = ( sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 ( y , y_stride , yd , yd_stride ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) <S2SV_ModEnd> + 32 ) >> 6 ; vsad = ( <S2SV_ModStart> + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride <S2SV_ModEnd> ) + 32 ) >> 6 ; # endif <S2SV_ModStart> ; # endif } else { actd = ( vpx_variance8x8 <S2SV_ModEnd> ( yd , yd_stride , VP8_ZEROS , 0 , <S2SV_ModStart> + 32 ) >> 6 ; act = ( vpx_variance8x8 <S2SV_ModEnd> ( y , y_stride , VP8_ZEROS , 0 , <S2SV_ModStart> + 32 ) >> 6 ; # ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse <S2SV_ModEnd> ) ; sad = ( sse + 32 ) <S2SV_ModStart> = ( sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 ( y , y_stride , yd , yd_stride ) + 32 ) >> 6 ; usad = ( vpx_sad4x4 ( u , uv_stride , ud , uvd_stride ) <S2SV_ModEnd> + 8 ) >> 4 ; vsad = ( <S2SV_ModStart> + 8 ) >> 4 ; vsad = ( vpx_sad4x4 ( v , uv_stride , vd , uvd_stride <S2SV_ModEnd> ) + 8 ) >> 4 ; # endif <S2SV_ModStart> , up += uv_stride , udp += uvd_stride ) memcpy <S2SV_ModEnd> ( udp , up , uvblksize ) ; for <S2SV_ModStart> , vp += uv_stride , vdp += uvd_stride ) memcpy <S2SV_ModEnd> ( vdp , vp , uvblksize ) ; }
<S2SV_ModStart> = ( int ) ( .5 + 256 * gaussian <S2SV_ModEnd> ( sigma , 0 , i ) ) ;
<S2SV_ModStart> , int q , int low_var_thresh , int flag , int uvfilter ) { int mbr ; <S2SV_ModEnd> double level = 6.0e-05 * q * q * <S2SV_ModStart> ( level + .5 ) ; int mb_rows = cm -> mb_rows ; int mb_cols = cm -> mb_cols <S2SV_ModEnd> ; unsigned char * limits = cm -> pp_limits_buffer <S2SV_ModStart> char * limits = cm -> pp_limits_buffer ; ; <S2SV_ModEnd> ( void ) post ; ( void ) low_var_thresh <S2SV_ModStart> void ) low_var_thresh ; ( void ) flag ; memset <S2SV_ModEnd> ( limits , ( unsigned char ) ppl , <S2SV_ModStart> source -> y_width , limits , 16 ) ; if ( uvfilter == 1 ) { <S2SV_ModStart> source -> uv_width , limits , 8 ) ; }
<S2SV_ModStart> s [ 0 ] ; for ( i = 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> ] = s [ cols - 1 ] ;
<S2SV_ModStart> s [ 0 ] ; for ( i = 0 ; i < 17 ; i ++ ) s [ ( i + rows ) <S2SV_ModEnd> * pitch ] = s [ ( rows -
<S2SV_ModStart> int Pitch ) { unsigned int i , j ; ( void ) bothclamp
<S2SV_ModStart> ; r < 16 ; r ++ ) { memcpy ( dst , src , 16 ) ; <S2SV_ModEnd> src += src_stride ; dst += dst_stride ; }
<S2SV_ModStart> ; r < 4 ; r ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride ; dst += dst_stride ; }
<S2SV_ModStart> ; r < 8 ; r ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride ; dst += dst_stride ; }
<S2SV_ModStart> ; r < 16 ; r ++ ) { memset <S2SV_ModEnd> ( ypred_ptr , expected_dc , 16 ) ; ypred_ptr <S2SV_ModStart> ; r < 16 ; r ++ ) { memset <S2SV_ModEnd> ( ypred_ptr , yleft_col [ r ] , 16
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp8_rtcd ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( YV12_BUFFER_CONFIG * ybf ) { int i ; memset <S2SV_ModEnd> ( ybf -> y_buffer - 1 - ybf -> <S2SV_ModStart> 1 ] = ( unsigned char ) 129 ; memset <S2SV_ModEnd> ( ybf -> u_buffer - 1 - ybf -> <S2SV_ModStart> 1 ] = ( unsigned char ) 129 ; memset <S2SV_ModEnd> ( ybf -> v_buffer - 1 - ybf ->
<S2SV_ModStart> dst , stride , dst , stride ) ; memset <S2SV_ModEnd> ( q , 0 , 2 * sizeof ( <S2SV_ModStart> stride , dst + 4 , stride ) ; memset <S2SV_ModEnd> ( q + 16 , 0 , 2 * <S2SV_ModStart> stride , dst + 8 , stride ) ; memset <S2SV_ModEnd> ( q + 32 , 0 , 2 * <S2SV_ModStart> stride , dst + 12 , stride ) ; memset <S2SV_ModEnd> ( q + 48 , 0 , 2 *
<S2SV_ModStart> br -> count ; int shift = VP8_BD_VALUE_SIZE - CHAR_BIT - ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t bytes_left = br -> user_buffer_end - <S2SV_ModStart> ( br -> decrypt_cb ) { size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br -> decrypt_cb ( br -> decrypt_state ,
<S2SV_ModStart> unsigned char * source , unsigned int source_sz , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void * decrypt_state ) { br ->
<S2SV_ModStart> # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> ) ) { pbi -> frame_corrupt_residual = 1 ; memset <S2SV_ModEnd> ( xd -> qcoeff , 0 , sizeof ( <S2SV_ModStart> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; memset <S2SV_ModEnd> ( xd -> eobs , 0 , 25 ) <S2SV_ModStart> ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> eobs , 0 , 25 ) <S2SV_ModStart> dst , dst_stride , dst , dst_stride ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 2 * <S2SV_ModStart> [ 0 ] , xd -> qcoeff ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 16 * <S2SV_ModStart> [ 0 ] , xd -> qcoeff ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 2 *
<S2SV_ModStart> ; xd -> above_context = pc -> above_context ; memset <S2SV_ModEnd> ( xd -> left_context , 0 , sizeof ( <S2SV_ModStart> v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; xd -> pre . y_buffer = ref_buffer [ ref <S2SV_ModEnd> ] [ 0 ] + recon_yoffset ; xd -> <S2SV_ModStart> ; xd -> pre . u_buffer = ref_buffer [ ref <S2SV_ModEnd> ] [ 1 ] + recon_uvoffset ; xd -> <S2SV_ModStart> ; xd -> pre . v_buffer = ref_buffer [ ref ] [ 2 ] + recon_uvoffset ; } else { xd -> pre . y_buffer = 0 ; xd -> pre . u_buffer = 0 ; xd -> pre . v_buffer = 0 ; } <S2SV_ModEnd> xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context
<S2SV_ModStart> if ( pc -> frame_type == KEY_FRAME ) { memcpy <S2SV_ModEnd> ( pc -> fc . mvc , vp8_default_mv_context , <S2SV_ModStart> ( pc ) ; vp8_default_coef_probs ( pc ) ; memset <S2SV_ModEnd> ( xd -> segment_feature_data , 0 , sizeof ( <S2SV_ModStart> ) ) ; xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; memset <S2SV_ModEnd> ( xd -> ref_lf_deltas , 0 , sizeof ( <S2SV_ModStart> , sizeof ( xd -> ref_lf_deltas ) ) ; memset <S2SV_ModEnd> ( xd -> mode_lf_deltas , 0 , sizeof (
<S2SV_ModStart> ( int ) Border ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 , plane_stride ) ; dest_ptr2 <S2SV_ModStart> ) ( Border ) ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 , plane_stride ) ; dest_ptr2 <S2SV_ModStart> ) ( Border ) ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 , plane_stride ) ; dest_ptr2
<S2SV_ModStart> ; i < plane_height ; i ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 [ 0 ] , Border <S2SV_ModStart> ; i < plane_height ; i ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 [ 0 ] , Border <S2SV_ModStart> ; i < plane_height ; i ++ ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 , src_ptr2 [ 0 ] , Border
<S2SV_ModStart> ( int ) Border ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , src_ptr1 , plane_stride ) ; dest_ptr1 <S2SV_ModStart> ) ( Border ) ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , src_ptr1 , plane_stride ) ; dest_ptr1 <S2SV_ModStart> ) ( Border ) ; i ++ ) { memcpy <S2SV_ModEnd> ( dest_ptr1 , src_ptr1 , plane_stride ) ; dest_ptr1
<S2SV_ModStart> MODE_INFO * mi , MB_MODE_INFO * mbmi ) { ( void ) mbmi ;
<S2SV_ModStart> ( ENTROPY_CONTEXT * ) x -> left_context ) ; memset <S2SV_ModEnd> ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) <S2SV_ModStart> , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; memset <S2SV_ModEnd> ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES )
<S2SV_ModStart> int first_corrupt ) { int mb_row , mb_col ; memset <S2SV_ModEnd> ( overlaps , 0 , sizeof ( MB_OVERLAP )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ; if ( ! pbi ) return NULL ; memset <S2SV_ModEnd> ( pbi , 0 , sizeof ( VP8D_COMP ) <S2SV_ModStart> ; pbi -> overlaps = NULL ; # else ( void ) oxcf ;
<S2SV_ModStart> common , sd , flags ) ; # else ( void ) flags ;
<S2SV_ModStart> const uint8_t * source , int64_t time_stamp ) { <S2SV_ModEnd> VP8_COMMON * cm = & pbi -> common ; <S2SV_ModStart> -> common ; int retcode = - 1 ; ( void ) size ; ( void ) source ; <S2SV_ModStart> if ( retcode <= 0 ) return retcode ; <S2SV_ModEnd> cm -> new_fb_idx = get_free_fb ( cm ) ; <S2SV_ModStart> ; pbi -> last_time_stamp = time_stamp ; decode_exit : <S2SV_ModEnd> pbi -> common . error . setjmp = 0 <S2SV_ModStart> -> common . error . setjmp = 0 ; vp8_clear_system_state ( ) ;
<S2SV_ModStart> # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> ) ) { pbi -> frame_corrupt_residual = 1 ; memset <S2SV_ModEnd> ( xd -> qcoeff , 0 , sizeof ( <S2SV_ModStart> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; memset <S2SV_ModEnd> ( xd -> eobs , 0 , 25 ) <S2SV_ModStart> ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> eobs , 0 , 25 ) <S2SV_ModStart> dst , dst_stride , dst , dst_stride ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 2 * <S2SV_ModStart> [ 0 ] , xd -> qcoeff ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 16 * <S2SV_ModStart> [ 0 ] , xd -> qcoeff ) ; memset <S2SV_ModEnd> ( b -> qcoeff , 0 , 2 *
<S2SV_ModStart> ; xd -> above_context = pc -> above_context ; memset <S2SV_ModEnd> ( xd -> left_context , 0 , sizeof ( <S2SV_ModStart> mb_row != pc -> mb_rows - 1 ) { memcpy <S2SV_ModEnd> ( ( pbi -> mt_yabove_row [ mb_row + 1 <S2SV_ModStart> + 15 * recon_y_stride ) , 16 ) ; memcpy <S2SV_ModEnd> ( ( pbi -> mt_uabove_row [ mb_row + 1 <S2SV_ModStart> + 7 * recon_uv_stride ) , 8 ) ; memcpy <S2SV_ModEnd> ( ( pbi -> mt_vabove_row [ mb_row + 1
<S2SV_ModStart> ; mbd -> mb_segement_abs_delta = xd -> mb_segement_abs_delta ; memcpy <S2SV_ModEnd> ( mbd -> segment_feature_data , xd -> segment_feature_data , <S2SV_ModStart> , sizeof ( xd -> segment_feature_data ) ) ; memcpy <S2SV_ModEnd> ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , <S2SV_ModStart> , sizeof ( xd -> ref_lf_deltas ) ) ; memcpy <S2SV_ModEnd> ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , <S2SV_ModStart> = & pbi -> mbc [ 0 ] ; memcpy <S2SV_ModEnd> ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , <S2SV_ModStart> , sizeof ( xd -> dequant_y1_dc ) ) ; memcpy <S2SV_ModEnd> ( mbd -> dequant_y1 , xd -> dequant_y1 , <S2SV_ModStart> , sizeof ( xd -> dequant_y1 ) ) ; memcpy <S2SV_ModEnd> ( mbd -> dequant_y2 , xd -> dequant_y2 , <S2SV_ModStart> , sizeof ( xd -> dequant_y2 ) ) ; memcpy <S2SV_ModEnd> ( mbd -> dequant_uv , xd -> dequant_uv ,
<S2SV_ModStart> if ( pc -> refresh_entropy_probs == 0 ) { memcpy <S2SV_ModEnd> ( & cpi -> common . lfc , & <S2SV_ModStart> ; i < num_part ; i ++ ) { memmove <S2SV_ModEnd> ( dp , cpi -> partition_d [ i + <S2SV_ModStart> bc [ 1 ] ) ; else # endif vp8_pack_tokens <S2SV_ModEnd> ( & cpi -> bc [ 1 ] ,
<S2SV_ModStart> VP8_DENOISER * denoiser , int width , int height , int num_mb_rows , int num_mb_cols , int mode <S2SV_ModStart> ) { int i ; assert ( denoiser ) ; denoiser -> num_mb_cols = num_mb_cols <S2SV_ModStart> vp8_denoiser_free ( denoiser ) ; return 1 ; } memset <S2SV_ModEnd> ( denoiser -> yv12_running_avg [ i ] . buffer_alloc <S2SV_ModStart> vp8_denoiser_free ( denoiser ) ; return 1 ; } memset <S2SV_ModEnd> ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 , <S2SV_ModStart> 0 , denoiser -> yv12_mc_running_avg . frame_size ) ; if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return <S2SV_ModEnd> 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int vp8_denoiser_filter_c ( unsigned char * mc_running_avg_y , int mc_avg_y_stride , unsigned char * running_avg_y , int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; int sum_diff_thresh ; int r , c <S2SV_ModEnd> ; int sum_diff = 0 ; int adj_val [ <S2SV_ModStart> 3 ] = { 3 , 4 , 6 } ; int shift_inc1 = 0 ; int shift_inc2 = 1 ; int col_sum [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <S2SV_ModStart> } ; if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) { if ( increase_denoising ) { shift_inc1 = 1 ; shift_inc2 = 2 ; } adj_val [ 0 ] += shift_inc2 ; adj_val [ 1 ] += shift_inc2 ; adj_val [ 2 ] += shift_inc2 <S2SV_ModEnd> ; } for ( r = 0 ; r <S2SV_ModStart> ( diff ) ; if ( absdiff <= 3 + shift_inc1 <S2SV_ModStart> [ c ] = mc_running_avg_y [ c ] ; col_sum [ c ] <S2SV_ModEnd> += diff ; } else { if ( absdiff <S2SV_ModStart> ; } else { if ( absdiff >= 4 + shift_inc1 <S2SV_ModStart> ] = sig [ c ] + adjustment ; col_sum [ c ] += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = sig [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] ; } sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs ( sum_diff ) > sum_diff_thresh ) { int delta = ( ( abs ( sum_diff ) - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = mc_running_avg_y [ c ] - sig [ c ] ; int adjustment = abs ( diff ) ; if ( adjustment > delta ) adjustment = delta ; if ( diff > 0 ) { if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } else if ( diff < 0 ) { if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ; col_sum [ c ] += adjustment ; } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } sum_diff = 0 ; for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] <S2SV_ModEnd> ; } if ( abs ( sum_diff ) > <S2SV_ModStart> ; } if ( abs ( sum_diff ) > sum_diff_thresh ) return COPY_BLOCK ; } else { return COPY_BLOCK ; } } vp8_copy_mem16x16 ( running_avg_y_start , avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride ) ; return FILTER_BLOCK ; } <S2SV_null>
<S2SV_ModStart> } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;
<S2SV_ModStart> , cpi -> common . MBs ) ) ; memcpy <S2SV_ModEnd> ( sortlist , cpi -> mb_activity_map , sizeof (
<S2SV_ModStart> ] ++ ; } } # endif if ( cpi -> current_layer == 0 ) { if <S2SV_ModEnd> ( xd -> mode_info_context -> mbmi . mode == <S2SV_ModStart> xd -> mode_info_context -> mbmi . mode == ZEROMV && <S2SV_ModEnd> xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> { int tok_count = * tp - tp_start ; vp8_pack_tokens <S2SV_ModEnd> ( w , tp_start , tok_count ) ; }
<S2SV_ModStart> -> mvc = cm -> fc . mvc ; memset <S2SV_ModEnd> ( cm -> above_context , 0 , sizeof (
<S2SV_ModStart> ( ++ b < 16 ) ; } # else ( void ) cpi ; #
<S2SV_ModStart> { unsigned int act ; unsigned int sse ; ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> ( x -> src . y_buffer , x ->
<S2SV_ModStart> 1 << cm -> multi_token_partition ) ; # endif memset <S2SV_ModEnd> ( segment_counts , 0 , sizeof ( segment_counts ) <S2SV_ModStart> update_mb_segmentation_map ) { int tot_count ; int i ; memset <S2SV_ModEnd> ( xd -> mb_segment_tree_probs , 255 , sizeof (
<S2SV_ModStart> x , i ) ; } } intra_pred_var = vpx_get_mb_ss <S2SV_ModEnd> ( x -> src_diff ) ; return intra_pred_var ;
<S2SV_ModStart> mb -> e_mbd . block [ ib ] ; <S2SV_ModEnd> dequant_ptr = d -> dequant ; coeff_ptr = b
<S2SV_ModStart> ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; memcpy <S2SV_ModEnd> ( & t_above , x -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , x -> e_mbd . left_context
<S2SV_ModStart> ! x -> e_mbd . left_context ) return ; memcpy <S2SV_ModEnd> ( & t_above , x -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , x -> e_mbd . left_context
<S2SV_ModStart> ! x -> e_mbd . left_context ) return ; memcpy <S2SV_ModEnd> ( & t_above , x -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , x -> e_mbd . left_context
<S2SV_ModStart> { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ; ( void ) cpi
<S2SV_ModStart> ; start_pos = cpi -> twopass . stats_in ; memset <S2SV_ModEnd> ( & next_frame , 0 , sizeof ( next_frame <S2SV_ModStart> ) { boost_score = old_boost_score ; break ; } memcpy <S2SV_ModEnd> ( this_frame , & next_frame , sizeof ( *
<S2SV_ModStart> int new_mv_mode_penalty = 256 ; v_fn_ptr . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd -> pre . y_buffer = recon_buffer ->
<S2SV_ModStart> double motion_decay ; double motion_pct = next_frame -> pcnt_motion ; ( void ) cpi
<S2SV_ModStart> , FIRSTPASS_STATS * stats ) { struct vpx_codec_cx_pkt pkt ; ( void ) cpi
<S2SV_ModStart> ; double decay_accumulator = 1.0 ; double next_iiratio ; memcpy <S2SV_ModEnd> ( & local_next_frame , next_frame , sizeof ( *
<S2SV_ModStart> <S2SV_null> void vp8_end_second_pass ( VP8_COMP * cpi ) { ( void ) cpi ;
<S2SV_ModStart> -> base_qindex , cm -> y1dc_delta_q ) ) ; memcpy <S2SV_ModEnd> ( cm -> fc . mvc , vp8_default_mv_context ,
<S2SV_ModStart> cpi -> twopass . frames_to_key == 0 ) { memcpy <S2SV_ModEnd> ( & this_frame_copy , & this_frame , sizeof ( <S2SV_ModStart> if ( cpi -> frames_till_gf_update_due == 0 ) { memcpy <S2SV_ModEnd> ( & this_frame_copy , & this_frame , sizeof ( <S2SV_ModStart> ) { int bak = cpi -> per_frame_bandwidth ; memcpy <S2SV_ModEnd> ( & this_frame_copy , & this_frame , sizeof ( <S2SV_ModStart> cpi -> common . frame_type != KEY_FRAME ) { memcpy <S2SV_ModEnd> ( & this_frame_copy , & this_frame , sizeof ( <S2SV_ModStart> , & this_frame_copy ) ; } } else { memcpy <S2SV_ModEnd> ( & this_frame_copy , & this_frame , sizeof (
<S2SV_ModStart> = x -> e_mbd . pre . y_stride ; ( void ) cpi ; <S2SV_ModStart> y_buffer + recon_yoffset + d -> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr , src_stride , raw_ptr , raw_stride , <S2SV_ModStart> pre . y_buffer + d -> offset ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr , src_stride , ref_ptr , ref_stride ,
<S2SV_ModStart> sdf ( what , what_stride , in_what , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( best_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> sdf ( what , what_stride , in_what , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( best_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> pre_stride ; # endif bestmv -> as_mv . row *= 8 ; bestmv -> as_mv . col *= 8 <S2SV_ModEnd> ; startmv = * bestmv ; bestmse = vfp
<S2SV_ModStart> sdf ( what , what_stride , bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( best_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; this_mv . as_mv . col = c
<S2SV_ModStart> sdf ( what , what_stride , bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( best_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> distance ; int col_max = ref_col + distance ; DECLARE_ALIGNED ( 16 , unsigned int , sad_array8 [ 8 ] <S2SV_ModEnd> ) ; unsigned int sad_array [ 3 ] ; <S2SV_ModStart> sdf ( what , what_stride , bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( best_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> = center_mv -> as_mv . col >> 3 ; ( void ) mvcost ; <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( & this_mv , & fcenter_mv <S2SV_ModStart> hex_range = 63 ; dia_range = 8 ; # else ( void ) search_param ; # <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } else { for ( <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } if ( best_site == <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } else { for ( <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } if ( best_site == <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } else { for ( <S2SV_ModStart> sdf ( what , what_stride , this_offset , in_what_stride <S2SV_ModEnd> ) ; CHECK_BETTER } } if ( best_site ==
<S2SV_ModStart> sdf ( what , what_stride , best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( ref_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> sdf ( what , what_stride , best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost ( ref_mv , & fcenter_mv , <S2SV_ModStart> sdf ( what , what_stride , check_here , in_what_stride <S2SV_ModEnd> ) ; if ( thissad < bestsad ) {
<S2SV_ModStart> col += 16 ) { unsigned int sse ; vpx_mse16x16 <S2SV_ModEnd> ( orig + col , orig_stride , recon +
<S2SV_ModStart> ; cpi -> cyclic_refresh_q = Q / 2 ; if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> ( cpi -> segmentation_map , 0 , mbs_in_frame ) <S2SV_ModStart> if ( cpi -> common . frame_type != KEY_FRAME && block_count > 0 <S2SV_ModStart> cyclic_refresh_mode_index ) ; cpi -> cyclic_refresh_mode_index = i ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif
<S2SV_ModStart> ) ) { cm -> frame_type = KEY_FRAME ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) { vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ; } # endif } # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 <S2SV_ModEnd> ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * <S2SV_ModStart> LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { <S2SV_ModStart> == low_res_frame_info -> low_res_ref_frames [ GOLDEN_FRAME ] ) ; } } if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . mr_encoder_id ) { if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) { unsigned int i ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target = lc -> starting_buffer_level ; lc -> buffer_level = lc -> starting_buffer_level ; } } cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ; } else { low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ; } } } # endif cpi -> closest_reference_frame = LAST_FRAME ; if ( cm -> frame_type != KEY_FRAME ) { int i ; MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { closest_ref = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) { closest_ref = GOLDEN_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) { closest_ref = ALTREF_FRAME ; } for ( i = 1 ; i <= 3 ; i ++ ) { vpx_ref_frame_type_t ref_frame_type = ( vpx_ref_frame_type_t ) ( ( i == 3 ) ? 4 : i ) ; if ( cpi -> ref_frame_flags & ref_frame_type ) { if ( ( cm -> current_video_frame - cpi -> current_ref_frames [ i ] ) < ( cm -> current_video_frame - cpi -> current_ref_frames [ closest_ref ] ) ) { closest_ref = i ; } } } cpi -> closest_reference_frame = closest_ref ; } <S2SV_ModEnd> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_ModStart> . rd_thresh_mult [ i ] = 128 ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> # endif if ( cpi -> cyclic_refresh_mode_enabled ) { int disable_cr_gf = ( cpi -> oxcf . screen_content_mode == 2 && cm -> refresh_golden_frame ) ; if ( cpi -> current_layer == 0 && cpi -> force_maxqp == 0 && ! disable_cr_gf <S2SV_ModEnd> ) cyclic_background_refresh ( cpi , Q , 0 ) <S2SV_ModStart> scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ; # if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) { if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) { vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 0 ) ; } } # endif <S2SV_ModStart> cpi -> Source , l , 1 , 0 , 1 <S2SV_ModStart> cpi -> Source , l , 1 , 0 , 1 <S2SV_ModStart> } } # endif # ifdef OUTPUT_YUV_SRC vp8_write_yuv_frame ( yuv_file , <S2SV_ModStart> ) ; else disable_segmentation ( cpi ) ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> if ( cm -> refresh_entropy_probs == 0 ) { memcpy <S2SV_ModEnd> ( & cm -> lfc , & cm -> <S2SV_ModStart> ; } # else vp8_encode_frame ( cpi ) ; if ( cpi -> oxcf . screen_content_mode == 2 ) { if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ; } <S2SV_ModStart> if ( tmp -> mbmi . mode == ZEROMV && tmp -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> yv12_fb [ cm -> new_fb_idx ] ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { cpi -> mse_source_denoised = measure_square_diff_partial ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi -> Source , cpi ) ; } if ( cpi -> oxcf . noise_sensitivity == 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { process_denoiser_mode_change ( cpi ) ; } # endif # if <S2SV_ModStart> cm ) ; } update_reference_frames ( cpi ) ; # ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; # endif <S2SV_ModStart> -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = -
<S2SV_ModStart> oxcf -> Version ; vp8_setup_version ( cm ) ; if ( oxcf -> timebase . num > 0 ) { <S2SV_ModStart> ) ( oxcf -> timebase . num ) ; } else { cpi -> framerate = 30 ; } <S2SV_ModStart> 30 ; cpi -> ref_framerate = cpi -> framerate ; cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1
<S2SV_ModStart> -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . ref_lf_deltas , <S2SV_ModStart> -> mb . e_mbd . ref_lf_deltas ) ) ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . mode_lf_deltas ,
<S2SV_ModStart> -> mb . e_mbd . mb_segement_abs_delta = abs_delta ; memcpy <S2SV_ModEnd> ( cpi -> segment_feature_data , feature_data , sizeof (
<S2SV_ModStart> * cpi , unsigned char * segmentation_map ) { memcpy <S2SV_ModEnd> ( cpi -> segmentation_map , segmentation_map , ( cpi
<S2SV_ModStart> -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . ref_lf_deltas , <S2SV_ModStart> -> mb . e_mbd . ref_lf_deltas ) ) ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . mode_lf_deltas , <S2SV_ModStart> -> mb . e_mbd . mode_lf_deltas ) ) ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . last_ref_lf_deltas , <S2SV_ModStart> -> mb . e_mbd . ref_lf_deltas ) ) ; memset <S2SV_ModEnd> ( cpi -> mb . e_mbd . last_mode_lf_deltas ,
<S2SV_ModStart> cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi -> gf_active_flags , 1 , ( cm
<S2SV_ModStart> cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi -> gf_active_flags , 1 , ( cm
<S2SV_ModStart> i = 0 ; i < oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { LAYER_CONTEXT * lc = & cpi ->
<S2SV_ModStart> = cm -> gld_fb_idx = cm -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> <S2SV_ModStart> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ; <S2SV_ModEnd> } else { if ( cm -> refresh_alt_ref_frame ) <S2SV_ModStart> ; cm -> alt_fb_idx = cm -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> <S2SV_ModStart> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ; <S2SV_ModEnd> } else if ( cm -> copy_buffer_to_arf ) { <S2SV_ModStart> ; cm -> alt_fb_idx = cm -> lst_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> <S2SV_ModStart> ] = cpi -> current_ref_frames [ LAST_FRAME ] ; <S2SV_ModEnd> } } else { if ( cm -> alt_fb_idx <S2SV_ModStart> ; cm -> alt_fb_idx = cm -> gld_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> <S2SV_ModStart> ] = cpi -> current_ref_frames [ GOLDEN_FRAME ] ; <S2SV_ModEnd> } } } if ( cm -> refresh_golden_frame ) <S2SV_ModStart> ; cm -> gld_fb_idx = cm -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> <S2SV_ModStart> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ; <S2SV_ModEnd> } else if ( cm -> copy_buffer_to_gf ) { <S2SV_ModStart> ; cm -> gld_fb_idx = cm -> lst_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> <S2SV_ModStart> ] = cpi -> current_ref_frames [ LAST_FRAME ] ; <S2SV_ModEnd> } } else { if ( cm -> alt_fb_idx <S2SV_ModStart> ; cm -> gld_fb_idx = cm -> alt_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> <S2SV_ModStart> ] = cpi -> current_ref_frames [ ALTREF_FRAME ] ; <S2SV_ModEnd> } } } } if ( cm -> refresh_last_frame <S2SV_ModStart> ; cm -> lst_fb_idx = cm -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames [ LAST_FRAME ] = cm -> <S2SV_ModStart> current_ref_frames [ LAST_FRAME ] = cm -> current_video_frame ; <S2SV_ModEnd> } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf <S2SV_ModStart> -> frame_type == KEY_FRAME ) { int i ; for ( i = LAST_FRAME ; i < MAX_REF_FRAMES ; ++ i ) vp8_yv12_copy_frame ( cpi -> Source <S2SV_ModEnd> , & cpi -> denoiser . yv12_running_avg [ i <S2SV_ModStart> . yv12_running_avg [ LAST_FRAME ] ) ; } } if ( cpi -> oxcf . noise_sensitivity == 4 ) vp8_yv12_copy_frame ( cpi -> Source , & cpi -> denoiser . yv12_last_source ) ;
<S2SV_ModStart> ( * cpi -> active_map ) ) ) ; memset <S2SV_ModEnd> ( cpi -> active_map , 1 , ( cm <S2SV_ModStart> TOKENLIST ) * cm -> mb_rows ) ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif
<S2SV_ModStart> 16 ) { unsigned int sse ; Total += vpx_mse16x16 <S2SV_ModEnd> ( src + j , source -> y_stride ,
<S2SV_ModStart> ? cpi -> oxcf . alt_freq : DEFAULT_GF_INTERVAL ; <S2SV_ModEnd> # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) cpi -> <S2SV_ModStart> cpi -> oxcf . number_of_layers != prev_number_of_layers ) { if ( cpi -> temporal_layer_id > 0 ) { cpi -> temporal_layer_id = 0 ; } <S2SV_ModStart> ( cpi , oxcf , prev_number_of_layers ) ; } if ( ! cpi -> initial_width ) { cpi -> initial_width = cpi -> oxcf . Width ; cpi -> initial_height = cpi -> oxcf . Height ; } cm -> Width = cpi -> oxcf . Width <S2SV_ModEnd> ; cm -> Height = cpi -> oxcf . <S2SV_ModStart> cm -> Height = cpi -> oxcf . Height ; assert ( cm -> Width <= cpi -> initial_width ) ; assert ( cm -> Height <= cpi -> initial_height ) <S2SV_ModStart> ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity
<S2SV_ModStart> 0 ; cm = & cpi -> common ; memset <S2SV_ModEnd> ( cpi , 0 , sizeof ( VP8_COMP ) <S2SV_ModStart> ; cpi -> temporal_pattern_counter = 0 ; cpi -> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> = 0.0 ; } } # endif cpi -> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> cpi -> common . mb_cols ) / 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> cyclic_refresh_map = ( signed char * ) NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> -> common . refresh_alt_ref_frame = 0 ; cpi -> force_maxqp = 0 ; cpi -> <S2SV_ModStart> ( "bd.yuv" , "ab" ) ; # endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( "denoised.yuv" , "ab" ) ; # endif # <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vpx_sad16x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . vf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vpx_variance16x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . svf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vpx_sub_pixel_variance16x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vpx_sad16x16x3 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vpx_sad16x16x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vpx_sad16x16x4d <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . sdf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vpx_sad16x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . vf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vpx_variance16x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vpx_sub_pixel_variance16x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vpx_sad16x8x3 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vpx_sad16x8x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vpx_sad16x8x4d <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . sdf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vpx_sad8x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . vf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vpx_variance8x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vpx_sub_pixel_variance8x16 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vpx_sad8x16x3 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vpx_sad8x16x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vpx_sad8x16x4d <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . sdf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vpx_sad8x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . vf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vpx_variance8x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vpx_sad8x8x3 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vpx_sad8x8x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vpx_sad8x8x4d <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . sdf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vpx_sad4x4 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . vf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vpx_variance4x4 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vpx_sub_pixel_variance4x4 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vpx_sad4x4x3 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vpx_sad4x4x8 <S2SV_ModEnd> ; cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df <S2SV_ModStart> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vpx_sad4x4x4d <S2SV_ModEnd> ; # if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr
<S2SV_ModStart> , int64_t * time_end , int flush ) { <S2SV_ModEnd> VP8_COMMON * cm ; struct vpx_usec_timer tsctimer ; struct <S2SV_ModStart> -> common . error . setjmp = 0 ; vp8_clear_system_state ( ) ; <S2SV_ModStart> -> common . error . setjmp = 1 ; <S2SV_ModEnd> vpx_usec_timer_start ( & cmptimer ) ; cpi -> source <S2SV_ModStart> ) ; cpi -> twopass . first_pass_done = 1 <S2SV_ModEnd> ; } # endif return - 1 ; } <S2SV_ModStart> cpi -> ref_framerate = 10000000.0 / avg_duration ; } # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ; } else { low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ; } } # endif <S2SV_ModStart> 0 ; i < cpi -> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { LAYER_CONTEXT * lc = & cpi -> <S2SV_ModStart> { int layer ; update_layer_contexts ( cpi ) ; if ( cpi -> temporal_layer_id >= 0 ) { layer = cpi -> temporal_layer_id ; } else { <S2SV_ModStart> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; } <S2SV_ModStart> if ( cm -> refresh_entropy_probs == 0 ) { memcpy <S2SV_ModEnd> ( & cm -> fc , & cm -> <S2SV_ModStart> ) ; } if ( cm -> refresh_alt_ref_frame ) memcpy <S2SV_ModEnd> ( & cpi -> lfc_a , & cm -> <S2SV_ModStart> ) ) ; if ( cm -> refresh_golden_frame ) memcpy <S2SV_ModEnd> ( & cpi -> lfc_g , & cm -> <S2SV_ModStart> ) ) ; if ( cm -> refresh_last_frame ) memcpy <S2SV_ModEnd> ( & cpi -> lfc_n , & cm -> <S2SV_ModStart> * recon = cpi -> common . frame_to_show ; unsigned int y_width = cpi -> common . Width ; unsigned int y_height = cpi -> common . Height ; unsigned int uv_width = ( y_width + 1 ) / 2 ; unsigned int uv_height = ( y_height + 1 ) / 2 ; int y_samples = y_height * y_width ; int uv_samples = uv_height * <S2SV_ModEnd> uv_width ; int t_samples = y_samples + 2 * <S2SV_ModStart> = y_samples + 2 * uv_samples ; double sq_error <S2SV_ModEnd> ; ye = calc_plane_error ( orig -> y_buffer , <S2SV_ModStart> , recon -> y_buffer , recon -> y_stride , y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ; ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , uv_width , <S2SV_ModEnd> uv_height ) ; sq_error = ( double ) ( <S2SV_ModStart> * pp = & cm -> post_proc_buffer ; double sq_error2 ; double <S2SV_ModStart> , pp -> y_buffer , pp -> y_stride , y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ; ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , uv_width , <S2SV_ModEnd> uv_height ) ; sq_error2 = ( double ) ( <S2SV_ModStart> ; cpi -> totalp += frame_psnr2 ; frame_ssim2 = vpx_calc_ssim <S2SV_ModEnd> ( cpi -> Source , & cm -> post_proc_buffer <S2SV_ModStart> ( cpi -> Source , & cm -> post_proc_buffer <S2SV_ModEnd> , & weight ) ; cpi -> summed_quality += <S2SV_ModStart> , u , v , frame_all ; frame_all = vpx_calc_ssimg <S2SV_ModEnd> ( cpi -> Source , cm -> frame_to_show , <S2SV_ModStart> ( f ) ; } # endif # endif <S2SV_ModEnd> cpi -> common . error . setjmp = 0
<S2SV_ModStart> common , dest , flags ) ; # else ( void ) flags ;
<S2SV_ModStart> { const FRAME_TYPE frame_type = cm -> frame_type ; int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> ( cpi -> sf . auto_filter == 0 ) { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModEnd> if ( cm -> filter_level > 0 ) { <S2SV_ModStart> # endif if ( cm -> filter_level > 0 && update_any_ref_buffers
<S2SV_ModStart> sd , int64_t time_stamp , int64_t end_time ) { <S2SV_ModEnd> struct vpx_usec_timer timer ; int res = 0 ; <S2SV_ModStart> struct vpx_usec_timer timer ; int res = 0 ; <S2SV_ModEnd> vpx_usec_timer_start ( & timer ) ; if ( sd <S2SV_ModStart> -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; <S2SV_ModEnd> return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> time_encoded ; if ( cpi -> b_calculate_psnr ) { <S2SV_ModEnd> if ( cpi -> oxcf . number_of_layers > 1 <S2SV_ModStart> 2 * cpi -> frames_in_layer [ i ] * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double total_psnr = vpx_sse_to_psnr ( samples , 255.0 <S2SV_ModStart> = 3.0 / 2 * cpi -> count * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double total_psnr = vpx_sse_to_psnr ( samples , 255.0 <S2SV_ModStart> ) ; vpx_free ( cpi -> cyclic_refresh_map ) ; vpx_free ( cpi -> consec_zero_last ) ; vpx_free ( cpi -> consec_zero_last_mvbias ) ; <S2SV_ModStart> OUTPUT_YUV_SRC fclose ( yuv_file ) ; # endif # ifdef OUTPUT_YUV_DENOISED fclose ( yuv_denoised_file ) ; # endif #
<S2SV_ModStart> . mb_cols ) { if ( map ) { memcpy <S2SV_ModEnd> ( cpi -> active_map , map , rows *
<S2SV_ModStart> } cpi -> mb . mbs_tested_so_far = 0 ; cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> ] = speed_map ( Speed , thresh_mult_map_split2 ) ; if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> >= 15 ) sf -> half_pixel_search = 0 ; memset <S2SV_ModEnd> ( cpi -> mb . error_bins , 0 , <S2SV_ModStart> { cpi -> mb . quantize_b = vp8_regular_quantize_b ; } else { cpi -> mb . quantize_b = vp8_fast_quantize_b <S2SV_ModEnd> ; } if ( cpi -> sf . improved_quant
<S2SV_ModStart> . mode_info_context -> mbmi . mv ; int this_rd ; int denoise_aggressive = 0 <S2SV_ModStart> -> rddiv , rate2 , * distortion2 ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && this_mode == ZEROMV <S2SV_ModEnd> && x -> e_mbd . mode_info_context -> mbmi . <S2SV_ModStart> x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) ) { if ( x -> is_skin <S2SV_ModEnd> ) rd_adj = 100 ; this_rd = ( (
<S2SV_ModStart> ) ; dptr = b -> predictor ; return vpx_get4x4sse_cs <S2SV_ModEnd> ( sptr , be -> src_stride , dptr ,
<S2SV_ModStart> int best_mode_index = 0 ; unsigned int sse = UINT_MAX , best_rd_sse = UINT_MAX ; # if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = UINT_MAX , best_sse = UINT_MAX <S2SV_ModEnd> ; # endif int sf_improved_mv_pred = cpi -> sf <S2SV_ModStart> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> [ 4 ] ; int sign_bias = 0 ; int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi <S2SV_ModStart> cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail <S2SV_ModEnd> ; if ( parent_ref_valid ) { int parent_ref_flag ; <S2SV_ModStart> ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME <S2SV_ModEnd> ) ; if ( parent_ref_frame && ! parent_ref_flag ) <S2SV_ModStart> parent_ref_frame && ! parent_ref_flag ) parent_ref_valid = 0 ; if ( dot_artifact_candidate ) parent_ref_valid = 0 ; } # endif { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { <S2SV_ModStart> sign_bias ] ; best_ref_mv . as_int = 0 ; memset <S2SV_ModEnd> ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) <S2SV_ModStart> , 0 , sizeof ( mode_mv_sb ) ) ; memset <S2SV_ModEnd> ( & best_mbmode , 0 , sizeof ( best_mbmode <S2SV_ModStart> = best_ref_mv_sb [ sign_bias ] . as_int ; } <S2SV_ModEnd> x -> mbs_tested_so_far ++ ; * returnintra = INT_MAX <S2SV_ModStart> . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; if ( cpi -> Speed < 12 ) { <S2SV_ModStart> ( cpi , x , & rd_adjustment ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> } else { rate2 += rate ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( b -> base_src ) , b <S2SV_ModStart> xd -> predictor , 16 ) ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( b -> base_src ) , b <S2SV_ModStart> if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_encoder_id <S2SV_ModEnd> ) sf_improved_mv_pred = 0 ; if ( parent_ref_valid && <S2SV_ModStart> ) sf_improved_mv_pred = 0 ; if ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> ) { mvp . as_int = parent_ref_mv . as_int <S2SV_ModStart> } } # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> && dissim <= 2 && MAX ( abs ( <S2SV_ModStart> ) { # if CONFIG_MULTI_RES_ENCODING if ( ! parent_ref_valid || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> as_int = d -> bmi . mv . as_int ; vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity ) { int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> if ( this_mode == ZEROMV && sse < zero_mv_sse && ! skip_old_reference <S2SV_ModStart> mbmi . mode == NEWMV && sse < best_sse && ! skip_old_reference <S2SV_ModStart> ; best_rd_sse = sse ; best_rd = this_rd ; memcpy <S2SV_ModEnd> ( & best_mbmode , & x -> e_mbd . <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> best_mbmode . ref_frame ; best_sse = best_rd_sse ; } if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> x , best_sse , zero_mv_sse , recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = ( best_mbmode . ref_frame == INTRA_FRAME ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModEnd> && x -> best_zeromv_reference_frame != INTRA_FRAME ) { int <S2SV_ModStart> 0 ; int this_ref_frame = x -> best_zeromv_reference_frame ; rd_adjustment = 100 ; <S2SV_ModStart> ) ; if ( this_rd < best_rd ) { memcpy <S2SV_ModEnd> ( & best_mbmode , & x -> e_mbd . <S2SV_ModStart> ; } if ( ! x -> skip ) memcpy <S2SV_ModEnd> ( & x -> e_mbd . mode_info_context -> mbmi
<S2SV_ModStart> ; ( void ) vfp ; ( void ) mb ; ( void )
<S2SV_ModStart> 16 ) { unsigned int sse ; Total += vpx_mse16x16 <S2SV_ModEnd> ( src + j , source -> y_stride ,
<S2SV_ModStart> -> base_qindex ) ; int filt_val ; int best_filt_val <S2SV_ModEnd> ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_ModStart> = cm -> filter_level ; best_filt_val = filt_val ; yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , cm -> frame_to_show ) ; vp8_loop_filter_partial_frame <S2SV_ModStart> ) ; while ( filt_val >= min_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , cm -> frame_to_show ) ; vp8_loop_filter_partial_frame <S2SV_ModStart> ) ; while ( filt_val < max_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , cm -> frame_to_show ) ; vp8_loop_filter_partial_frame
<S2SV_ModStart> == ( cpi -> current_gf_interval >> 1 ) ) { Adjustment = <S2SV_ModEnd> ( cpi -> current_gf_interval - 1 ) * Adjustment <S2SV_ModStart> ( cpi -> current_gf_interval - 1 ) * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <S2SV_ModEnd> else cpi -> this_frame_target -= Adjustment ; } }
<S2SV_ModStart> ) { int Q = cpi -> active_worst_quality ; if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; }
<S2SV_ModStart> { vp8_default_coef_probs ( & cpi -> common ) ; memcpy <S2SV_ModEnd> ( cpi -> common . fc . mvc , <S2SV_ModStart> . fc . mvc , flag ) ; } memcpy <S2SV_ModEnd> ( & cpi -> lfc_a , & cpi -> <S2SV_ModStart> ( cpi -> common . fc ) ) ; memcpy <S2SV_ModEnd> ( & cpi -> lfc_g , & cpi -> <S2SV_ModStart> ( cpi -> common . fc ) ) ; memcpy <S2SV_ModEnd> ( & cpi -> lfc_n , & cpi ->
<S2SV_ModStart> ( mv_row | mv_col ) & 7 ) { vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( uptr , pre_stride , mv_col & 7 , <S2SV_ModStart> , upred_ptr , uv_stride , & sse2 ) ; vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( vptr , pre_stride , mv_col & 7 , <S2SV_ModStart> ) ; sse2 += sse1 ; } else { vpx_variance8x8 <S2SV_ModEnd> ( uptr , pre_stride , upred_ptr , uv_stride , <S2SV_ModStart> , upred_ptr , uv_stride , & sse2 ) ; vpx_variance8x8 <S2SV_ModEnd> ( vptr , pre_stride , vpred_ptr , uv_stride ,
<S2SV_ModStart> ) threshold = x -> encode_breakout ; var = vpx_variance16x16 <S2SV_ModEnd> ( * ( b -> base_src ) , b
<S2SV_ModStart> ; ENTROPY_CONTEXT * ta_b ; ENTROPY_CONTEXT * tl_b ; memcpy <S2SV_ModEnd> ( & t_above , x -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , x -> e_mbd . left_context <S2SV_ModStart> ; ENTROPY_CONTEXT * ta_s ; ENTROPY_CONTEXT * tl_s ; memcpy <S2SV_ModEnd> ( & t_above_s , & t_above , sizeof ( <S2SV_ModStart> & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left_s , & t_left , sizeof ( <S2SV_ModStart> ; mode_selected = this_mode ; best_label_rd = this_rd ; memcpy <S2SV_ModEnd> ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) <S2SV_ModStart> , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) <S2SV_ModStart> , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; } } memcpy <S2SV_ModEnd> ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) <S2SV_ModStart> , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES )
<S2SV_ModStart> ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; memcpy <S2SV_ModEnd> ( & t_above , mb -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , mb -> e_mbd . left_context
<S2SV_ModStart> , int * distortion , int fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> , int * distortion , int fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> = * l , templ = * l ; DECLARE_ALIGNED ( 16 , unsigned char , best_predictor [ 16 * 4 ] ) ; DECLARE_ALIGNED ( 16 , short , best_dqcoeff [ 16 ] <S2SV_ModEnd> ) ; int dst_stride = x -> e_mbd . <S2SV_ModStart> copy_predictor ( best_predictor , b -> predictor ) ; memcpy <S2SV_ModEnd> ( best_dqcoeff , b -> dqcoeff , 32 )
<S2SV_ModStart> ENTROPY_CONTEXT * tl ; const int * bmode_costs ; memcpy <S2SV_ModEnd> ( & t_above , mb -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , mb -> e_mbd . left_context
<S2SV_ModStart> ) ) ; best_mode -> rd = this_rd ; memcpy <S2SV_ModEnd> ( & best_mode -> mbmode , & x -> <S2SV_ModStart> -> mbmi , sizeof ( MB_MODE_INFO ) ) ; memcpy <S2SV_ModEnd> ( & best_mode -> partition , x -> partition_info
<S2SV_ModStart> y_buffer - 16 , xd -> dst . y_stride <S2SV_ModEnd> ) ; } else if ( xd -> mb_to_left_edge <S2SV_ModStart> y_stride * 16 , xd -> dst . y_stride <S2SV_ModEnd> ) ; } else { near_sad [ 0 ] <S2SV_ModStart> y_stride * 16 , xd -> dst . y_stride <S2SV_ModEnd> ) ; near_sad [ 1 ] = cpi -> <S2SV_ModStart> y_buffer - 16 , xd -> dst . y_stride <S2SV_ModEnd> ) ; near_sad [ 2 ] = cpi -> <S2SV_ModStart> 16 - 16 , xd -> dst . y_stride <S2SV_ModEnd> ) ; } if ( cpi -> common . <S2SV_ModStart> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride <S2SV_ModEnd> ) ; if ( near_sad [ 5 ] != <S2SV_ModStart> b -> src_stride , pre_y_buffer - 16 , pre_y_stride <S2SV_ModEnd> ) ; near_sad [ 3 ] = cpi -> <S2SV_ModStart> src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride <S2SV_ModEnd> ) ; if ( near_sad [ 6 ] != <S2SV_ModStart> b -> src_stride , pre_y_buffer + 16 , pre_y_stride <S2SV_ModEnd> ) ; if ( near_sad [ 7 ] != <S2SV_ModStart> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride <S2SV_ModEnd> ) ; } if ( cpi -> common .
<S2SV_ModStart> col = mvy [ vcnt / 2 ] ; <S2SV_ModEnd> * sr = 0 ; } } mvp ->
<S2SV_ModStart> mvthresh ) { int i ; BEST_SEG_INFO bsi ; memset <S2SV_ModEnd> ( & bsi , 0 , sizeof ( bsi
<S2SV_ModStart> returnrate , int * returndistortion , int * returnintra , int mb_row , int mb_col <S2SV_ModStart> ) ; # if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = UINT_MAX , best_sse = UINT_MAX , best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # endif mode_mv = mode_mv_sb [ sign_bias ] <S2SV_ModStart> = INT_MAX ; best_mode . intra_rd = INT_MAX ; memset <S2SV_ModEnd> ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) <S2SV_ModStart> , 0 , sizeof ( mode_mv_sb ) ) ; memset <S2SV_ModEnd> ( & best_mode . mbmode , 0 , sizeof <S2SV_ModStart> , sizeof ( best_mode . mbmode ) ) ; memset <S2SV_ModEnd> ( & best_mode . bmodes , 0 , sizeof <S2SV_ModStart> = d -> bmi . mv . as_int ; <S2SV_ModEnd> further_steps = ( cpi -> sf . max_step_search_steps - <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> x , best_sse , zero_mv_sse , recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart> best_mode . rd || x -> skip ) { <S2SV_ModEnd> * returnrate = rd . rate2 ; * returndistortion <S2SV_ModStart> mbmi . partitioning = 0 ; return ; } memcpy <S2SV_ModEnd> ( & x -> e_mbd . mode_info_context -> mbmi <S2SV_ModStart> bmodes [ i ] . mv . as_int ; memcpy <S2SV_ModEnd> ( x -> partition_info , & best_mode . partition
<S2SV_ModStart> ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; memcpy <S2SV_ModEnd> ( & t_above , mb -> e_mbd . above_context <S2SV_ModStart> . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy <S2SV_ModEnd> ( & t_left , mb -> e_mbd . left_context
<S2SV_ModStart> vpx_image_t * img , YV12_BUFFER_CONFIG * yv12 ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> planes [ VPX_PLANE_V ] ; yv12 -> y_crop_width = y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h <S2SV_ModEnd> ; yv12 -> y_stride = img -> stride [
<S2SV_ModStart> -> mr_low_res_mode_info = mr_cfg -> mr_low_res_mode_info ; } # else ( void ) mr_cfg ; # <S2SV_ModStart> arnr_type ; oxcf -> tuning = vp8_cfg . tuning ; oxcf -> screen_content_mode = vp8_cfg . screen_content_mode
<S2SV_ModStart> ( cfg , g_timebase . num , 1 , 1000000000 <S2SV_ModEnd> ) ; RANGE_CHECK_HI ( cfg , g_profile , 3 <S2SV_ModStart> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> <= cfg -> ts_target_bitrate [ i - 1 ] && cfg -> rc_target_bitrate > 0
<S2SV_ModStart> ; vp8_remove_compressor ( & ctx -> cpi ) ; vpx_free <S2SV_ModEnd> ( ctx ) ; return VPX_CODEC_OK ; } <S2SV_null>
<S2SV_ModStart> ( & ctx -> pkt_list ) ; if ( ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> if ( ctx -> cfg . kf_mode == VPX_KF_AUTO <S2SV_ModStart> ctx -> cpi ; round = ( vpx_codec_pts_t ) 10000000 <S2SV_ModEnd> * ctx -> cfg . g_timebase . num /
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * data =
<S2SV_ModStart> * mr_cfg ) { vpx_codec_err_t res = VPX_CODEC_OK ; vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; if ( ! ctx -> priv ) { struct vpx_codec_alg_priv * priv = ( struct vpx_codec_alg_priv * ) vpx_calloc ( 1 , sizeof ( * priv <S2SV_ModEnd> ) ) ; if ( ! priv ) { <S2SV_ModStart> { return VPX_CODEC_MEM_ERROR ; } ctx -> priv = ( vpx_codec_priv_t * ) <S2SV_ModEnd> priv ; ctx -> priv -> init_flags = ctx <S2SV_ModStart> if ( ctx -> config . enc ) { priv <S2SV_ModEnd> -> cfg = * ctx -> config . enc <S2SV_ModStart> enc ; ctx -> config . enc = & priv -> cfg ; } priv -> vp8_cfg = default_extracfg <S2SV_ModEnd> ; priv -> vp8_cfg . pkt_list = & priv <S2SV_ModStart> if ( ! res ) { set_vp8e_config ( & priv -> oxcf , priv -> cfg , priv -> vp8_cfg , mr_cfg ) ; priv -> cpi = vp8_create_compressor ( & priv -> oxcf ) ; if ( ! priv -> cpi ) res = VPX_CODEC_MEM_ERROR ; <S2SV_ModEnd> } } return res ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) shared_mem_loc ; res = VPX_CODEC_OK ; } # else ( void ) cfg ; ( void ) mem_loc ; #
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_active_map_t * data =
<S2SV_ModStart> * cfg ) { vpx_codec_err_t res ; if ( <S2SV_ModEnd> cfg -> g_w != ctx -> cfg . g_w <S2SV_ModStart> cfg -> g_w != ctx -> cfg . g_w || <S2SV_ModEnd> cfg -> g_h != ctx -> cfg . g_h <S2SV_ModStart> -> g_h != ctx -> cfg . g_h ) { if <S2SV_ModEnd> ( cfg -> g_lag_in_frames > 1 || cfg -> <S2SV_ModStart> > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( "Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization" ) ; if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( "Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values" ) ; } <S2SV_ModEnd> if ( ( cfg -> g_lag_in_frames > ctx ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t <S2SV_ModStart> data = va_arg ( args , vp8_postproc_cfg_t * ) <S2SV_ModEnd> ; if ( data ) { ctx -> preview_ppcfg <S2SV_ModStart> else ( void ) ctx ; ( void ) <S2SV_ModEnd> args ; return VPX_CODEC_INCAPABLE ; # endif } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * data =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_roi_map_t * data =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_scaling_mode_t * data =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int update = va_arg
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int update = va_arg
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int reference_flag = va_arg
<S2SV_ModStart> vpx_image_t * img , YV12_BUFFER_CONFIG * yv12 ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> planes [ VPX_PLANE_V ] ; yv12 -> y_crop_width = y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h <S2SV_ModEnd> ; yv12 -> y_stride = img -> stride [
<S2SV_ModStart> ctx -> fragments . count == 0 ) { memset <S2SV_ModEnd> ( ( void * ) ctx -> fragments . <S2SV_ModStart> ( ctx -> fragments . ptrs ) ) ; memset <S2SV_ModEnd> ( ctx -> fragments . sizes , 0 , <S2SV_ModStart> } if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( ! ctx -> fragments . enabled
<S2SV_ModStart> ; unsigned int w , h ; if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( <S2SV_ModStart> resolution_change = 1 ; if ( ! res && ! ctx -> decoder_init <S2SV_ModEnd> ) { VP8D_CONFIG oxcf ; oxcf . Width = <S2SV_ModStart> -> yv12_frame_buffers , & oxcf ) ; ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> <S2SV_ModStart> [ 0 ] -> decrypt_state = ctx -> decrypt_state <S2SV_ModEnd> ; } if ( ! res ) { VP8D_COMP <S2SV_ModStart> -> common . error . setjmp = 0 ; vp8_clear_system_state ( ) ;
<S2SV_ModStart> static vpx_codec_err_t vp8_destroy ( vpx_codec_alg_priv_t * ctx ) { vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ; vpx_free ( ctx ) ; <S2SV_ModEnd> return VPX_CODEC_OK ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * corrupted = <S2SV_ModStart> ] ; if ( corrupted && pbi ) { const YV12_BUFFER_CONFIG * const frame = pbi -> common . frame_to_show ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame <S2SV_ModEnd> -> corrupted ; return VPX_CODEC_OK ; } else return
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * ref_info =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * update_info =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * data =
<S2SV_ModStart> * data ) { vpx_codec_err_t res = VPX_CODEC_OK ; vpx_codec_alg_priv_t * priv = NULL ; ( void ) data ; vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd <S2SV_ModEnd> ( ) ; if ( ! ctx -> priv <S2SV_ModStart> ; if ( ! ctx -> priv ) { vp8_init_ctx ( ctx ) ; priv = ( vpx_codec_alg_priv_t * ) ctx -> priv ; priv -> fragments . count = 0 ; priv -> fragments . enabled = ( priv -> base . init_flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) ; } else { priv = ( vpx_codec_alg_priv_t * ) ctx -> priv ; } priv <S2SV_ModEnd> -> yv12_frame_buffers . use_frame_threads = ( ctx -> priv <S2SV_ModStart> yv12_frame_buffers . use_frame_threads = ( ctx -> priv -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ; priv <S2SV_ModEnd> -> yv12_frame_buffers . use_frame_threads = 0 ; if ( <S2SV_ModStart> -> yv12_frame_buffers . use_frame_threads = 0 ; if ( priv <S2SV_ModEnd> -> yv12_frame_buffers . use_frame_threads && ( ( ctx -> <S2SV_ModStart> . use_frame_threads && ( ( ctx -> priv -> <S2SV_ModEnd> init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) || ( ctx -> priv <S2SV_ModStart> & VPX_CODEC_USE_ERROR_CONCEALMENT ) || ( ctx -> priv -> <S2SV_ModEnd> init_flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) ) ) { res =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void vp8_init_ctx ( vpx_codec_ctx_t * ctx ) { vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) ; ctx -> priv = ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> ; ctx -> priv -> init_flags = ctx -> <S2SV_ModStart> -> priv -> init_flags = ctx -> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> decrypt_cb = NULL ; priv -> decrypt_state = NULL ; <S2SV_ModStart> if ( ctx -> config . dec ) { priv <S2SV_ModEnd> -> cfg = * ctx -> config . dec <S2SV_ModStart> dec ; ctx -> config . dec = & priv <S2SV_ModEnd> -> cfg ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void * decrypt_state ) { vpx_codec_err_t res <S2SV_ModStart> ; if ( decrypt_cb ) { int n = MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> ; decrypt_cb ( decrypt_state , data , clear_buffer , <S2SV_ModStart> 0x01 || clear [ 5 ] != 0x2a ) return <S2SV_ModEnd> VPX_CODEC_UNSUP_BITSTREAM ; si -> w = ( clear [
<S2SV_ModStart> vpx_codec_flags_t flags ) { ( void ) si ; ( void ) flags ;
<S2SV_ModStart> <S2SV_null> static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , va_list args ) { vpx_decrypt_init * init = va_arg ( args , vpx_decrypt_init <S2SV_ModEnd> * ) ; if ( init ) { ctx
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t <S2SV_ModStart> VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * data =
<S2SV_ModStart> VPX_PLANE_ALPHA ] = yv12 -> y_stride ; img -> bit_depth = 8 ; img ->
<S2SV_ModStart> <S2SV_null> void vp9_remove_common ( VP9_COMMON * cm ) { vp9_free_context_buffers ( cm ) ; vpx_free ( cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_above_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO
<S2SV_ModStart> ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane ,
<S2SV_ModStart> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd <S2SV_ModStart> << ( tx_size << 1 ) ; int i = 0 , r , c ; const int max_blocks_wide = num_4x4_w + ( xd -> mb_to_right_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_right_edge >> ( 5 + pd -> <S2SV_ModStart> ( 5 + pd -> subsampling_x ) ) ; const int max_blocks_high = num_4x4_h + ( xd -> mb_to_bottom_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_bottom_edge >> ( 5 + pd -> <S2SV_ModStart> ( 5 + pd -> subsampling_y ) ) ; const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> ; for ( r = 0 ; r < <S2SV_ModStart> ; for ( r = 0 ; r < max_blocks_high <S2SV_ModEnd> ; r += ( 1 << tx_size ) ) <S2SV_ModStart> { for ( c = 0 ; c < max_blocks_wide <S2SV_ModEnd> ; c += ( 1 << tx_size ) ) <S2SV_ModStart> c += ( 1 << tx_size ) ) { <S2SV_ModEnd> visit ( plane , i , plane_bsize , tx_size <S2SV_ModStart> , arg ) ; i += step ; } i += extra_step <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO
<S2SV_ModStart> [ i ] = 0 ; } else { memset <S2SV_ModEnd> ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) <S2SV_ModStart> [ i ] = 0 ; } else { memset <S2SV_ModEnd> ( l , has_eob , sizeof ( ENTROPY_CONTEXT )
<S2SV_ModStart> subsampling_y = i ? ss_y : 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * descriptor , size_t member_offset ) { int mi_row , mi_col ; MODE_INFO * * mi <S2SV_ModEnd> = cm -> mi_grid_visible ; int rows = cm <S2SV_ModStart> ; log_frame_info ( cm , descriptor , file ) <S2SV_ModEnd> ; for ( mi_row = 0 ; mi_row < <S2SV_ModStart> * ) ( ( char * ) ( & mi [ 0 <S2SV_ModEnd> ] -> mbmi ) + member_offset ) ) ) <S2SV_ModStart> -> mbmi ) + member_offset ) ) ) ; mi <S2SV_ModEnd> ++ ; } fprintf ( file , "\\n" ) <S2SV_ModStart> ; } fprintf ( file , "\\n" ) ; mi <S2SV_ModEnd> += 8 ; } fprintf ( file , "\\n"
<S2SV_ModStart> ; vp9_coeff_probs_model * const probs = cm -> fc -> <S2SV_ModEnd> coef_probs [ tx_size ] ; const vp9_coeff_probs_model * const
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void extend_to_full_distribution ( vpx_prob * probs , vpx_prob p ) { memcpy <S2SV_ModEnd> ( probs , vp9_pareto8_full [ p = 0 ? <S2SV_ModStart> p - 1 ] , MODEL_NODES * sizeof ( vpx_prob <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cm ) { vp9_copy ( cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; vp9_copy <S2SV_ModStart> , default_coef_probs_4x4 ) ; vp9_copy ( cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; vp9_copy <S2SV_ModStart> , default_coef_probs_8x8 ) ; vp9_copy ( cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; vp9_copy <S2SV_ModStart> , default_coef_probs_16x16 ) ; vp9_copy ( cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_model_to_full_probs ( const vpx_prob * model , vpx_prob <S2SV_ModEnd> * full ) { if ( full != model <S2SV_ModStart> full ) { if ( full != model ) memcpy ( full , model , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES ) ; extend_to_full_distribution ( & full
<S2SV_ModStart> int i , j ; FRAME_CONTEXT * fc = <S2SV_ModEnd> cm -> fc ; const FRAME_CONTEXT * pre_fc = <S2SV_ModStart> ++ ) fc -> intra_inter_prob [ i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> intra_inter_prob [ i ] , counts <S2SV_ModStart> ++ ) fc -> comp_inter_prob [ i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> comp_inter_prob [ i ] , counts <S2SV_ModStart> ++ ) fc -> comp_ref_prob [ i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> comp_ref_prob [ i ] , counts <S2SV_ModStart> -> single_ref_prob [ i ] [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> single_ref_prob [ i ] [ j <S2SV_ModStart> 0 ; i < INTER_MODE_CONTEXTS ; i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] <S2SV_ModStart> 0 ; i < BLOCK_SIZE_GROUPS ; i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] <S2SV_ModStart> 0 ; i < INTRA_MODES ; ++ i ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] <S2SV_ModStart> 0 ; i < PARTITION_CONTEXTS ; i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_partition_tree , pre_fc -> partition_prob [ i ] <S2SV_ModStart> 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] <S2SV_ModStart> . p8x8 [ i ] [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> tx_probs . p8x8 [ i ] <S2SV_ModStart> . p16x16 [ i ] [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> tx_probs . p16x16 [ i ] <S2SV_ModStart> . p32x32 [ i ] [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> tx_probs . p32x32 [ i ] <S2SV_ModStart> i ) fc -> skip_probs [ i ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc -> skip_probs [ i ] , counts
<S2SV_ModStart> ; nmv_context * fc = & cm -> fc -> <S2SV_ModEnd> nmvc ; const nmv_context * pre_fc = & cm <S2SV_ModStart> counts = & cm -> counts . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , pre_fc -> joints , counts -> <S2SV_ModStart> comps [ i ] ; comp -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> sign , c -> sign ) <S2SV_ModStart> pre_comp -> sign , c -> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , pre_comp -> classes , c -> <S2SV_ModStart> c -> classes , comp -> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , pre_comp -> class0 , c -> <S2SV_ModStart> j ) comp -> bits [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> bits [ j ] , c <S2SV_ModStart> 0 ; j < CLASS0_SIZE ; ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] <S2SV_ModStart> , comp -> class0_fp [ j ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , pre_comp -> fp , c -> <S2SV_ModStart> if ( allow_hp ) { comp -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> class0_hp , c -> class0_hp ) <S2SV_ModStart> c -> class0_hp ) ; comp -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> hp , c -> hp )
<S2SV_ModStart> ( VP9_COMMON * cm ) { cm -> fc -> <S2SV_ModEnd> nmvc = default_nmv_context ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> i ] . data ) return - 1 ; memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_idct16x16_add ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> eob ) { if ( eob == 1 ) vpx_idct16x16_1_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ) ; else if ( eob <= 10 ) vpx_idct16x16_10_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ( input , dest , stride ) ; else vpx_idct16x16_256_add <S2SV_ModEnd> ( input , dest , stride ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_idct32x32_add ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> eob ) { if ( eob == 1 ) vpx_idct32x32_1_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ) ; else if ( eob <= 34 ) vpx_idct32x32_34_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ( input , dest , stride ) ; else vpx_idct32x32_1024_add <S2SV_ModEnd> ( input , dest , stride ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_idct4x4_add ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> eob ) { if ( eob > 1 ) vpx_idct4x4_16_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ( input , dest , stride ) ; else vpx_idct4x4_1_add <S2SV_ModEnd> ( input , dest , stride ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_idct8x8_add ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> eob ) { if ( eob == 1 ) vpx_idct8x8_1_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> , stride ) ; else if ( eob <= 12 ) vpx_idct8x8_12_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ( input , dest , stride ) ; else vpx_idct8x8_64_add <S2SV_ModEnd> ( input , dest , stride ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_iht16x16_256_add_c ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> int tx_type ) { int i , j ; tran_low_t out [ 16 * 16 ] ; tran_low_t * outptr = out ; tran_low_t <S2SV_ModEnd> temp_in [ 16 ] , temp_out [ 16 ] <S2SV_ModStart> 0 ; j < 16 ; ++ j ) { <S2SV_ModStart> dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , <S2SV_ModEnd> ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) <S2SV_ModStart> ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_iht4x4_16_add_c ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> { const transform_2d IHT_4 [ ] = { { idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c } } ; int i , j ; tran_low_t out [ 4 * 4 ] ; tran_low_t * outptr = out ; tran_low_t <S2SV_ModEnd> temp_in [ 4 ] , temp_out [ 4 ] <S2SV_ModStart> 0 ; j < 4 ; ++ j ) { <S2SV_ModStart> dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; } <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> void vp9_iht4x4_add ( TX_TYPE tx_type , const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_iht8x8_64_add_c ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> int tx_type ) { int i , j ; tran_low_t out [ 8 * 8 ] ; tran_low_t * outptr = out ; tran_low_t <S2SV_ModEnd> temp_in [ 8 ] , temp_out [ 8 ] <S2SV_ModStart> 0 ; j < 8 ; ++ j ) { <S2SV_ModStart> dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , <S2SV_ModEnd> ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <S2SV_ModStart> ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_iwht4x4_add ( const tran_low_t <S2SV_ModEnd> * input , uint8_t * dest , int stride <S2SV_ModStart> eob ) { if ( eob > 1 ) vpx_iwht4x4_16_add <S2SV_ModEnd> ( input , dest , stride ) ; else <S2SV_ModStart> ( input , dest , stride ) ; else vpx_iwht4x4_1_add <S2SV_ModEnd> ( input , dest , stride ) ; }
<S2SV_ModStart> = mbmi -> tx_size ; const TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> ) ; const int filter_level = get_filter_level ( lfi_n <S2SV_ModStart> ; i < h ; i ++ ) { memset <S2SV_ModEnd> ( & lfm -> lfl_y [ index ] , <S2SV_ModStart> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) << shift_y ; if ( tx_size_uv == TX_4X4
<S2SV_ModStart> ; i < h ; i ++ ) { memset <S2SV_ModEnd> ( & lfm -> lfl_y [ index ] , <S2SV_ModStart> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) << shift_y ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( mask_16x16 & 3 ) == 3 ) { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> ) ; count = 2 ; } else { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> lfthr + * ( lfl + 1 ) ; vpx_lpf_horizontal_8_dual <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> ( mask_4x4_int & 3 ) == 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 4 * pitch , pitch , <S2SV_ModStart> ) ; else if ( mask_4x4_int & 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 8 + 4 * pitch , <S2SV_ModStart> ; } count = 2 ; } else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 4 * pitch , pitch , <S2SV_ModStart> lfthr + * ( lfl + 1 ) ; vpx_lpf_horizontal_4_dual <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> ( mask_4x4_int & 3 ) == 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 4 * pitch , pitch , <S2SV_ModStart> ) ; else if ( mask_4x4_int & 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 8 + 4 * pitch , <S2SV_ModStart> ; } count = 2 ; } else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s + 4 * pitch , pitch ,
<S2SV_ModStart> ) { if ( mask_16x16 & 1 ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> } else if ( mask_8x8 & 1 ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s , pitch , lfi -> mblim , <S2SV_ModStart> } else if ( mask_4x4 & 1 ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ( s + 4 , pitch , lfi ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void filter_selectively_vert_row2 ( int subsampling_factor <S2SV_ModEnd> , uint8_t * s , int pitch , unsigned <S2SV_ModStart> uint8_t * lfl ) { const int mask_shift = subsampling_factor <S2SV_ModEnd> ? 4 : 8 ; const int mask_cutoff = <S2SV_ModStart> ? 4 : 8 ; const int mask_cutoff = subsampling_factor <S2SV_ModEnd> ? 0xf : 0xff ; const int lfl_forward = <S2SV_ModStart> ? 0xf : 0xff ; const int lfl_forward = subsampling_factor <S2SV_ModEnd> ? 4 : 8 ; unsigned int mask_16x16_0 = <S2SV_ModStart> ( mask_16x16_0 & mask_16x16_1 ) & 1 ) { vpx_lpf_vertical_16_dual <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> } else if ( mask_16x16_0 & 1 ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> , lfi0 -> hev_thr ) ; } else { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s + 8 * pitch , pitch , <S2SV_ModStart> ( mask_8x8_0 & mask_8x8_1 ) & 1 ) { vpx_lpf_vertical_8_dual <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> } else if ( mask_8x8_0 & 1 ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> -> hev_thr , 1 ) ; } else { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s + 8 * pitch , pitch , <S2SV_ModStart> ( mask_4x4_0 & mask_4x4_1 ) & 1 ) { vpx_lpf_vertical_4_dual <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> } else if ( mask_4x4_0 & 1 ) { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s , pitch , lfi0 -> mblim , <S2SV_ModStart> -> hev_thr , 1 ) ; } else { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s + 8 * pitch , pitch , <S2SV_ModStart> ( mask_4x4_int_0 & mask_4x4_int_1 ) & 1 ) { vpx_lpf_vertical_4_dual <S2SV_ModEnd> ( s + 4 , pitch , lfi0 -> <S2SV_ModStart> } else if ( mask_4x4_int_0 & 1 ) { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s + 4 , pitch , lfi0 -> <S2SV_ModStart> -> hev_thr , 1 ) ; } else { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s + 8 * pitch + 4 ,
<S2SV_ModStart> ( block_inside_limit < 1 ) block_inside_limit = 1 ; memset <S2SV_ModEnd> ( lfi -> lfthr [ lvl ] . lim <S2SV_ModStart> ] . lim , block_inside_limit , SIMD_WIDTH ) ; memset <S2SV_ModEnd> ( lfi -> lfthr [ lvl ] . mblim
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; vp9_loop_filter_rows ( frame , cm , xd -> plane <S2SV_ModEnd> , start_mi_row , end_mi_row , y_only ) ; }
<S2SV_ModStart> ) { int lvl_seg = default_filt_lvl ; if ( segfeature_active <S2SV_ModEnd> ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_ModStart> , SEG_LVL_ALT_LF ) ) { const int data = get_segdata <S2SV_ModEnd> ( seg , seg_id , SEG_LVL_ALT_LF ) ; lvl_seg <S2SV_ModStart> } if ( ! lf -> mode_ref_delta_enabled ) { memset <S2SV_ModEnd> ( lfi -> lvl [ seg_id ] , lvl_seg
<S2SV_ModStart> 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) memset <S2SV_ModEnd> ( lfi -> lfthr [ lvl ] . hev_thr
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_loop_filter_rows ( YV12_BUFFER_CONFIG * frame_buffer , VP9_COMMON * cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , int start , int stop , int y_only <S2SV_ModStart> int num_planes = y_only ? 1 : MAX_MB_PLANE ; enum lf_path path ; LOOP_FILTER_MASK lfm ; int mi_row , mi_col ; if ( y_only ) path = LF_PATH_444 ; else if ( planes [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) path = LF_PATH_420 ; else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ; else path = LF_PATH_SLOW <S2SV_ModEnd> ; for ( mi_row = start ; mi_row < <S2SV_ModStart> ; mi_row += MI_BLOCK_SIZE ) { MODE_INFO * * mi <S2SV_ModEnd> = cm -> mi_grid_visible + mi_row * cm -> <S2SV_ModStart> += MI_BLOCK_SIZE ) { int plane ; vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ; vp9_setup_mask ( cm , mi_row , mi_col , mi <S2SV_ModEnd> + mi_col , cm -> mi_stride , & lfm <S2SV_ModStart> , cm -> mi_stride , & lfm ) ; vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ; for ( plane = 1 <S2SV_ModEnd> ; plane < num_planes ; ++ plane ) { <S2SV_ModStart> ; plane < num_planes ; ++ plane ) { switch ( path ) { case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , mi_row , mi_col ) ; break ; } <S2SV_ModEnd> } } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> mi_row , const int mi_col , MODE_INFO * * mi <S2SV_ModEnd> , const int mode_info_stride , LOOP_FILTER_MASK * lfm ) <S2SV_ModStart> cm -> lf_info ; MODE_INFO * * mip = mi ; MODE_INFO * * mip2 = mi <S2SV_ModEnd> ; const int offset_32 [ ] = { 4 <S2SV_ModStart> mi_col : MI_BLOCK_SIZE ) ; vp9_zero ( * lfm ) ; assert ( mip [ 0 ] != NULL <S2SV_ModStart> 1 << columns ) - 1 ) ) * 0x0101010101010101ULL <S2SV_ModEnd> ; const uint16_t mask_uv = ( ( 1 << <S2SV_ModStart> ) { lfm -> left_y [ i ] &= 0xfefefefefefefefeULL <S2SV_ModEnd> ; lfm -> left_uv [ i ] &= 0xeeee
<S2SV_ModStart> <S2SV_null> int16_t vp9_ac_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return ac_qlookup [ clamp ( qindex + delta , <S2SV_ModStart> + delta , 0 , MAXQ ) ] ; case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> <S2SV_null> int16_t vp9_dc_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return dc_qlookup [ clamp ( qindex + delta , <S2SV_ModStart> + delta , 0 , MAXQ ) ] ; case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> int segment_id , int base_qindex ) { if ( segfeature_active <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_ALT_Q ) ) { <S2SV_ModStart> , SEG_LVL_ALT_Q ) ) { const int data = get_segdata <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_ALT_Q ) ; const
<S2SV_ModStart> -> mbmi ) ; const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ] <S2SV_ModEnd> ; int ref ; for ( ref = 0 <S2SV_ModStart> = mi -> mbmi . sb_type < BLOCK_8X8 ? average_split_mvs ( pd , mi , ref , block <S2SV_ModEnd> ) : mi -> mbmi . mv [ ref <S2SV_ModStart> int xs , ys , subpel_x , subpel_y ; const int is_scaled = vp9_is_scaled ( sf ) ; if ( is_scaled <S2SV_ModEnd> ) { pre = pre_buf -> buf + scaled_buffer_offset <S2SV_ModStart> + ( scaled_mv . col >> SUBPEL_BITS ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ; } else { <S2SV_ModStart> ref , kernel , xs , ys ) ; } # else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , const YV12_BUFFER_CONFIG * src , int mi_row , <S2SV_ModStart> int mi_col ) { uint8_t * const buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = { src -> y_buffer , src -> <S2SV_ModStart> y_buffer , src -> u_buffer , src -> v_buffer } ; const int strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = { src -> y_stride , src -> <S2SV_ModStart> y_stride , src -> uv_stride , src -> uv_stride <S2SV_ModEnd> } ; int i ; for ( i = <S2SV_ModStart> ) { struct macroblockd_plane * const pd = & planes <S2SV_ModEnd> [ i ] ; setup_pred_plane ( & pd ->
<S2SV_ModStart> ref_stride , uint8_t * dst , int dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , TX_SIZE tx_size , int up_available , int <S2SV_ModStart> y , int plane ) { int i ; DECLARE_ALIGNED ( 16 , uint8_t , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; uint8_t * above_row = above_data + 16 <S2SV_ModStart> = & xd -> plane [ plane ] ; <S2SV_ModEnd> if ( plane == 0 ) { frame_width = <S2SV_ModStart> + pd -> subsampling_y ) ) + y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( left_available ) { if ( xd -> <S2SV_ModStart> i * ref_stride - 1 ] ; } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> mb_to_right_edge < 0 ) { if ( x0 + bs <= frame_width ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width ) { const int r = frame_width <S2SV_ModStart> { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else { if ( bs == 4 && <S2SV_ModStart> ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ - 1 ] = left_available ? above_ref <S2SV_ModStart> above_ref [ - 1 ] : 129 ; } else { memset <S2SV_ModEnd> ( above_row , 127 , bs * 2 ) <S2SV_ModStart> ; above_row [ - 1 ] = 127 ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rtcd ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> other_h , int this_w , int this_h ) { # endif if ( ! valid_ref_frame_size <S2SV_ModEnd> ( other_w , other_h , this_w , this_h ) <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> ; } else { sf -> predict [ 0 <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> ; } } else { if ( sf -> <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> ; } else { sf -> predict [ 0 <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> min_log2_tile_cols , int * max_log2_tile_cols ) { const int sb64_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; * min_log2_tile_cols = get_min_log2_tile_cols ( sb64_cols ) ; * max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> cm , int row , int col ) { vp9_tile_set_row ( tile , cm , row ) ; vp9_tile_set_col ( tile , cm , col <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> buf2 = ( const TileBuffer * ) b ; return ( int ) ( buf2 -> size - buf1 -> size ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> VP9_COMMON * const cm = & pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> << 6 ] ; int tile_row , tile_col ; int mi_row , mi_col ; TileData * tile_data = NULL ; if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <S2SV_ModEnd> assert ( tile_rows <= 4 ) ; assert ( <S2SV_ModStart> tile_cols <= ( 1 << 6 ) ) ; memset <S2SV_ModEnd> ( cm -> above_context , 0 , sizeof ( <S2SV_ModStart> ) * MAX_MB_PLANE * 2 * aligned_cols ) ; memset <S2SV_ModEnd> ( cm -> above_seg_context , 0 , sizeof ( <S2SV_ModStart> * cm -> above_seg_context ) * aligned_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <S2SV_ModStart> tile_col < tile_cols ; ++ tile_col ) { const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * tile_rows - 1 ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const cm = & pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; const <S2SV_ModStart> ; const int num_workers = MIN ( pbi -> <S2SV_ModEnd> max_threads & ~ 1 , tile_cols ) ; TileBuffer <S2SV_ModStart> 1 , tile_cols ) ; TileBuffer tile_buffers [ 1 ] [ 1 <S2SV_ModStart> 0 ) { const int num_threads = pbi -> <S2SV_ModEnd> max_threads & ~ 1 ; int i ; CHECK_MEM_ERROR <S2SV_ModStart> ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> ; i < num_threads ; ++ i ) { VPxWorker <S2SV_ModEnd> * const worker = & pbi -> tile_workers [ <S2SV_ModStart> [ i ] ; ++ pbi -> num_tile_workers ; winterface -> init ( worker <S2SV_ModEnd> ) ; if ( i < num_threads - 1 <S2SV_ModStart> if ( i < num_threads - 1 && ! winterface -> reset <S2SV_ModEnd> ( worker ) ) { vpx_internal_error ( & cm <S2SV_ModStart> ; n < num_workers ; ++ n ) { VPxWorker * const worker = & pbi -> tile_workers [ n ] ; winterface -> sync ( worker ) ; worker -> hook = ( VPxWorkerHook ) tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> ( cm -> above_context , 0 , sizeof ( <S2SV_ModStart> ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; memset <S2SV_ModEnd> ( cm -> above_seg_context , 0 , sizeof ( <S2SV_ModStart> * cm -> above_seg_context ) * aligned_mi_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] <S2SV_ModEnd> [ 0 ] ) , compare_tile_buffers ) ; { <S2SV_ModStart> < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] <S2SV_ModStart> , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] <S2SV_ModEnd> + group_start + 1 , ( group_end - group_start <S2SV_ModStart> group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] <S2SV_ModEnd> [ group_end ] = largest ; group_start = group_end <S2SV_ModStart> ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) <S2SV_ModStart> && n < tile_cols ; ++ i ) { VPxWorker <S2SV_ModEnd> * const worker = & pbi -> tile_workers [ <S2SV_ModStart> ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi <S2SV_ModEnd> ; tile_data -> xd = pbi -> mb ; <S2SV_ModStart> ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> <S2SV_ModEnd> dqcoeff ) ; worker -> had_error = 0 ; <S2SV_ModStart> 1 || n == tile_cols - 1 ) { winterface -> execute ( worker ) ; } else { winterface -> launch <S2SV_ModEnd> ( worker ) ; } if ( buf -> <S2SV_ModStart> ; i > 0 ; -- i ) { VPxWorker <S2SV_ModEnd> * const worker = & pbi -> tile_workers [ <S2SV_ModStart> ] ; pbi -> mb . corrupted |= ! winterface -> sync <S2SV_ModEnd> ( worker ) ; } if ( final_worker > <S2SV_ModStart> tile_workers [ final_worker ] . data1 ; bit_reader_end = vpx_reader_find_end <S2SV_ModEnd> ( & tile_data -> bit_reader ) ; final_worker = <S2SV_ModStart> -> bit_reader ) ; final_worker = - 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_unsigned_max ( struct vpx_read_bit_buffer <S2SV_ModEnd> * rb , int max ) { const int <S2SV_ModStart> , int max ) { const int data = vpx_rb_read_literal <S2SV_ModEnd> ( rb , get_unsigned_bits ( max ) ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) { struct <S2SV_ModEnd> macroblockd_plane * const pd = & xd -> plane <S2SV_ModStart> = & xd -> plane [ plane ] ; PREDICTION_MODE mode = ( plane == 0 ) ? mbmi -> mode : mbmi -> uv_mode ; uint8_t * dst ; <S2SV_ModEnd> dst = & pd -> dst . buf [ <S2SV_ModStart> & pd -> dst . buf [ 4 * row <S2SV_ModEnd> * pd -> dst . stride + 4 * <S2SV_ModStart> * pd -> dst . stride + 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row << 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row , plane ) ; if ( ! mbmi -> skip ) { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const int eob = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type <S2SV_ModEnd> , tx_size , dst , pd -> dst .
<S2SV_ModStart> pbi -> mb ; FRAME_CONTEXT * const fc = cm -> fc ; vpx_reader r ; int k ; if ( vpx_reader_init ( & r , data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModEnd> ) ) vpx_internal_error ( & cm -> error , <S2SV_ModStart> -> allow_high_precision_mv , & r ) ; } return vpx_reader_has_error <S2SV_ModEnd> ( & r ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , vpx_reader <S2SV_ModEnd> * r ) { if ( is_compound_reference_allowed ( cm <S2SV_ModStart> if ( is_compound_reference_allowed ( cm ) ) { return vpx_read_bit ( r ) ? ( vpx_read_bit <S2SV_ModEnd> ( r ) ? REFERENCE_MODE_SELECT : COMPOUND_REFERENCE ) :
<S2SV_ModStart> <S2SV_null> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vpx_reader <S2SV_ModEnd> * r ) { FRAME_CONTEXT * const fc = <S2SV_ModStart> * r ) { FRAME_CONTEXT * const fc = <S2SV_ModEnd> cm -> fc ; int i ; if (
<S2SV_ModStart> <S2SV_null> static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vpx_reader <S2SV_ModEnd> * r ) { int i , j ;
<S2SV_ModStart> read_mv_probs ( nmv_context * ctx , int allow_hp , vpx_reader <S2SV_ModEnd> * r ) { int i , j ;
<S2SV_ModStart> <S2SV_null> static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vpx_reader <S2SV_ModEnd> * r ) { int i , j ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static TX_MODE read_tx_mode ( vpx_reader * r ) { TX_MODE tx_mode = vpx_read_literal <S2SV_ModEnd> ( r , 2 ) ; if ( tx_mode <S2SV_ModStart> ; if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit <S2SV_ModEnd> ( r ) ; return tx_mode ; } <S2SV_null>
<S2SV_ModStart> static void read_tx_mode_probs ( struct tx_probs * tx_probs , vpx_reader <S2SV_ModEnd> * r ) { int i , j ;
<S2SV_ModStart> static size_t read_uncompressed_header ( VP9Decoder * pbi , struct vpx_read_bit_buffer <S2SV_ModEnd> * rb ) { VP9_COMMON * const cm = <S2SV_ModStart> * const cm = & pbi -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; size_t sz ; cm -> last_frame_type = cm -> frame_type ; cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> ( rb , 2 ) != VP9_FRAME_MARKER ) vpx_internal_error <S2SV_ModStart> VPX_CODEC_UNSUP_BITSTREAM , "Invalid<S2SV_blank>frame<S2SV_blank>marker" ) ; cm -> profile = vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error <S2SV_ModStart> cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; # endif cm -> show_existing_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) ; if ( cm -> show_existing_frame <S2SV_ModStart> { const int frame_to_show = cm -> ref_frame_map [ vpx_rb_read_literal ( rb , 3 ) ] ; lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> frame_bufs [ frame_to_show ] . ref_count < 1 ) <S2SV_ModStart> frame_bufs [ frame_to_show ] . ref_count < 1 ) { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> error , VPX_CODEC_UNSUP_BITSTREAM , "Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame" , frame_to_show ) ; } ref_cnt_fb ( frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; unlock_buffer_pool ( pool <S2SV_ModEnd> ) ; pbi -> refresh_frame_flags = 0 ; cm <S2SV_ModStart> = 0 ; cm -> show_frame = 1 ; if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> ; } cm -> frame_type = ( FRAME_TYPE ) vpx_rb_read_bit ( rb ) ; cm -> show_frame = vpx_rb_read_bit ( rb ) ; cm -> error_resilient_mode = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) ; if ( cm -> frame_type <S2SV_ModStart> if ( cm -> frame_type == KEY_FRAME ) { if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , <S2SV_ModStart> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) <S2SV_ModStart> cm -> frame_refs [ i ] . idx = INVALID_IDX <S2SV_ModEnd> ; cm -> frame_refs [ i ] . buf <S2SV_ModStart> cm -> frame_refs [ i ] . buf = NULL <S2SV_ModEnd> ; } setup_frame_size ( cm , rb ) ; <S2SV_ModStart> ; } setup_frame_size ( cm , rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> -> intra_only = cm -> show_frame ? 0 : vpx_rb_read_bit <S2SV_ModEnd> ( rb ) ; cm -> reset_frame_context = cm <S2SV_ModStart> -> reset_frame_context = cm -> error_resilient_mode ? 0 : vpx_rb_read_literal <S2SV_ModEnd> ( rb , 2 ) ; if ( cm <S2SV_ModStart> ) ; if ( cm -> intra_only ) { if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } pbi -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , REF_FRAMES ) ; setup_frame_size ( cm <S2SV_ModStart> ) ; setup_frame_size ( cm , rb ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } } else if ( pbi -> need_resync != 1 ) { pbi -> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb , REF_FRAMES ) ; for ( i <S2SV_ModStart> ; ++ i ) { const int ref = vpx_rb_read_literal <S2SV_ModEnd> ( rb , REF_FRAMES_LOG2 ) ; const int idx <S2SV_ModStart> idx = cm -> ref_frame_map [ ref ] ; RefBuffer * const ref_frame = & cm -> frame_refs [ i ] ; ref_frame -> idx = idx ; ref_frame -> buf = & frame_bufs [ idx ] . buf <S2SV_ModEnd> ; cm -> ref_frame_sign_bias [ LAST_FRAME + i ] <S2SV_ModStart> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) ; } setup_frame_size_with_refs ( cm , <S2SV_ModStart> cm , rb ) ; cm -> allow_high_precision_mv = vpx_rb_read_bit <S2SV_ModEnd> ( rb ) ; cm -> interp_filter = read_interp_filter <S2SV_ModStart> = & cm -> frame_refs [ i ] ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> y_crop_height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder" "<S2SV_blank>state" ) ; <S2SV_ModEnd> } if ( ! cm -> error_resilient_mode ) { <S2SV_ModStart> ( ! cm -> error_resilient_mode ) { cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode = 1 ; } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count ; } else { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 1 ; <S2SV_ModEnd> if ( frame_is_intra_only ( cm ) || cm -> <S2SV_ModStart> ( & cm -> seg , rb ) ; setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> setup_tile_info ( cm , rb ) ; sz = vpx_rb_read_literal <S2SV_ModEnd> ( rb , 16 ) ; if ( sz
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int reconstruct_inter_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane * const pd = & xd -> <S2SV_ModStart> = & xd -> plane [ plane ] ; const scan_order * sc = & vp9_default_scan_orders [ tx_size ] ; const int eob = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_inter ( xd , plane <S2SV_ModEnd> , tx_size , & pd -> dst . buf <S2SV_ModStart> & pd -> dst . buf [ 4 * row <S2SV_ModEnd> * pd -> dst . stride + 4 * <S2SV_ModStart> * pd -> dst . stride + 4 * col <S2SV_ModEnd> ] , pd -> dst . stride , eob <S2SV_ModStart> pd -> dst . stride , eob ) ; return <S2SV_ModEnd> eob ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int tile_worker_hook ( TileWorkerData * const tile_data , const TileInfo * const tile ) { int mi_row , mi_col ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info <S2SV_ModEnd> ; for ( mi_row = tile -> mi_row_start ; <S2SV_ModStart> mi_col += MI_BLOCK_SIZE ) { decode_partition ( tile_data -> pbi , & tile_data -> xd <S2SV_ModEnd> , mi_row , mi_col , & tile_data -> bit_reader <S2SV_ModStart> , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void update_mv_probs ( vpx_prob * p , int n , vpx_reader <S2SV_ModEnd> * r ) { int i ; for ( <S2SV_ModStart> i < n ; ++ i ) if ( vpx_read <S2SV_ModEnd> ( r , MV_UPDATE_PROB ) ) p [ i <S2SV_ModStart> MV_UPDATE_PROB ) ) p [ i ] = ( vpx_read_literal <S2SV_ModEnd> ( r , 7 ) << 1 ) |
<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r ) { if ( cm -> reference_mode <S2SV_ModStart> ) ; const REFERENCE_MODE mode = ( REFERENCE_MODE ) vpx_read ( r , cm -> fc -> comp_inter_prob [ ctx ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> comp_inter [ ctx ] [ mode ] ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , int ctx ) { const int <S2SV_ModStart> , int ctx ) { const int mode = vpx_read_tree ( r , vp9_inter_mode_tree , cm -> fc -> inter_mode_probs [ ctx ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> inter_mode [ ctx ] [ mode ] ; return
<S2SV_ModStart> const xd , int mi_row , int mi_col , vpx_reader <S2SV_ModEnd> * r ) { struct segmentation * const seg <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <S2SV_ModEnd> ; if ( ! seg -> enabled ) return <S2SV_ModStart> seg -> enabled ) return 0 ; predicted_segment_id = cm -> last_frame_seg_map ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 ; if ( ! seg -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; return predicted_segment_id ; } if ( seg -> temporal_update ) { const vpx_prob <S2SV_ModEnd> pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_ModStart> seg , xd ) ; mbmi -> seg_id_predicted = vpx_read <S2SV_ModEnd> ( r , pred_prob ) ; segment_id = mbmi <S2SV_ModStart> , seg ) ; } set_segment_id ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id ) ; return segment_id ; } <S2SV_null>
<S2SV_ModStart> const xd , int mi_row , int mi_col , vpx_reader <S2SV_ModEnd> * r ) { MODE_INFO * const mi = <S2SV_ModStart> mbmi ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi <S2SV_ModEnd> ; const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_ModStart> bsize = mbmi -> sb_type ; int i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; mbmi -> segment_id = read_intra_segment_id ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , r ) ; mbmi -> skip = read_skip <S2SV_ModStart> mbmi -> tx_size = read_tx_size ( cm , xd <S2SV_ModEnd> , 1 , r ) ; mbmi -> ref_frame
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static PREDICTION_MODE read_intra_mode ( vpx_reader * r , const vpx_prob * p ) { return ( PREDICTION_MODE ) vpx_read_tree <S2SV_ModEnd> ( r , vp9_intra_mode_tree , p ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , PREDICTION_MODE y_mode ) { const PREDICTION_MODE <S2SV_ModEnd> uv_mode = read_intra_mode ( r , cm -> fc <S2SV_ModStart> uv_mode = read_intra_mode ( r , cm -> fc -> uv_mode_prob [ y_mode ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> uv_mode [ y_mode ] [ uv_mode ] ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , int size_group ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = read_intra_mode ( r , cm -> fc <S2SV_ModStart> y_mode = read_intra_mode ( r , cm -> fc -> y_mode_prob [ size_group ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> y_mode [ size_group ] [ y_mode ] ; return
<S2SV_ModStart> static int read_intra_segment_id ( VP9_COMMON * const cm , int mi_offset , int x_mis , int y_mis , vpx_reader <S2SV_ModEnd> * r ) { struct segmentation * const seg <S2SV_ModStart> segmentation * const seg = & cm -> seg <S2SV_ModEnd> ; int segment_id ; if ( ! seg -> <S2SV_ModStart> 0 ; if ( ! seg -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; return 0 ; } <S2SV_ModEnd> segment_id = read_segment_id ( r , seg ) ; <S2SV_ModStart> r , seg ) ; set_segment_id ( cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id ) ; return segment_id ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE void read_mv ( vpx_reader <S2SV_ModEnd> * r , MV * mv , const MV <S2SV_ModStart> ) { const MV_JOINT_TYPE joint_type = ( MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r , vp9_mv_joint_tree , ctx -> joints )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int read_mv_component ( vpx_reader <S2SV_ModEnd> * r , const nmv_component * mvcomp , int <S2SV_ModStart> , fr , hp ; const int sign = vpx_read <S2SV_ModEnd> ( r , mvcomp -> sign ) ; const <S2SV_ModStart> mvcomp -> sign ) ; const int mv_class = vpx_read_tree <S2SV_ModEnd> ( r , vp9_mv_class_tree , mvcomp -> classes ) <S2SV_ModStart> MV_CLASS_0 ; if ( class0 ) { d = vpx_read_tree <S2SV_ModEnd> ( r , vp9_mv_class0_tree , mvcomp -> class0 ) <S2SV_ModStart> ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ; mag = 0 <S2SV_ModStart> i < n ; ++ i ) d |= vpx_read <S2SV_ModEnd> ( r , mvcomp -> bits [ i ] <S2SV_ModStart> -> bits [ i ] ) << i ; mag = CLASS0_SIZE << ( mv_class + 2 ) ; } fr = vpx_read_tree <S2SV_ModEnd> ( r , vp9_mv_fp_tree , class0 ? mvcomp -> <S2SV_ModStart> mvcomp -> fp ) ; hp = usehp ? vpx_read <S2SV_ModEnd> ( r , class0 ? mvcomp -> class0_hp : <S2SV_ModStart> : mvcomp -> hp ) : 1 ; mag += ( <S2SV_ModEnd> ( d << 3 ) | ( fr <<
<S2SV_ModStart> * const cm , MACROBLOCKD * const xd , vpx_reader <S2SV_ModEnd> * r , int segment_id , MV_REFERENCE_FRAME ref_frame [ <S2SV_ModStart> 2 ] ) { FRAME_CONTEXT * const fc = cm -> fc ; FRAME_COUNTS * counts = xd -> counts ; if ( segfeature_active ( & cm -> <S2SV_ModEnd> seg , segment_id , SEG_LVL_REF_FRAME ) ) { ref_frame <S2SV_ModStart> { ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) get_segdata <S2SV_ModEnd> ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME <S2SV_ModStart> cm , xd ) ; const int bit = vpx_read <S2SV_ModEnd> ( r , fc -> comp_ref_prob [ ctx ] <S2SV_ModStart> -> comp_ref_prob [ ctx ] ) ; if ( counts <S2SV_ModEnd> ) ++ counts -> comp_ref [ ctx ] [ <S2SV_ModStart> vp9_get_pred_context_single_ref_p1 ( xd ) ; const int bit0 = vpx_read <S2SV_ModEnd> ( r , fc -> single_ref_prob [ ctx0 ] <S2SV_ModStart> ctx0 ] [ 0 ] ) ; if ( counts <S2SV_ModEnd> ) ++ counts -> single_ref [ ctx0 ] [ <S2SV_ModStart> vp9_get_pred_context_single_ref_p2 ( xd ) ; const int bit1 = vpx_read <S2SV_ModEnd> ( r , fc -> single_ref_prob [ ctx1 ] <S2SV_ModStart> ctx1 ] [ 1 ] ) ; if ( counts <S2SV_ModEnd> ) ++ counts -> single_ref [ ctx1 ] [
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int read_segment_id ( vpx_reader <S2SV_ModEnd> * r , const struct segmentation * seg ) <S2SV_ModStart> , const struct segmentation * seg ) { return vpx_read_tree <S2SV_ModEnd> ( r , vp9_segment_tree , seg -> tree_probs )
<S2SV_ModStart> cm , MACROBLOCKD * xd , TX_SIZE max_tx_size , vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; const int ctx = get_tx_size_context ( xd ) ; const vpx_prob <S2SV_ModEnd> * tx_probs = get_tx_probs ( max_tx_size , ctx , <S2SV_ModStart> ( max_tx_size , ctx , & cm -> fc -> tx_probs ) ; int tx_size = vpx_read <S2SV_ModEnd> ( r , tx_probs [ 0 ] ) ; <S2SV_ModStart> TX_4X4 && max_tx_size >= TX_16X16 ) { tx_size += vpx_read <S2SV_ModEnd> ( r , tx_probs [ 1 ] ) ; <S2SV_ModStart> != TX_8X8 && max_tx_size >= TX_32X32 ) tx_size += vpx_read <S2SV_ModEnd> ( r , tx_probs [ 2 ] ) ; <S2SV_ModStart> tx_probs [ 2 ] ) ; } if ( counts <S2SV_ModEnd> ) ++ get_tx_counts ( max_tx_size , ctx , & <S2SV_ModStart> ) ++ get_tx_counts ( max_tx_size , ctx , & counts -> <S2SV_ModEnd> tx ) [ tx_size ] ; return ( TX_SIZE
<S2SV_ModStart> , const MACROBLOCKD * xd , int segment_id , vpx_reader * r ) { if ( segfeature_active <S2SV_ModEnd> ( & cm -> seg , segment_id , SEG_LVL_SKIP <S2SV_ModStart> vp9_get_skip_context ( xd ) ; const int skip = vpx_read ( r , cm -> fc -> skip_probs [ ctx ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> skip [ ctx ] [ skip ] ; return
<S2SV_ModStart> ( VP9_COMMON * cm , MACROBLOCKD * xd , int allow_select , vpx_reader * r ) { TX_MODE tx_mode = cm -> tx_mode ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; <S2SV_ModEnd> const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;
<S2SV_ModStart> <S2SV_null> static void set_segment_id ( VP9_COMMON * cm , int mi_offset , int x_mis , int y_mis , int segment_id ) { <S2SV_ModEnd> int x , y ; assert ( segment_id >= <S2SV_ModStart> ; for ( y = 0 ; y < y_mis <S2SV_ModEnd> ; y ++ ) for ( x = 0 <S2SV_ModStart> ) for ( x = 0 ; x < x_mis ; x ++ ) cm -> current_frame_seg_map <S2SV_ModEnd> [ mi_offset + y * cm -> mi_cols +
<S2SV_ModStart> * const cm = & pbi -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModEnd> { const int old_idx = cm -> ref_frame_map [ <S2SV_ModStart> old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ cm -> new_fb_idx ] . ref_count ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> for ( ref_index = 0 ; ref_index < 3 <S2SV_ModStart> cm -> frame_refs [ ref_index ] . idx = - 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> VP9_LAST_FLAG ) { const YV12_BUFFER_CONFIG * const cfg = get_ref_frame ( cm , 0 ) ; if ( cfg == NULL ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "No<S2SV_blank>\'last\'<S2SV_blank>reference<S2SV_blank>frame" ) ; return VPX_CODEC_ERROR ; } <S2SV_ModEnd> if ( ! equal_dimensions ( cfg , sd )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> VP9Decoder * vp9_decoder_create ( BufferPool * const pool ) { VP9Decoder * volatile <S2SV_ModEnd> const pbi = vpx_memalign ( 32 , sizeof ( <S2SV_ModStart> sizeof ( * pbi ) ) ; VP9_COMMON * volatile <S2SV_ModStart> } cm -> error . setjmp = 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> ( & cm -> ref_frame_map , - 1 , <S2SV_ModStart> , sizeof ( cm -> ref_frame_map ) ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; cm -> current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> ( & pbi -> lf_worker ) ; return pbi
<S2SV_ModStart> <S2SV_null> void vp9_decoder_remove ( VP9Decoder * pbi ) { int i ; vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> ( & pbi -> lf_worker ) ; vpx_free ( <S2SV_ModStart> ) ; vpx_free ( pbi -> lf_worker . data1 ) ; vpx_free ( pbi -> tile_data <S2SV_ModStart> < pbi -> num_tile_workers ; ++ i ) { VPxWorker <S2SV_ModEnd> * const worker = & pbi -> tile_workers [ <S2SV_ModStart> = & pbi -> tile_workers [ i ] ; vpx_get_worker_interface ( ) -> end ( worker ) ; } vpx_free ( pbi -> tile_worker_data ) ; vpx_free ( pbi -> tile_worker_info ) ; <S2SV_ModEnd> vpx_free ( pbi -> tile_workers ) ; if ( <S2SV_ModStart> -> tile_workers ) ; if ( pbi -> num_tile_workers > 0 ) { vp9_loop_filter_dealloc ( & pbi -> lf_row_sync <S2SV_ModEnd> ) ; } vpx_free ( pbi ) ; }
<S2SV_ModStart> , size_t size , const uint8_t * * psource ) { VP9_COMMON * volatile const cm = & pbi -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModEnd> ; const uint8_t * source = * psource ; <S2SV_ModStart> ( cm -> frame_refs [ 0 ] . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <S2SV_ModEnd> cm -> frame_refs [ 0 ] . buf -> <S2SV_ModStart> ] . buf -> corrupted = 1 ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && cm -> new_fb_idx >= 0 && <S2SV_ModEnd> frame_bufs [ cm -> new_fb_idx ] . ref_count == <S2SV_ModStart> cm -> new_fb_idx ] . ref_count == 0 ) pool -> release_fb_cb ( pool -> cb_priv , & <S2SV_ModEnd> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) <S2SV_ModStart> new_fb_idx = get_free_fb ( cm ) ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <S2SV_ModStart> ( cm -> error . jmp ) ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; cm -> error . setjmp = 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <S2SV_ModEnd> ; return - 1 ; } cm -> error <S2SV_ModStart> } cm -> error . setjmp = 1 ; <S2SV_ModEnd> vp9_decode_frame ( pbi , source , source + size <S2SV_ModStart> source , source + size , psource ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } cm -> error . setjmp = 0 ; return retcode ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * sd ) { RefBuffer * ref_buf = NULL ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> const int free_fb = get_free_fb ( cm ) ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; -- frame_bufs [ free_fb ] . ref_count ; ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , ref_fb_ptr , free_fb ) ; ref_buf -> <S2SV_ModStart> , free_fb ) ; ref_buf -> buf = & <S2SV_ModEnd> frame_bufs [ * ref_fb_ptr ] . buf ; vp8_yv12_copy_frame
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_coefs ( const MACROBLOCKD * xd , PLANE_TYPE type , tran_low_t <S2SV_ModEnd> * dqcoeff , TX_SIZE tx_size , const int16_t * <S2SV_ModStart> int16_t * scan , const int16_t * nb , vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModEnd> const int max_eob = 16 << ( tx_size << <S2SV_ModStart> 1 ) ; const FRAME_CONTEXT * const fc = xd -> fc <S2SV_ModEnd> ; const int ref = is_inter_block ( & xd <S2SV_ModStart> ; int band , c = 0 ; const vpx_prob <S2SV_ModEnd> ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES <S2SV_ModStart> ] [ type ] [ ref ] ; const vpx_prob <S2SV_ModEnd> * prob ; unsigned int ( * coef_counts ) <S2SV_ModStart> ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] <S2SV_ModEnd> ; unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS <S2SV_ModStart> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; uint8_t token_cache [ 32 * 32 ] <S2SV_ModEnd> ; const uint8_t * band_translate = get_band_translate ( tx_size <S2SV_ModStart> = ( tx_size == TX_32X32 ) ; int v , token <S2SV_ModStart> ; int16_t dqv = dq [ 0 ] ; const uint8_t * cat1_prob ; const uint8_t * cat2_prob ; const uint8_t * cat3_prob ; const uint8_t * cat4_prob ; const uint8_t * cat5_prob ; const uint8_t * cat6_prob ; if ( counts ) { coef_counts = counts -> coef [ tx_size ] [ type ] [ ref ] ; eob_branch_count = counts -> eob_branch [ tx_size ] [ type ] [ ref ] ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> bd > VPX_BITS_8 ) { if ( xd -> bd == VPX_BITS_10 ) { cat1_prob = vp9_cat1_prob_high10 ; cat2_prob = vp9_cat2_prob_high10 ; cat3_prob = vp9_cat3_prob_high10 ; cat4_prob = vp9_cat4_prob_high10 ; cat5_prob = vp9_cat5_prob_high10 ; cat6_prob = vp9_cat6_prob_high10 ; } else { cat1_prob = vp9_cat1_prob_high12 ; cat2_prob = vp9_cat2_prob_high12 ; cat3_prob = vp9_cat3_prob_high12 ; cat4_prob = vp9_cat4_prob_high12 ; cat5_prob = vp9_cat5_prob_high12 ; cat6_prob = vp9_cat6_prob_high12 ; } } else { cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; } # else cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; # endif <S2SV_ModStart> while ( c < max_eob ) { int val = - 1 <S2SV_ModStart> [ band ] [ ctx ] ; if ( counts <S2SV_ModEnd> ) ++ eob_branch_count [ band ] [ ctx ] <S2SV_ModStart> band ] [ ctx ] ; if ( ! vpx_read <S2SV_ModEnd> ( r , prob [ EOB_CONTEXT_NODE ] ) ) <S2SV_ModStart> EOB_MODEL_TOKEN ) ; break ; } while ( ! vpx_read <S2SV_ModEnd> ( r , prob [ ZERO_CONTEXT_NODE ] ) ) <S2SV_ModStart> ] [ ctx ] ; } if ( ! vpx_read <S2SV_ModEnd> ( r , prob [ ONE_CONTEXT_NODE ] ) ) <S2SV_ModStart> ] ) ) { INCREMENT_COUNT ( ONE_TOKEN ) ; token = ONE_TOKEN ; val = 1 ; } else { INCREMENT_COUNT ( TWO_TOKEN ) ; token = vpx_read_tree ( r , vp9_coef_con_tree , <S2SV_ModEnd> vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] <S2SV_ModStart> vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ) ; switch ( token ) { case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ; break ; case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; break ; case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; break ; case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; break ; case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; break ; case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; break ; case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) { case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; break ; case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; break ; case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; break ; default : assert ( 0 ) ; return - 1 ; } # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; # endif break ; } } v = ( val * dqv ) >> dq_shift ; # if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ; # else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; # endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; # endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; ++ c ; ctx = get_coef_context ( nb , token_cache , c ) ; dqv = dq [ 1 ] <S2SV_ModEnd> ; } return c ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_term_subexp ( vpx_reader * r ) { if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 4 ) ; if ( ! <S2SV_ModStart> ( r , 4 ) ; if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 4 ) + 16 ; if <S2SV_ModStart> , 4 ) + 16 ; if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 5 ) + 32 ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_uniform ( vpx_reader <S2SV_ModEnd> * r ) { const int l = 8 <S2SV_ModStart> l ) - 191 ; const int v = vpx_read_literal <S2SV_ModEnd> ( r , l - 1 ) ; return <S2SV_ModStart> : ( v << 1 ) - m + vpx_read_bit <S2SV_ModEnd> ( r ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> > 2 * m ) return v ; return ( v & 1 ) ? m - ( ( v + 1 ) >> 1 ) : m + ( v >> 1 ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int m ) { static int inv_map_table [ MAX_PROB ] = { 7 , 20 , 33 , 46 , 59 , 72 , 85 , 98 , 111 , 124 , 137 , 150 , 163 , 176 , 189 , 202 , 215 , 228 , 241 , 254 , 1 , 2 , 3 , 4 , 5 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 253 } ; assert ( v < ( int ) ( sizeof ( inv_map_table ) / sizeof ( inv_map_table [ 0 ] ) ) <S2SV_ModEnd> ) ; v = inv_map_table [ v ] ; <S2SV_ModStart> MAX_PROB ) { return 1 + inv_recenter_nonneg ( v <S2SV_ModEnd> , m ) ; } else { return MAX_PROB <S2SV_ModStart> } else { return MAX_PROB - inv_recenter_nonneg ( v <S2SV_ModEnd> , MAX_PROB - 1 - m ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_diff_update_prob ( vpx_reader * r , vpx_prob * p ) { if ( vpx_read <S2SV_ModEnd> ( r , DIFF_UPDATE_PROB ) ) { const int <S2SV_ModStart> decode_term_subexp ( r ) ; * p = ( vpx_prob <S2SV_ModEnd> ) inv_remap_prob ( delp , * p ) ;
<S2SV_ModStart> * const seg = & cm -> seg ; vpx_clear_system_state <S2SV_ModEnd> ( ) ; if ( cm -> frame_type == <S2SV_ModStart> rc . is_src_frame_alt_ref ) ) { int segment ; const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <S2SV_ModEnd> qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , <S2SV_ModStart> , cm -> frame_type , cm -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <S2SV_ModEnd> vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; <S2SV_ModStart> segment , SEG_LVL_ALT_Q , qindex_delta ) ; } } }
<S2SV_ModStart> RATE_CONTROL * rc ) { const float factor = 0.25 <S2SV_ModEnd> ; const int number_blocks = cm -> mi_rows * <S2SV_ModStart> * cm -> mi_cols ; if ( rc -> avg_frame_bandwidth <S2SV_ModEnd> < factor * number_blocks || number_blocks / 64 <
<S2SV_ModStart> CYCLIC_REFRESH * cr , const MB_MODE_INFO * mbmi , int64_t rate , int64_t dist , int bsize ) { MV mv = mbmi -> mv [ 0 ] . as_mv ; if ( dist > cr -> thresh_dist_sb && ( mv . row > cr -> motion_thresh || mv . row < - cr -> motion_thresh || mv . col > cr -> motion_thresh || mv . col < - cr -> motion_thresh || ! is_inter_block ( mbmi ) ) ) return CR_SEGMENT_ID_BASE ; else if ( bsize >= BLOCK_16X16 && rate < cr -> thresh_rate_sb && is_inter_block ( mbmi ) && mbmi -> mv [ 0 ] . as_int == 0 && cr -> rate_boost_fac > 10 ) return CR_SEGMENT_ID_BOOST2 ; else return CR_SEGMENT_ID_BOOST1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) { size_t last_coded_q_map_size ; <S2SV_ModStart> vpx_free ( cr ) ; return NULL ; } last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ; cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ; if ( cr -> last_coded_q_map == NULL ) { vpx_free ( cr ) ; return NULL ; } assert ( MAXQ <= 255 ) ; memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ;
<S2SV_ModStart> ( cr -> map ) ; vpx_free ( cr -> last_coded_q_map ) ; vpx_free ( cr
<S2SV_ModStart> * const seg = & cm -> seg ; <S2SV_ModEnd> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc <S2SV_ModStart> int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <S2SV_ModStart> ( cpi -> svc . temporal_layer_id > 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <S2SV_ModEnd> ( seg_map , 0 , cm -> mi_rows * <S2SV_ModStart> ; if ( cm -> frame_type == KEY_FRAME ) { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; cr -> sb_index = 0 ; } <S2SV_ModEnd> return ; } else { int qindex_delta = 0 <S2SV_ModStart> } else { int qindex_delta = 0 ; int qindex2 ; const double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <S2SV_ModEnd> ; qindex2 = clamp ( cm -> base_qindex + <S2SV_ModStart> cpi , qindex2 ) ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q , qindex_delta ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int mi_row , int mi_col , BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip <S2SV_ModEnd> ) { const VP9_COMMON * const cm = & <S2SV_ModStart> int refresh_this_block = candidate_refresh_aq ( cr , mbmi , rate , dist , bsize <S2SV_ModEnd> ) ; int new_map_value = cr -> map [ <S2SV_ModStart> 0 ; int y = 0 ; if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] == 1 ) <S2SV_ModEnd> new_map_value = 0 ; } else { new_map_value = <S2SV_ModStart> ; x < xmis ; x ++ ) { int map_offset = <S2SV_ModEnd> block_index + y * cm -> mi_cols + x <S2SV_ModStart> block_index + y * cm -> mi_cols + x ; cr -> map [ map_offset ] = new_map_value ; cpi -> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> [ bs ] - bottom_overflow ; int avg ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { aq_highbd_8_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , bw , bh , & sse , & avg ) ; sse >>= 2 * ( xd -> bd - 8 ) ; avg >>= ( xd -> bd - 8 ) ; } else { aq_variance <S2SV_ModEnd> ( x -> plane [ 0 ] . src <S2SV_ModStart> bh , & sse , & avg ) ; } # else aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; # endif <S2SV_ModStart> ( bw * bh ) ; } else { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> plane [ 0 ] . src . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , & sse ) ; } else { var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ; } # else var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ; # endif <S2SV_ModEnd> return ( 256 * var ) >> num_pels_log2_lookup [
<S2SV_ModStart> struct segmentation * seg = & cm -> seg <S2SV_ModEnd> ; int i ; if ( cm -> frame_type <S2SV_ModStart> seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vpx_clear_system_state ( ) ; for ( i = 0 ; i < MAX_SEGMENTS ; ++ i ) { int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { continue ; } vp9_set_segdata ( seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q , qindex_delta ) ; vp9_enable_segfeature ( seg <S2SV_ModStart> SEG_LVL_ALT_Q , qindex_delta ) ; vp9_enable_segfeature ( seg , i , SEG_LVL_ALT_Q ) ; <S2SV_ModEnd> } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cpi , TX_SIZE tx_size , vp9_coeff_stats * coef_branch_ct , vp9_coeff_probs_model * coef_probs ) { vp9_coeff_count * coef_counts = cpi -> td . rd_counts . <S2SV_ModEnd> coef_counts [ tx_size ] ; unsigned int ( *
<S2SV_ModStart> void encode_loopfilter ( struct loopfilter * lf , struct vpx_write_bit_buffer * wb ) { int i ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , lf -> filter_level , 6 ) <S2SV_ModStart> wb , lf -> filter_level , 6 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , lf -> sharpness_level , 3 ) <S2SV_ModStart> wb , lf -> sharpness_level , 3 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , lf -> mode_ref_delta_enabled ) ; if <S2SV_ModStart> ) ; if ( lf -> mode_ref_delta_enabled ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , lf -> mode_ref_delta_update ) ; if <S2SV_ModStart> delta != lf -> last_ref_deltas [ i ] ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , changed ) ; if ( changed <S2SV_ModStart> lf -> last_ref_deltas [ i ] = delta ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , abs ( delta ) & 0x3F <S2SV_ModStart> ( delta ) & 0x3F , 6 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , delta < 0 ) ; } <S2SV_ModStart> delta != lf -> last_mode_deltas [ i ] ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , changed ) ; if ( changed <S2SV_ModStart> lf -> last_mode_deltas [ i ] = delta ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , abs ( delta ) & 0x3F <S2SV_ModStart> ( delta ) & 0x3F , 6 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , delta < 0 ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_quantization ( const VP9_COMMON * const cm , struct vpx_write_bit_buffer * wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> base_qindex , QINDEX_BITS )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { int i , j ; <S2SV_ModStart> * wb ) { int i , j ; const struct segmentation * seg = & cm -> seg ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , seg -> enabled ) ; if <S2SV_ModStart> if ( ! seg -> enabled ) return ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , seg -> update_map ) ; if <S2SV_ModStart> if ( seg -> update_map ) { vp9_choose_segmap_coding_method ( cm , xd <S2SV_ModEnd> ) ; for ( i = 0 ; i <S2SV_ModStart> ; const int update = prob != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , prob , 8 ) ; } <S2SV_ModStart> ( wb , prob , 8 ) ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb , seg -> temporal_update ) ; if <S2SV_ModStart> ; const int update = prob != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , prob , 8 ) ; } <S2SV_ModStart> , prob , 8 ) ; } } } vpx_wb_write_bit <S2SV_ModEnd> ( wb , seg -> update_data ) ; if <S2SV_ModStart> ) ; if ( seg -> update_data ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , seg -> abs_delta ) ; for <S2SV_ModStart> ; j ++ ) { const int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , active ) ; if ( active <S2SV_ModStart> if ( active ) { const int data = get_segdata <S2SV_ModEnd> ( seg , i , j ) ; const <S2SV_ModStart> , abs ( data ) , data_max ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , data < 0 ) ; }
<S2SV_ModStart> * const cm = & cpi -> common ; vpx_writer <S2SV_ModEnd> residual_bc ; int tile_row , tile_col ; TOKENEXTRA * <S2SV_ModStart> residual_bc ; int tile_row , tile_col ; TOKENEXTRA * tok_end ; size_t total_size = 0 ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] ; tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ; if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) vpx_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; else vpx_start_encode ( & residual_bc , data_ptr + total_size ) ; write_modes ( cpi , & cpi -> tile_data [ tile_idx ] . tile_info , & residual_bc , & tok , tok_end ) ; assert ( tok == tok_end ) ; vpx_stop_encode <S2SV_ModEnd> ( & residual_bc ) ; if ( tile_col <
<S2SV_ModStart> <S2SV_null> static void encode_txfm_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> ( w , MIN ( cm -> tx_mode , <S2SV_ModStart> ; if ( cm -> tx_mode >= ALLOW_32X32 ) vpx_write_bit <S2SV_ModEnd> ( w , cm -> tx_mode == TX_MODE_SELECT ) <S2SV_ModStart> < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_8x8 ( counts -> <S2SV_ModEnd> tx . p8x8 [ i ] , ct_8x8p ) <S2SV_ModStart> ) vp9_cond_prob_diff_update ( w , & cm -> fc -> <S2SV_ModEnd> tx_probs . p8x8 [ i ] [ j ] <S2SV_ModStart> < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_16x16 ( counts -> <S2SV_ModEnd> tx . p16x16 [ i ] , ct_16x16p ) <S2SV_ModStart> ) vp9_cond_prob_diff_update ( w , & cm -> fc -> <S2SV_ModEnd> tx_probs . p16x16 [ i ] [ j ] <S2SV_ModStart> < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_32x32 ( counts -> <S2SV_ModEnd> tx . p32x32 [ i ] , ct_32x32p ) <S2SV_ModStart> ) vp9_cond_prob_diff_update ( w , & cm -> fc -> <S2SV_ModEnd> tx_probs . p32x32 [ i ] [ j ]
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_unsigned_max ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , int data , int max ) <S2SV_ModStart> wb , int data , int max ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , data , get_unsigned_bits ( max )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void fix_interp_filter ( VP9_COMMON * cm , FRAME_COUNTS * counts <S2SV_ModStart> ; ++ j ) count [ i ] += counts -> <S2SV_ModEnd> switchable_interp [ j ] [ i ] ; c
<S2SV_ModStart> static int get_refresh_mask ( VP9_COMP * cpi ) { if ( vp9_preserve_existing_gf ( cpi ) ) { <S2SV_ModEnd> return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx <S2SV_ModStart> else { int arf_idx = cpi -> alt_fb_idx ; if ( ( cpi -> oxcf . pass == 2 ) && cpi -> multi_arf_allowed ) { const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ; arf_idx = gf_group -> arf_update_idx [ gf_group -> index ] ; } <S2SV_ModEnd> return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx
<S2SV_ModStart> VP9_COMP * cpi , const MODE_INFO * mi , vpx_writer <S2SV_ModEnd> * w ) { VP9_COMMON * const cm = <S2SV_ModStart> const nmv_context * nmvc = & cm -> fc -> nmvc ; const MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; const MACROBLOCKD * const xd = & <S2SV_ModStart> const mbmi = & mi -> mbmi ; const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const PREDICTION_MODE <S2SV_ModEnd> mode = mbmi -> mode ; const int segment_id <S2SV_ModStart> { const int pred_flag = mbmi -> seg_id_predicted ; vpx_prob <S2SV_ModEnd> pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_ModStart> pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; vpx_write <S2SV_ModEnd> ( w , pred_flag , pred_prob ) ; if <S2SV_ModStart> segment_id ) ; } } skip = write_skip ( cm , xd <S2SV_ModEnd> , segment_id , mi , w ) ; if <S2SV_ModStart> , mi , w ) ; if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) vpx_write <S2SV_ModEnd> ( w , is_inter , vp9_get_intra_inter_prob ( cm , <S2SV_ModStart> -> tx_mode == TX_MODE_SELECT && ! ( is_inter && skip ) ) { write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w ) ; } if ( ! is_inter <S2SV_ModStart> write_intra_mode ( w , mode , cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group_lookup [ bsize ] ] ) ; <S2SV_ModStart> < 2 ; idx += num_4x4_w ) { const PREDICTION_MODE <S2SV_ModEnd> b_mode = mi -> bmi [ idy * 2 <S2SV_ModStart> write_intra_mode ( w , b_mode , cm -> fc -> <S2SV_ModEnd> y_mode_prob [ 0 ] ) ; } } } <S2SV_ModStart> w , mbmi -> uv_mode , cm -> fc -> <S2SV_ModEnd> uv_mode_prob [ mode ] ) ; } else { <S2SV_ModStart> ) ; } else { const int mode_ctx = mbmi_ext <S2SV_ModEnd> -> mode_context [ mbmi -> ref_frame [ 0 ] <S2SV_ModStart> mbmi -> ref_frame [ 0 ] ] ; const vpx_prob * const inter_probs = cm -> fc -> inter_mode_probs [ mode_ctx ] ; write_ref_frames ( cm , xd , w ) ; if ( ! segfeature_active <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_ModStart> { write_inter_mode ( w , mode , inter_probs ) <S2SV_ModEnd> ; } } if ( cm -> interp_filter == <S2SV_ModStart> vp9_write_token ( w , vp9_switchable_interp_tree , cm -> fc -> <S2SV_ModEnd> switchable_interp_prob [ ctx ] , & switchable_interp_encodings [ mbmi <S2SV_ModStart> , & switchable_interp_encodings [ mbmi -> interp_filter ] ) ; ++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] <S2SV_ModStart> j = idy * 2 + idx ; const PREDICTION_MODE <S2SV_ModEnd> b_mode = mi -> bmi [ j ] . <S2SV_ModStart> ; write_inter_mode ( w , b_mode , inter_probs ) <S2SV_ModEnd> ; if ( b_mode == NEWMV ) { for <S2SV_ModStart> . as_mv [ ref ] . as_mv , & mbmi_ext <S2SV_ModEnd> -> ref_mvs [ mbmi -> ref_frame [ ref ] <S2SV_ModStart> -> mv [ ref ] . as_mv , & mbmi_ext <S2SV_ModEnd> -> ref_mvs [ mbmi -> ref_frame [ ref ]
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void pack_mb_tokens ( vpx_writer <S2SV_ModEnd> * w , TOKENEXTRA * * tp , const <S2SV_ModStart> , TOKENEXTRA * * tp , const TOKENEXTRA * const stop , vpx_bit_depth_t bit_depth <S2SV_ModEnd> ) { TOKENEXTRA * p = * tp ; <S2SV_ModStart> const a = & vp9_coef_encodings [ t ] ; int i = 0 ; int v = a -> value ; int n = a -> len ; # if CONFIG_VP9_HIGHBITDEPTH const vp9_extra_bit * b ; if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ; else if ( bit_depth == VPX_BITS_10 ) b = & vp9_extra_bits_high10 [ t ] ; else b = & vp9_extra_bits [ t ] ; # else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; ( void ) bit_depth ; # endif <S2SV_ModEnd> if ( p -> skip_eob_node ) { n -= <S2SV_ModStart> ( v >> -- n ) & 1 ; vpx_write <S2SV_ModEnd> ( w , bb , pb [ i >> <S2SV_ModStart> ] ; } while ( n ) ; } vpx_write_bit <S2SV_ModEnd> ( w , e & 1 ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void prob_diff_update ( const vpx_tree_index * tree , vpx_prob <S2SV_ModEnd> probs [ ] , const unsigned int counts [ <S2SV_ModStart> unsigned int counts [ ] , int n , vpx_writer <S2SV_ModEnd> * w ) { int i ; unsigned int
<S2SV_ModStart> <S2SV_null> static void update_coef_probs ( VP9_COMP * cpi , vpx_writer <S2SV_ModEnd> * w ) { const TX_MODE tx_mode = cpi <S2SV_ModStart> = tx_mode_to_biggest_tx_size [ tx_mode ] ; TX_SIZE tx_size ; <S2SV_ModEnd> for ( tx_size = TX_4X4 ; tx_size <= max_tx_size <S2SV_ModStart> TX_4X4 ; tx_size <= max_tx_size ; ++ tx_size ) { vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ; vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ; if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) { vpx_write_bit ( w , 0 ) ; } else { build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ; <S2SV_ModStart> update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct , frame_coef_probs ) ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void update_coef_probs_common ( vpx_writer <S2SV_ModEnd> * const bc , VP9_COMP * cpi , TX_SIZE <S2SV_ModStart> * cpi , TX_SIZE tx_size , vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) { vp9_coeff_probs_model * old_coef_probs = cpi -> common . fc -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> ; switch ( cpi -> sf . use_fast_coef_updates ) <S2SV_ModStart> ; t < entropy_nodes_update ; ++ t ) { vpx_prob newp = new_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> ] [ l ] [ t ] ; const vpx_prob oldp = old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> k ] [ l ] [ 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> ] [ l ] , & newp , upd , stepsize <S2SV_ModStart> ] == 0 || savings < 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc , 0 ) ; return ; } <S2SV_ModStart> ( bc , 0 ) ; return ; } vpx_write_bit <S2SV_ModEnd> ( bc , 1 ) ; for ( i <S2SV_ModStart> ; t < entropy_nodes_update ; ++ t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> k ] [ l ] + t ; const vpx_prob <S2SV_ModEnd> upd = DIFF_UPDATE_PROB ; int s ; int u <S2SV_ModStart> k ] [ l ] [ 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> ] [ l ] , & newp , upd , stepsize <S2SV_ModStart> newp != * oldp ) u = 1 ; vpx_write <S2SV_ModEnd> ( bc , u , upd ) ; if <S2SV_ModStart> } } } } } } return ; } case ONE_LOOP_REDUCED : { int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> ; ++ k ) { for ( l = <S2SV_ModStart> ; t < entropy_nodes_update ; ++ t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> ; int s ; int u = 0 ; if ( t == PIVOT_NODE ) { <S2SV_ModEnd> s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ <S2SV_ModStart> k ] [ l ] [ 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] [ j ] [ k ] <S2SV_ModStart> ] [ l ] , & newp , upd , stepsize ) ; } else { <S2SV_ModEnd> s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ <S2SV_ModStart> * oldp , & newp , upd ) ; } <S2SV_ModStart> newp != * oldp ) u = 1 ; <S2SV_ModEnd> updates += u ; if ( u == 0 <S2SV_ModStart> && updates == 1 ) { int v ; vpx_write_bit <S2SV_ModEnd> ( bc , 1 ) ; for ( v <S2SV_ModStart> 0 ; v < noupdates_before_first ; ++ v ) vpx_write <S2SV_ModEnd> ( bc , 0 , upd ) ; } <S2SV_ModStart> ( bc , 0 , upd ) ; } vpx_write <S2SV_ModEnd> ( bc , u , upd ) ; if <S2SV_ModStart> } } if ( updates == 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc , 0 ) ; } return ;
<S2SV_ModStart> <S2SV_null> static void update_skip_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> ) { int k ; for ( k = <S2SV_ModStart> ) vp9_cond_prob_diff_update ( w , & cm -> fc -> skip_probs [ k ] , counts -> <S2SV_ModEnd> skip [ k ] ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void update_switchable_interp_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts <S2SV_ModEnd> ) { int j ; for ( j = <S2SV_ModStart> j ) prob_diff_update ( vp9_switchable_interp_tree , cm -> fc -> switchable_interp_prob [ j ] , counts -> <S2SV_ModEnd> switchable_interp [ j ] , SWITCHABLE_FILTERS , w )
<S2SV_ModStart> ; MACROBLOCKD * const xd = & cpi -> td . <S2SV_ModStart> mb . e_mbd ; FRAME_CONTEXT * const fc = cm -> fc ; FRAME_COUNTS * counts = cpi -> td . counts ; vpx_writer header_bc ; vpx_start_encode <S2SV_ModEnd> ( & header_bc , data ) ; if ( <S2SV_ModStart> ONLY_4X4 ; else encode_txfm_probs ( cm , & header_bc , counts <S2SV_ModStart> header_bc ) ; update_skip_probs ( cm , & header_bc , counts <S2SV_ModStart> i ) prob_diff_update ( vp9_inter_mode_tree , cm -> fc -> inter_mode_probs [ i ] , counts -> <S2SV_ModEnd> inter_mode [ i ] , INTER_MODES , & header_bc <S2SV_ModStart> inter_mode [ i ] , INTER_MODES , & header_bc <S2SV_ModEnd> ) ; if ( cm -> interp_filter == SWITCHABLE <S2SV_ModStart> == SWITCHABLE ) update_switchable_interp_probs ( cm , & header_bc , counts <S2SV_ModStart> , & fc -> intra_inter_prob [ i ] , counts -> intra_inter [ i ] ) ; if ( cpi <S2SV_ModEnd> -> allow_comp_inter_inter ) { const int use_compound_pred = cm <S2SV_ModStart> int use_hybrid_pred = cm -> reference_mode == REFERENCE_MODE_SELECT ; vpx_write_bit <S2SV_ModEnd> ( & header_bc , use_compound_pred ) ; if ( <S2SV_ModStart> , use_compound_pred ) ; if ( use_compound_pred ) { vpx_write_bit <S2SV_ModEnd> ( & header_bc , use_hybrid_pred ) ; if ( <S2SV_ModStart> , & fc -> comp_inter_prob [ i ] , counts -> <S2SV_ModEnd> comp_inter [ i ] ) ; } } if <S2SV_ModStart> -> single_ref_prob [ i ] [ 0 ] , counts -> <S2SV_ModEnd> single_ref [ i ] [ 0 ] ) ; <S2SV_ModStart> -> single_ref_prob [ i ] [ 1 ] , counts -> <S2SV_ModEnd> single_ref [ i ] [ 1 ] ) ; <S2SV_ModStart> , & fc -> comp_ref_prob [ i ] , counts -> <S2SV_ModEnd> comp_ref [ i ] ) ; for ( i <S2SV_ModStart> i ) prob_diff_update ( vp9_intra_mode_tree , cm -> fc -> y_mode_prob [ i ] , counts -> <S2SV_ModEnd> y_mode [ i ] , INTRA_MODES , & header_bc <S2SV_ModStart> vp9_partition_tree , fc -> partition_prob [ i ] , counts -> <S2SV_ModEnd> partition [ i ] , PARTITION_TYPES , & header_bc <S2SV_ModStart> ( cm , cm -> allow_high_precision_mv , & header_bc , & counts -> mv ) ; } vpx_stop_encode <S2SV_ModEnd> ( & header_bc ) ; assert ( header_bc .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_delta_q ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , int delta_q ) { if ( <S2SV_ModStart> ) { if ( delta_q != 0 ) { vpx_wb_write_bit ( wb , 1 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , abs ( delta_q ) , 4 <S2SV_ModStart> , abs ( delta_q ) , 4 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , delta_q < 0 ) ; } <S2SV_ModStart> , delta_q < 0 ) ; } else { vpx_wb_write_bit <S2SV_ModEnd> ( wb , 0 ) ; } } <S2SV_null>
<S2SV_ModStart> void write_display_size ( const VP9_COMMON * cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { const int scaling_active = cm <S2SV_ModStart> || cm -> height != cm -> display_height ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , scaling_active ) ; if ( scaling_active <S2SV_ModStart> , scaling_active ) ; if ( scaling_active ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> display_width - 1 , <S2SV_ModStart> cm -> display_width - 1 , 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> display_height - 1 ,
<S2SV_ModStart> void write_frame_size ( const VP9_COMMON * cm , struct vpx_write_bit_buffer * wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> width - 1 , <S2SV_ModStart> cm -> width - 1 , 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> height - 1 ,
<S2SV_ModStart> static void write_frame_size_with_refs ( VP9_COMP * cpi , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { VP9_COMMON * const cm = <S2SV_ModStart> cfg = get_ref_frame_buffer ( cpi , ref_frame ) ; if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) { found = 0 ; } else if ( cfg != NULL ) { <S2SV_ModStart> && cm -> height == cfg -> y_crop_height ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb , found ) ; if ( found <S2SV_ModStart> ; } } if ( ! found ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> width - 1 , <S2SV_ModStart> cm -> width - 1 , 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> height - 1 ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_inter_mode ( vpx_writer * w , PREDICTION_MODE mode , const vpx_prob <S2SV_ModEnd> * probs ) { assert ( is_inter_mode ( mode
<S2SV_ModStart> <S2SV_null> static void write_interp_filter ( INTERP_FILTER filter , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { const int filter_to_literal [ ] <S2SV_ModStart> 1 , 0 , 2 , 3 } ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , filter == SWITCHABLE ) ; if <S2SV_ModStart> SWITCHABLE ) ; if ( filter != SWITCHABLE ) vpx_wb_write_literal <S2SV_ModEnd> ( wb , filter_to_literal [ filter ] , 2
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_intra_mode ( vpx_writer * w , PREDICTION_MODE mode , const vpx_prob <S2SV_ModEnd> * probs ) { vp9_write_token ( w , vp9_intra_mode_tree
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , vpx_writer * w ) { <S2SV_ModEnd> const struct segmentation * const seg = & cm <S2SV_ModStart> 0 ] ; const MODE_INFO * const above_mi = xd -> above_mi ; const MODE_INFO * const left_mi = xd -> left_mi <S2SV_ModEnd> ; const MB_MODE_INFO * const mbmi = & mi <S2SV_ModStart> seg , mbmi -> segment_id ) ; write_skip ( cm , xd <S2SV_ModEnd> , mbmi -> segment_id , mi , w ) <S2SV_ModStart> && cm -> tx_mode == TX_MODE_SELECT ) write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w ) ; if ( bsize >= BLOCK_8X8
<S2SV_ModStart> * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end ) { const VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; int mi_row , mi_col ; set_partition_probs ( cm , xd ) <S2SV_ModEnd> ; for ( mi_row = tile -> mi_row_start ; <S2SV_ModStart> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { vp9_zero ( xd -> <S2SV_ModEnd> left_seg_context ) ; for ( mi_col = tile ->
<S2SV_ModStart> * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end , int mi_row , int mi_col ) { <S2SV_ModStart> tok_end , int mi_row , int mi_col ) { const <S2SV_ModStart> ; MACROBLOCKD * const xd = & cpi -> td . <S2SV_ModStart> m = xd -> mi [ 0 ] ; cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ; <S2SV_ModStart> ( frame_is_intra_only ( cm ) ) { write_mb_modes_kf ( cm , xd <S2SV_ModEnd> , xd -> mi , w ) ; } <S2SV_ModStart> ) ; pack_mb_tokens ( w , tok , tok_end , cm -> bit_depth
<S2SV_ModStart> * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end , int mi_row , int mi_col , BLOCK_SIZE <S2SV_ModStart> mi_row , int mi_col , BLOCK_SIZE bsize ) { const <S2SV_ModStart> ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; const int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const int bs = ( 1 << bsl <S2SV_ModStart> / 4 ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModEnd> m = cm -> mi_grid_visible [ mi_row * cm <S2SV_ModStart> [ mi_row * cm -> mi_stride + mi_col ] <S2SV_ModEnd> ; partition = partition_lookup [ bsl ] [ m
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> xd , int hbs , int mi_row , int <S2SV_ModStart> int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vpx_writer <S2SV_ModEnd> * w ) { const int ctx = partition_plane_context <S2SV_ModStart> , mi_row , mi_col , bsize ) ; const vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> ; const int has_rows = ( mi_row + hbs <S2SV_ModStart> p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; vpx_write <S2SV_ModEnd> ( w , p == PARTITION_SPLIT , probs [ <S2SV_ModStart> p == PARTITION_SPLIT || p == PARTITION_VERT ) ; vpx_write <S2SV_ModEnd> ( w , p == PARTITION_SPLIT , probs [
<S2SV_ModStart> <S2SV_null> static void write_profile ( BITSTREAM_PROFILE profile , struct vpx_write_bit_buffer * wb ) { switch ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 ) ; break ; case PROFILE_1 : vpx_wb_write_literal ( wb , 2 , 2 ) ; break ; case PROFILE_2 : vpx_wb_write_literal ( wb , 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) <S2SV_ModStart> cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) ; } if ( is_compound ) <S2SV_ModStart> ) ) ; } if ( is_compound ) { vpx_write <S2SV_ModEnd> ( w , mbmi -> ref_frame [ 0 ] <S2SV_ModStart> mbmi -> ref_frame [ 0 ] != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , <S2SV_ModStart> mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_segment_id ( vpx_writer <S2SV_ModEnd> * w , const struct segmentation * seg ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_selected_tx_size ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { TX_SIZE tx_size = xd -> mi [ 0 ] -> mbmi . tx_size ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; <S2SV_ModEnd> const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; <S2SV_ModStart> TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; const vpx_prob <S2SV_ModEnd> * const tx_probs = get_tx_probs2 ( max_tx_size , xd <S2SV_ModStart> tx_probs = get_tx_probs2 ( max_tx_size , xd , & cm -> fc -> tx_probs ) ; vpx_write <S2SV_ModEnd> ( w , tx_size != TX_4X4 , tx_probs [ <S2SV_ModStart> tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) { vpx_write <S2SV_ModEnd> ( w , tx_size != TX_8X8 , tx_probs [ <S2SV_ModStart> ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) vpx_write <S2SV_ModEnd> ( w , tx_size != TX_16X16 , tx_probs [
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int write_skip ( const VP9_COMMON * cm , const MACROBLOCKD * xd <S2SV_ModEnd> , int segment_id , const MODE_INFO * mi , <S2SV_ModStart> , int segment_id , const MODE_INFO * mi , vpx_writer * w ) { if ( segfeature_active ( & cm -> <S2SV_ModEnd> seg , segment_id , SEG_LVL_SKIP ) ) { return <S2SV_ModStart> int skip = mi -> mbmi . skip ; vpx_write ( w , skip , vp9_get_skip_prob ( cm <S2SV_ModEnd> , xd ) ) ; return skip ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_sync_code ( struct vpx_write_bit_buffer * wb ) { vpx_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; vpx_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , VP9_SYNC_CODE_2 , 8 ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_tile_info ( const VP9_COMMON * const cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { int min_log2_tile_cols , max_log2_tile_cols , <S2SV_ModStart> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , 1 ) ; if ( cm <S2SV_ModStart> ; if ( cm -> log2_tile_cols < max_log2_tile_cols ) vpx_wb_write_bit ( wb , 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> log2_tile_rows != 0 ) <S2SV_ModStart> ; if ( cm -> log2_tile_rows != 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> log2_tile_rows != 1 )
<S2SV_ModStart> static void write_uncompressed_header ( VP9_COMP * cpi , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) { VP9_COMMON * const cm = <S2SV_ModStart> * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , VP9_FRAME_MARKER , 2 ) ; write_profile <S2SV_ModStart> write_profile ( cm -> profile , wb ) ; vpx_wb_write_bit ( wb , 0 ) ; vpx_wb_write_bit ( wb , cm -> frame_type ) ; vpx_wb_write_bit ( wb , cm -> show_frame ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> error_resilient_mode ) ; if <S2SV_ModStart> if ( cm -> frame_type == KEY_FRAME ) { write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> write_sync_code ( wb ) ; if ( cm -> <S2SV_ModStart> wb ) ; if ( cm -> profile > PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; } else { MV_REFERENCE_FRAME ref_frame ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , get_refresh_mask ( cpi ) , REF_FRAMES <S2SV_ModStart> ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> ( cpi , ref_frame ) , REF_FRAMES_LOG2 ) ; <S2SV_ModStart> ( cpi , ref_frame ) , REF_FRAMES_LOG2 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> ref_frame_sign_bias [ ref_frame ] <S2SV_ModStart> ; } write_frame_size_with_refs ( cpi , wb ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> allow_high_precision_mv ) ; fix_interp_filter <S2SV_ModStart> , cm -> allow_high_precision_mv ) ; fix_interp_filter ( cm , cpi -> td . counts <S2SV_ModStart> } if ( ! cm -> error_resilient_mode ) { vpx_wb_write_bit ( wb , cm -> refresh_frame_context ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , cm -> frame_parallel_decoding_mode ) ; } <S2SV_ModStart> ( wb , cm -> frame_parallel_decoding_mode ) ; } vpx_wb_write_literal <S2SV_ModEnd> ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) <S2SV_ModStart> encode_quantization ( cm , wb ) ; encode_segmentation ( cm , xd <S2SV_ModEnd> , wb ) ; write_tile_info ( cm , wb
<S2SV_ModStart> <S2SV_null> static void cost ( int * costs , vpx_tree tree , const vpx_prob <S2SV_ModEnd> * probs , int i , int c ) <S2SV_ModStart> , int i , int c ) { const vpx_prob <S2SV_ModEnd> prob = probs [ i / 2 ] ; <S2SV_ModStart> + vp9_cost_bit ( prob , b ) ; const vpx_tree_index <S2SV_ModEnd> ii = tree [ i + b ] ;
<S2SV_ModStart> <S2SV_null> void vp9_cost_tokens ( int * costs , const vpx_prob * probs , vpx_tree <S2SV_ModEnd> tree ) { cost ( costs , tree ,
<S2SV_ModStart> <S2SV_null> void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vpx_tree <S2SV_ModEnd> tree ) { assert ( tree [ 0 ]
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fadst16 ( const tran_low_t * input , tran_low_t * output ) { tran_high_t <S2SV_ModEnd> s0 , s1 , s2 , s3 , s4 <S2SV_ModStart> s4 , s5 , s6 , s7 , s8 ; tran_high_t <S2SV_ModEnd> s9 , s10 , s11 , s12 , s13 <S2SV_ModStart> , s12 , s13 , s14 , s15 ; tran_high_t x0 = input [ 15 ] ; tran_high_t x1 = input [ 0 ] ; tran_high_t x2 = input [ 13 ] ; tran_high_t x3 = input [ 2 ] ; tran_high_t x4 = input [ 11 ] ; tran_high_t x5 = input [ 4 ] ; tran_high_t x6 = input [ 9 ] ; tran_high_t x7 = input [ 6 ] ; tran_high_t x8 = input [ 7 ] ; tran_high_t x9 = input [ 8 ] ; tran_high_t x10 = input [ 5 ] ; tran_high_t x11 = input [ 10 ] ; tran_high_t x12 = input [ 3 ] ; tran_high_t x13 = input [ 12 ] ; tran_high_t x14 = input [ 1 ] ; tran_high_t <S2SV_ModEnd> x15 = input [ 14 ] ; s0 = <S2SV_ModStart> ( s15 ) ; output [ 0 ] = ( tran_low_t ) x0 ; output [ 1 ] = ( tran_low_t ) - x8 ; output [ 2 ] = ( tran_low_t ) x12 ; output [ 3 ] = ( tran_low_t ) - x4 ; output [ 4 ] = ( tran_low_t ) x6 ; output [ 5 ] = ( tran_low_t ) x14 ; output [ 6 ] = ( tran_low_t ) x10 ; output [ 7 ] = ( tran_low_t ) x2 ; output [ 8 ] = ( tran_low_t ) x3 ; output [ 9 ] = ( tran_low_t ) x11 ; output [ 10 ] = ( tran_low_t ) x15 ; output [ 11 ] = ( tran_low_t ) x7 ; output [ 12 ] = ( tran_low_t ) x5 ; output [ 13 ] = ( tran_low_t ) - x13 ; output [ 14 ] = ( tran_low_t ) x9 ; output [ 15 ] = ( tran_low_t ) <S2SV_ModEnd> - x1 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fadst4 ( const tran_low_t * input , tran_low_t * output ) { tran_high_t x0 , x1 , x2 , x3 ; tran_high_t <S2SV_ModEnd> s0 , s1 , s2 , s3 , s4 <S2SV_ModStart> x0 + x3 ; output [ 0 ] = ( tran_low_t ) <S2SV_ModStart> ( s0 ) ; output [ 1 ] = ( tran_low_t ) <S2SV_ModStart> ( s1 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModStart> ( s2 ) ; output [ 3 ] = ( tran_low_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fadst8 ( const tran_low_t * input , tran_low_t * output ) { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t x0 = input [ 7 ] ; tran_high_t x1 = input [ 0 ] ; tran_high_t x2 = input [ 5 ] ; tran_high_t x3 = input [ 2 ] ; tran_high_t x4 = input [ 3 ] ; tran_high_t x5 = input [ 4 ] ; tran_high_t x6 = input [ 1 ] ; tran_high_t <S2SV_ModEnd> x7 = input [ 6 ] ; s0 = <S2SV_ModStart> ( s7 ) ; output [ 0 ] = ( tran_low_t ) x0 ; output [ 1 ] = ( tran_low_t ) - x4 ; output [ 2 ] = ( tran_low_t ) x6 ; output [ 3 ] = ( tran_low_t ) - x2 ; output [ 4 ] = ( tran_low_t ) x3 ; output [ 5 ] = ( tran_low_t ) - x7 ; output [ 6 ] = ( tran_low_t ) x5 ; output [ 7 ] = ( tran_low_t ) <S2SV_ModEnd> - x1 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fdct16 ( const tran_low_t in [ 16 ] , tran_low_t out [ 16 ] ) { tran_high_t step1 [ 8 ] ; tran_high_t step2 [ 8 ] ; tran_high_t step3 [ 8 ] ; tran_high_t input [ 8 ] ; tran_high_t <S2SV_ModEnd> temp1 , temp2 ; input [ 0 ] = <S2SV_ModStart> 0 ] - in [ 15 ] ; { tran_high_t <S2SV_ModEnd> s0 , s1 , s2 , s3 , s4 <S2SV_ModStart> , s4 , s5 , s6 , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <S2SV_ModEnd> x0 , x1 , x2 , x3 ; s0 <S2SV_ModStart> x2 * cospi_8_64 ; out [ 0 ] = ( tran_low_t ) <S2SV_ModStart> ( t0 ) ; out [ 4 ] = ( tran_low_t ) <S2SV_ModStart> ( t2 ) ; out [ 8 ] = ( tran_low_t ) <S2SV_ModStart> ( t1 ) ; out [ 12 ] = ( tran_low_t ) <S2SV_ModStart> * - cospi_4_64 ; out [ 2 ] = ( tran_low_t ) <S2SV_ModStart> ( t0 ) ; out [ 6 ] = ( tran_low_t ) <S2SV_ModStart> ( t2 ) ; out [ 10 ] = ( tran_low_t ) <S2SV_ModStart> ( t1 ) ; out [ 14 ] = ( tran_low_t ) <S2SV_ModStart> cospi_24_64 ; temp2 = step3 [ 2 ] * cospi_24_64 + <S2SV_ModEnd> step3 [ 5 ] * cospi_8_64 ; step2 [ <S2SV_ModStart> ) ; temp1 = step3 [ 2 ] * cospi_8_64 - <S2SV_ModEnd> step3 [ 5 ] * cospi_24_64 ; temp2 = <S2SV_ModStart> step1 [ 2 ] = step3 [ 3 ] + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> step2 [ 5 ] ; step1 [ 6 ] <S2SV_ModStart> ] * cospi_18_64 ; out [ 1 ] = ( tran_low_t ) <S2SV_ModStart> ( temp1 ) ; out [ 9 ] = ( tran_low_t ) <S2SV_ModStart> ] * cospi_26_64 ; out [ 5 ] = ( tran_low_t ) <S2SV_ModStart> ( temp1 ) ; out [ 13 ] = ( tran_low_t ) <S2SV_ModStart> ] * cospi_22_64 ; out [ 3 ] = ( tran_low_t ) <S2SV_ModStart> ( temp1 ) ; out [ 11 ] = ( tran_low_t ) <S2SV_ModStart> ] * cospi_30_64 ; out [ 7 ] = ( tran_low_t ) <S2SV_ModStart> ( temp1 ) ; out [ 15 ] = ( tran_low_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fdct4 ( const tran_low_t * input , tran_low_t * output ) { tran_high_t step [ 4 ] ; tran_high_t <S2SV_ModEnd> temp1 , temp2 ; step [ 0 ] = <S2SV_ModStart> ) * cospi_16_64 ; output [ 0 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( temp2 ) ; temp1 = step [ <S2SV_ModStart> ] * cospi_24_64 ; output [ 1 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 3 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( temp2 ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void fdct8 ( const tran_low_t * input , tran_low_t * output ) { tran_high_t <S2SV_ModEnd> s0 , s1 , s2 , s3 , s4 <S2SV_ModStart> , s4 , s5 , s6 , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <S2SV_ModEnd> x0 , x1 , x2 , x3 ; s0 <S2SV_ModStart> x3 * cospi_24_64 ; output [ 0 ] = ( tran_low_t ) <S2SV_ModStart> ( t0 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModStart> ( t2 ) ; output [ 4 ] = ( tran_low_t ) <S2SV_ModStart> ( t1 ) ; output [ 6 ] = ( tran_low_t ) <S2SV_ModStart> s6 + s5 ) * cospi_16_64 ; t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( t1 ) ; x0 = s4 + <S2SV_ModStart> * - cospi_4_64 ; output [ 1 ] = ( tran_low_t ) <S2SV_ModStart> ( t0 ) ; output [ 3 ] = ( tran_low_t ) <S2SV_ModStart> ( t2 ) ; output [ 5 ] = ( tran_low_t ) <S2SV_ModStart> ( t1 ) ; output [ 7 ] = ( tran_low_t )
<S2SV_ModStart> <S2SV_null> void vp9_fht16x16_c ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride , int tx_type ) <S2SV_ModStart> ) { if ( tx_type == DCT_DCT ) { vpx_fdct16x16_c <S2SV_ModEnd> ( input , output , stride ) ; } <S2SV_ModStart> , output , stride ) ; } else { tran_low_t out [ 256 ] ; int i , j ; tran_low_t <S2SV_ModEnd> temp_in [ 16 ] , temp_out [ 16 ] <S2SV_ModStart> 0 ; j < 16 ; ++ j ) out <S2SV_ModEnd> [ j * 16 + i ] = (
<S2SV_ModStart> <S2SV_null> void vp9_fht4x4_c ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride , int tx_type ) <S2SV_ModStart> ) { if ( tx_type == DCT_DCT ) { vpx_fdct4x4_c <S2SV_ModEnd> ( input , output , stride ) ; } <S2SV_ModStart> , output , stride ) ; } else { tran_low_t out [ 4 * 4 ] ; int i , j ; tran_low_t <S2SV_ModEnd> temp_in [ 4 ] , temp_out [ 4 ] <S2SV_ModStart> 0 ; j < 4 ; ++ j ) out <S2SV_ModEnd> [ j * 4 + i ] = temp_out
<S2SV_ModStart> <S2SV_null> void vp9_fht8x8_c ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride , int tx_type ) <S2SV_ModStart> ) { if ( tx_type == DCT_DCT ) { vpx_fdct8x8_c <S2SV_ModEnd> ( input , output , stride ) ; } <S2SV_ModStart> , output , stride ) ; } else { tran_low_t out [ 64 ] ; int i , j ; tran_low_t <S2SV_ModEnd> temp_in [ 8 ] , temp_out [ 8 ] <S2SV_ModStart> 0 ; j < 8 ; ++ j ) out <S2SV_ModEnd> [ j * 8 + i ] = temp_out
<S2SV_ModStart> <S2SV_null> void vp9_fwht4x4_c ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride ) { int i <S2SV_ModStart> output , int stride ) { int i ; tran_high_t <S2SV_ModEnd> a1 , b1 , c1 , d1 , e1 <S2SV_ModStart> c1 , d1 , e1 ; const int16_t * ip_pass0 = input ; const tran_low_t * ip = NULL ; tran_low_t <S2SV_ModEnd> * op = output ; for ( i = <S2SV_ModStart> < 4 ; i ++ ) { a1 = ip_pass0 [ 0 * stride ] ; b1 = ip_pass0 [ 1 * stride ] ; c1 = ip_pass0 [ 2 * stride ] ; d1 = ip_pass0 <S2SV_ModEnd> [ 3 * stride ] ; a1 += b1 <S2SV_ModStart> d1 += b1 ; op [ 0 ] = ( tran_low_t ) a1 ; op [ 4 ] = ( tran_low_t ) c1 ; op [ 8 ] = ( tran_low_t ) d1 ; op [ 12 ] = ( tran_low_t ) b1 ; ip_pass0 <S2SV_ModEnd> ++ ; op ++ ; } ip = output <S2SV_ModStart> d1 += b1 ; op [ 0 ] = ( tran_low_t ) ( a1 * UNIT_QUANT_FACTOR ) ; op [ 1 ] = ( tran_low_t ) ( c1 * UNIT_QUANT_FACTOR ) ; op [ 2 ] = ( tran_low_t ) ( d1 * UNIT_QUANT_FACTOR ) ; op [ 3 ] = ( tran_low_t ) ( b1 * UNIT_QUANT_FACTOR ) <S2SV_ModEnd> ; ip += 4 ; op += 4 ;
<S2SV_ModStart> int ref_flags = cpi -> ref_frame_flags ; if ( segfeature_active <S2SV_ModEnd> ( & cpi -> common . seg , 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> choose_partitioning ( VP9_COMP * cpi , const TileInfo * <S2SV_ModStart> * cpi , const TileInfo * const tile , MACROBLOCK * x , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * xd = & x -> e_mbd ; int i , j , k , m ; v64x64 vt ; v16x16 vt2 [ 16 ] ; int force_split [ 21 ] <S2SV_ModEnd> ; uint8_t * s ; const uint8_t * d <S2SV_ModStart> int pixels_wide = 64 , pixels_high = 64 ; int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; const int use_4x4_partition = is_key_frame ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; int variance4x4downsample [ 16 ] ; int segment_id = CR_SEGMENT_ID_BASE ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; set_vbp_thresholds ( cpi , thresholds , q ) ; } } set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; unsigned int uv_sad <S2SV_ModEnd> ; const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi <S2SV_ModStart> = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; const YV12_BUFFER_CONFIG * yv12_g = NULL ; unsigned int y_sad , y_sad_g ; const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; assert ( yv12 != NULL ) ; if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; } else { y_sad_g = UINT_MAX ; } vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , <S2SV_ModEnd> & cm -> frame_refs [ LAST_FRAME - 1 ] <S2SV_ModStart> -> frame_refs [ LAST_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = LAST_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> sb_type = BLOCK_64X64 ; mbmi -> mv [ 0 ] . as_int = 0 ; mbmi -> interp_filter = BILINEAR ; y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( y_sad_g < y_sad ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; mbmi -> mv [ 0 ] . as_int = 0 ; y_sad = y_sad_g ; } else { x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , BLOCK_64X64 ) ; for ( i = 1 ; i <= 2 ; ++ i ) { struct macroblock_plane * p = & x -> plane [ i ] ; struct macroblockd_plane * pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ; else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ; x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; } d = xd -> plane [ 0 ] . dst . buf ; dp = xd -> plane [ 0 ] . dst . stride ; if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) { const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) { set_block_size ( cpi , x , xd , mi_row , mi_col , BLOCK_64X64 ) ; return 0 ; } } } else { d = VP9_VAR_OFFS ; dp = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( xd -> bd ) { case 10 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; break ; case 12 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; break ; case 8 : default : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; break ; } } # endif } force_split [ 0 ] = 0 ; <S2SV_ModEnd> for ( i = 0 ; i < 4 <S2SV_ModStart> ( i >> 1 ) << 5 ) ; const int i2 = i << 2 ; force_split [ i + 1 ] = 0 ; <S2SV_ModStart> ( ( j >> 1 ) << 4 ) ; const int split_index = 5 + i2 + j <S2SV_ModStart> [ i ] . split [ j ] ; force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 0 ; if ( ! is_key_frame ) { fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high ) ; if ( minmax > cpi -> vbp_threshold_minmax ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( is_key_frame || ( low_res && ! cpi -> use_svc && vt . split [ i ] . split [ j ] . part_variances . none . variance > ( thresholds [ 1 ] << 1 ) ) ) { force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 1 ; <S2SV_ModStart> k < 4 ; k ++ ) { int x8_idx <S2SV_ModEnd> = x16_idx + ( ( k & 1 ) <S2SV_ModStart> k & 1 ) << 3 ) ; int y8_idx <S2SV_ModEnd> = y16_idx + ( ( k >> 1 ) <S2SV_ModStart> ( k >> 1 ) << 3 ) ; v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : & vt2 [ i2 + j ] . split [ k ] ; fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; } <S2SV_ModEnd> } } } for ( i = 0 ; <S2SV_ModStart> ; i < 4 ; i ++ ) { const int i2 = i << 2 ; <S2SV_ModStart> ; j < 4 ; j ++ ) { if ( variance4x4downsample [ i2 + j ] == 1 ) { v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; for ( m = 0 ; m < 4 ; m ++ ) fill_variance_tree ( & vtemp -> split [ m ] , BLOCK_8X8 ) ; fill_variance_tree ( vtemp , BLOCK_16X16 ) ; } } fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; if ( ! force_split [ i + 1 ] ) { get_variance ( & vt . split [ i ] . part_variances . none ) ; if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( ! force_split [ 0 ] ) { fill_variance_tree ( & vt , BLOCK_64X64 ) ; get_variance ( & vt . part_variances . none ) ; } if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || ! set_vt_partitioning ( cpi , x , xd , & vt , BLOCK_64X64 , mi_row , mi_col , thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] <S2SV_ModEnd> ) ) { for ( i = 0 ; <S2SV_ModStart> ( i >> 1 ) << 2 ) ; const int i2 = i << 2 ; if ( ! set_vt_partitioning ( cpi , x , xd , & vt . split [ i ] , <S2SV_ModEnd> BLOCK_32X32 , ( mi_row + y32_idx ) , ( <S2SV_ModStart> y32_idx ) , ( mi_col + x32_idx ) , thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] <S2SV_ModEnd> ) ) { for ( j = 0 ; <S2SV_ModStart> ( j >> 1 ) << 1 ) ; v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , mi_row + y32_idx + y16_idx , mi_col + x32_idx + x16_idx , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) <S2SV_ModEnd> { for ( k = 0 ; k < <S2SV_ModStart> int y8_idx = ( k >> 1 ) ; if ( use_4x4_partition ) { if ( ! set_vt_partitioning ( cpi , x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , mi_row + y32_idx + y16_idx + y8_idx , mi_col + x32_idx + x16_idx + x8_idx , thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { set_block_size ( cpi , x , xd , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_4X4 ) ; } } else { set_block_size ( cpi , x , xd <S2SV_ModEnd> , ( mi_row + y32_idx + y16_idx + y8_idx <S2SV_ModStart> + x8_idx ) , BLOCK_8X8 ) ; } } } } } } } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static void duplicate_mode_info_in_sb ( VP9_COMMON * cm , MACROBLOCKD * <S2SV_ModEnd> xd , int mi_row , int mi_col , BLOCK_SIZE
<S2SV_ModStart> VP9_COMP * cpi , const TileInfo * const tile , ThreadData * td <S2SV_ModStart> , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { MACROBLOCK * const x = & td -> mb ; set_offsets ( cpi , tile , x <S2SV_ModEnd> , mi_row , mi_col , bsize ) ; update_state <S2SV_ModStart> mi_col , bsize ) ; update_state ( cpi , td , ctx <S2SV_ModEnd> , mi_row , mi_col , bsize , output_enabled ) <S2SV_ModStart> bsize , output_enabled ) ; encode_superblock ( cpi , td , <S2SV_ModStart> tp , output_enabled , mi_row , mi_col , bsize , ctx <S2SV_ModStart> ) ; if ( output_enabled ) { update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; ( * tp ) -> token =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void encode_b_rt ( VP9_COMP * cpi , ThreadData * td <S2SV_ModStart> , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { MACROBLOCK * const x = & td -> mb ; set_offsets ( cpi , tile , x <S2SV_ModEnd> , mi_row , mi_col , bsize ) ; update_state_rt <S2SV_ModStart> mi_col , bsize ) ; update_state_rt ( cpi , td , ctx , mi_row , mi_col , bsize ) ; # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) { vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ; } # endif encode_superblock ( cpi , td <S2SV_ModEnd> , tp , output_enabled , mi_row , mi_col , <S2SV_ModStart> tp , output_enabled , mi_row , mi_col , bsize , ctx ) ; update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; ( * tp ) -> token =
<S2SV_ModStart> * const sf = & cpi -> sf ; ThreadData * const td = & cpi -> td ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; VP9_COMMON * const cm = & <S2SV_ModStart> * const xd = & x -> e_mbd ; RD_COUNTS * const rdc = & cpi -> td . rd_counts ; <S2SV_ModStart> 0 ] = cm -> mi ; vp9_zero ( * td -> counts ) ; vp9_zero ( rdc -> coef_counts ) ; vp9_zero ( rdc -> comp_pred_diff ) ; vp9_zero ( rdc -> filter_diff ) ; xd -> lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add ; # else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; # endif x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; if ( xd -> lossless ) x -> optimize = 0 ; cm -> tx_mode = select_tx_mode ( cpi , xd ) ; vp9_frame_init_quantizer ( cpi ) ; vp9_initialize_rd_consts ( cpi ) ; vp9_initialize_me_consts ( cpi , x , cm -> base_qindex ) ; init_encode_frame_mb_context ( cpi ) ; cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame ; cm -> prev_mi = cm -> use_prev_frame_mvs ? cm -> prev_mip + cm -> mi_stride + 1 : NULL ; x -> quant_fp = cpi -> sf . use_quant_fp ; vp9_zero ( x -> skip_txfm <S2SV_ModEnd> ) ; if ( sf -> use_nonrd_pick_mode ) { <S2SV_ModStart> plane ; PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none <S2SV_ModEnd> ; for ( i = 0 ; i < <S2SV_ModStart> vp9_zero ( x -> zcoeff_blk ) ; if ( cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; if ( sf -> partition_search_type == SOURCE_VAR_BASED_PARTITION ) source_var_based_partition_search_method ( cpi ) ; <S2SV_ModEnd> } { struct vpx_usec_timer emr_timer ; vpx_usec_timer_start ( & <S2SV_ModStart> vpx_usec_timer emr_timer ; vpx_usec_timer_start ( & emr_timer ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , & cpi -> twopass . this_frame_mb_stats ) ; } # endif if ( MIN ( cpi -> oxcf . max_threads , 1 << cm -> log2_tile_cols ) > 1 ) vp9_encode_tiles_mt ( cpi ) ; else encode_tiles ( cpi ) ; <S2SV_ModEnd> vpx_usec_timer_mark ( & emr_timer ) ; cpi -> time_encode_sb_row <S2SV_ModStart> time_encode_sb_row += vpx_usec_timer_elapsed ( & emr_timer ) ; } sf -> skip_encode_frame = sf -> skip_encode_sb ? get_skip_encode_frame ( cm , td ) : 0 ; <S2SV_ModEnd> # if 0 cpi -> last_frame_distortion = cpi ->
<S2SV_ModStart> <S2SV_null> static void encode_nonrd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; for ( mi_col = tile_info -> mi_col_start ; mi_col < tile_info -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> ; const int idx_str = cm -> mi_stride * <S2SV_ModStart> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ; PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type ; BLOCK_SIZE bsize = BLOCK_64X64 ; int seg_skip = 0 ; x -> source_variance = UINT_MAX ; vp9_zero ( x -> pred_mv ) ; vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } switch ( <S2SV_ModEnd> partition_search_type ) { case VAR_BASED_PARTITION : choose_partitioning ( cpi <S2SV_ModStart> ) { case VAR_BASED_PARTITION : choose_partitioning ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , mi_col ) ; nonrd_use_partition ( cpi <S2SV_ModStart> mi_row , mi_col ) ; nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; break ; case SOURCE_VAR_BASED_PARTITION : set_source_var_based_partition ( cpi , tile_info , x , mi <S2SV_ModEnd> , mi_row , mi_col ) ; nonrd_use_partition ( cpi <S2SV_ModStart> mi_row , mi_col ) ; nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; break ; case FIXED_PARTITION : if ( ! seg_skip ) bsize = sf -> always_this_block_size ; set_fixed_partitioning ( cpi , tile_info , mi <S2SV_ModEnd> , mi_row , mi_col , bsize ) ; nonrd_use_partition <S2SV_ModStart> mi_col , bsize ) ; nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; break ; case REFERENCE_PARTITION : set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; nonrd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rdc , 1 , INT64_MAX , td -> pc_root ) ; } else { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; } break ; default : assert ( <S2SV_ModStart> break ; default : assert ( 0 ) ; break ;
<S2SV_ModStart> <S2SV_null> static void encode_rd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; for ( mi_col = tile_info -> mi_col_start ; mi_col < tile_info -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { const struct segmentation * const seg = & cm -> seg ; int dummy_rate ; int64_t dummy_dist ; RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> ; if ( sf -> adaptive_pred_interp_filter ) { for <S2SV_ModStart> sf -> adaptive_pred_interp_filter ) { for ( i = 0 ; i < 64 ; ++ i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX ; if ( sf -> partition_search_type == FIXED_PARTITION || seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( sf -> partition_search_type == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( sf -> auto_min_max_partition_size ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , mi_row , mi_col , BLOCK_64X64 , <S2SV_ModStart> tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rdc , INT64_MAX , td -> pc_root <S2SV_ModEnd> ) ; } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void encode_sb ( VP9_COMP * cpi , ThreadData * td , <S2SV_ModStart> , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> -> common ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> & x -> e_mbd ; const int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = ( 1 << bsl ) / <S2SV_ModStart> ; int ctx ; PARTITION_TYPE partition ; BLOCK_SIZE subsize = bsize <S2SV_ModStart> mi_row , mi_col , bsize ) ; subsize = get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> ) ; } else { ctx = 0 ; <S2SV_ModStart> partition = partition_lookup [ bsl ] [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart> ; switch ( partition ) { case PARTITION_NONE : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ; break ; case PARTITION_VERT : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if ( mi_col + hbs < cm <S2SV_ModStart> if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; } break ; case PARTITION_HORZ : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if ( mi_row + hbs < cm <S2SV_ModStart> if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; } break ; case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { encode_sb ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } break ; default : assert ( 0 && "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; break <S2SV_ModEnd> ; } if ( partition != PARTITION_SPLIT || bsize
<S2SV_ModStart> <S2SV_null> static void encode_sb_rt ( VP9_COMP * cpi , ThreadData * td , <S2SV_ModStart> , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> -> common ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> & x -> e_mbd ; const int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = ( 1 << bsl ) / <S2SV_ModStart> return ; if ( bsize >= BLOCK_8X8 ) { <S2SV_ModEnd> const int idx_str = xd -> mi_stride * mi_row <S2SV_ModStart> = partition_lookup [ bsl ] [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; switch ( partition ) { case PARTITION_NONE : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ; break ; case PARTITION_VERT : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if ( mi_col + hbs < cm <S2SV_ModStart> if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; } break ; case PARTITION_HORZ : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if ( mi_row + hbs < cm <S2SV_ModStart> if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } break ; case PARTITION_SPLIT : subsize <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; break ; default : assert ( 0 && "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; break <S2SV_ModEnd> ; } if ( partition != PARTITION_SPLIT || bsize
<S2SV_ModStart> int mi_row , int mi_col , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModEnd> ) { MACROBLOCKD * xd = & x -> <S2SV_ModStart> = & x -> e_mbd ; int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = ( 1 << bsl ) / <S2SV_ModStart> << bsl ) / 4 ; PARTITION_TYPE partition = pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> ; assert ( bsize >= BLOCK_8X8 ) ; if <S2SV_ModStart> ; switch ( partition ) { case PARTITION_NONE : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , mi_row , mi_col ) ; * <S2SV_ModStart> ( xd -> mi [ 0 ] ) = pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> ; duplicate_mode_info_in_sb ( cm , xd , mi_row , <S2SV_ModStart> , bsize ) ; break ; case PARTITION_VERT : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , mi_row , mi_col ) ; * <S2SV_ModStart> ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col <S2SV_ModStart> ( cm , xd , mi_row , mi_col , subsize <S2SV_ModEnd> ) ; if ( mi_col + hbs < cm <S2SV_ModStart> mi_col + hbs < cm -> mi_cols ) { set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col <S2SV_ModStart> , xd , mi_row , mi_col + hbs , subsize ) ; } break ; case PARTITION_HORZ : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , mi_row , mi_col ) ; * <S2SV_ModStart> ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 0 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col <S2SV_ModStart> ( cm , xd , mi_row , mi_col , subsize <S2SV_ModEnd> ) ; if ( mi_row + hbs < cm <S2SV_ModStart> mi_row + hbs < cm -> mi_rows ) { set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModEnd> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs <S2SV_ModStart> , xd , mi_row + hbs , mi_col , subsize ) ; } break ; case PARTITION_SPLIT : { <S2SV_ModEnd> fill_mode_info_sb ( cm , x , mi_row , mi_col <S2SV_ModStart> , x , mi_row , mi_col , subsize , pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) ; fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; fill_mode_info_sb ( cm , x , mi_row + <S2SV_ModStart> cm , x , mi_row + hbs , mi_col + hbs , subsize , pc_tree -> split [ 3 ] ) ; break ; } <S2SV_ModEnd> default : break ; } } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; v -> sum_error = s ; v -> log2_count = c ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * data , BLOCK_SIZE bsize ) { variance_node node ; memset ( & node , 0 , sizeof ( node ) )
<S2SV_ModStart> cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) return GOLDEN_FRAME ; else return LAST_FRAME <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , MACROBLOCK * x <S2SV_ModStart> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src <S2SV_ModEnd> , mi_row , mi_col , BLOCK_64X64 ) ; if
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO * * mi_8x8 , BLOCK_SIZE * min_block_size <S2SV_ModStart> mi_8x8 , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) { <S2SV_ModEnd> int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE <S2SV_ModStart> ? mi -> mbmi . sb_type : 0 ; bs_hist [ sb_type ] ++ ;
<S2SV_ModStart> static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , const struct buf_2d * ref <S2SV_ModEnd> , int mi_row , int mi_col , BLOCK_SIZE bs <S2SV_ModStart> mi_row , int mi_col , BLOCK_SIZE bs ) { unsigned int sse , var ; uint8_t * last_y ; const YV12_BUFFER_CONFIG * last = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; assert ( last != NULL ) ; last_y = & last -> y_buffer [ mi_row * MI_SIZE * last -> y_stride + mi_col * MI_SIZE ] <S2SV_ModEnd> ; var = cpi -> fn_ptr [ bs ] <S2SV_ModStart> cpi -> fn_ptr [ bs ] . vf ( ref -> buf , ref -> stride , last_y , last <S2SV_ModEnd> -> y_stride , & sse ) ; return ROUND_POWER_OF_TWO
<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source <S2SV_ModEnd> , 0 , 0 ) ; vp9_setup_block_planes ( & <S2SV_ModStart> cm -> subsampling_x , cm -> subsampling_y ) ; memset <S2SV_ModEnd> ( xd -> above_context [ 0 ] , 0 <S2SV_ModStart> ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ; memset <S2SV_ModEnd> ( xd -> above_seg_context , 0 , sizeof (
<S2SV_ModStart> MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { memcpy <S2SV_ModEnd> ( x -> pred_mv , ctx -> pred_mv ,
<S2SV_ModStart> <S2SV_null> static void nonrd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA * * tp , int mi_row , <S2SV_ModStart> int mi_row , int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , int do_recon , int64_t best_rd , PC_TREE * pc_tree ) { const SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> VP9_COMMON * const cm = & cpi -> common <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> tp_orig = * tp ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; int i ; BLOCK_SIZE subsize = bsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int do_split = bsize >= BLOCK_8X8 ; int <S2SV_ModStart> >= BLOCK_8X8 ; ( void ) * tp_orig ; <S2SV_ModEnd> assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ <S2SV_ModStart> bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; if ( sf -> auto_min_max_partition_size ) { partition_none_allowed &= ( bsize <= x -> max_partition_size && bsize >= x -> <S2SV_ModEnd> min_partition_size ) ; partition_horz_allowed &= ( ( bsize <= <S2SV_ModStart> min_partition_size ) ; partition_horz_allowed &= ( ( bsize <= x -> max_partition_size && bsize > x -> <S2SV_ModEnd> min_partition_size ) || force_horz_split ) ; partition_vert_allowed &= ( <S2SV_ModStart> force_horz_split ) ; partition_vert_allowed &= ( ( bsize <= x -> max_partition_size && bsize > x -> <S2SV_ModEnd> min_partition_size ) || force_vert_split ) ; do_split &= bsize <S2SV_ModStart> ) || force_vert_split ) ; do_split &= bsize > x -> min_partition_size ; } if ( sf -> <S2SV_ModEnd> use_square_partition_only ) { partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= <S2SV_ModStart> partition_horz_allowed &= force_horz_split ; partition_vert_allowed &= force_vert_split ; } ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) <S2SV_ModEnd> ; if ( partition_none_allowed ) { nonrd_pick_sb_modes ( cpi <S2SV_ModStart> if ( partition_none_allowed ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx ) ; ctx <S2SV_ModEnd> -> mic . mbmi = xd -> mi [ <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; ctx -> mbmi_ext = * x -> mbmi_ext ; ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; ctx -> skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX ) { int pl = partition_plane_context ( <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_NONE ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( this_rdc . rdcost < best_rdc . rdcost ) { int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ; int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; dist_breakout_thr <S2SV_ModEnd> >>= 8 - ( b_width_log2_lookup [ bsize ] + <S2SV_ModStart> bsize ] + b_height_log2_lookup [ bsize ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> ; if ( ! x -> e_mbd . lossless <S2SV_ModStart> if ( ! x -> e_mbd . lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr <S2SV_ModEnd> ) { do_split = 0 ; do_rect = 0 <S2SV_ModStart> 0 ; do_rect = 0 ; } } } } store_pred_mv ( x , ctx ) ; if ( do_split <S2SV_ModEnd> ) { int pl = partition_plane_context ( xd , <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) <S2SV_ModEnd> ; subsize = get_subsize ( bsize , PARTITION_SPLIT ) <S2SV_ModStart> ( i = 0 ; i < 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ i ) { const int x_idx = <S2SV_ModStart> + x_idx >= cm -> mi_cols ) continue ; <S2SV_ModEnd> load_pred_mv ( x , ctx ) ; nonrd_pick_partition ( <S2SV_ModStart> x , ctx ) ; nonrd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , mi_row + y_idx , mi_col + <S2SV_ModStart> y_idx , mi_col + x_idx , subsize , & this_rdc , 0 , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate == INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) ; } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT ; } else { if ( sf -> <S2SV_ModEnd> less_rectangular_check ) do_rect &= ! partition_none_allowed ; } } <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row + ms < cm -> mi_rows ) <S2SV_ModStart> mi_row + ms < cm -> mi_rows ) { load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row + ms , mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; if ( this_rdc . rate == INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } else { int pl = partition_plane_context ( <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_HORZ ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) <S2SV_ModEnd> ; } } if ( partition_vert_allowed && do_rect ) <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_VERT ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col + ms < cm -> mi_cols ) <S2SV_ModStart> mi_col + ms < cm -> mi_cols ) { load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + ms , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; if ( this_rdc . rate == INT_MAX ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } else { int pl = partition_plane_context ( <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_VERT ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) ; } } * rd_cost = best_rdc ; if ( best_rdc . rate == INT_MAX ) { vp9_rd_cost_reset ( rd_cost ) ; return ; } <S2SV_ModEnd> fill_mode_info_sb ( cm , x , mi_row , mi_col <S2SV_ModStart> , x , mi_row , mi_col , bsize , pc_tree ) ; if ( best_rdc . rate < INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX && do_recon ) { int output_enabled = <S2SV_ModStart> int output_enabled = ( bsize == BLOCK_64X64 ) ; encode_sb_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } if ( bsize == BLOCK_64X64 && do_recon <S2SV_ModEnd> ) { assert ( tp_orig < * tp ) <S2SV_ModStart> ( tp_orig < * tp ) ; assert ( best_rdc . rate < INT_MAX ) ; assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX ) ; } else { assert (
<S2SV_ModStart> <S2SV_null> static void nonrd_pick_sb_modes ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModEnd> ) { VP9_COMMON * const cm = & cpi <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD * const xd = & x -> <S2SV_ModStart> * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) vp9_pick_inter_mode ( cpi , x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void nonrd_use_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , MODE_INFO * * mi <S2SV_ModEnd> , TOKENEXTRA * * tp , int mi_row , <S2SV_ModStart> int mi_col , BLOCK_SIZE bsize , int output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON * const cm = & cpi <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> & x -> e_mbd ; const int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = ( 1 << bsl ) / <S2SV_ModStart> -> mi_stride ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_ModEnd> if ( mi_row >= cm -> mi_rows || mi_col <S2SV_ModStart> ; subsize = ( bsize >= BLOCK_8X8 ) ? mi <S2SV_ModEnd> [ 0 ] -> mbmi . sb_type : BLOCK_4X4 <S2SV_ModStart> = partition_lookup [ bsl ] [ subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } switch ( partition ) { case PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> = xd -> mi [ 0 ] -> mbmi ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ; break ; case PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> = xd -> mi [ 0 ] -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; } break ; case PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . mbmi = xd -> mi [ 0 <S2SV_ModStart> = xd -> mi [ 0 ] -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> } break ; case PARTITION_SPLIT : subsize = get_subsize <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , mi_row , mi_col , subsize , <S2SV_ModStart> , mi_row , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 0 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi <S2SV_ModEnd> + hbs , tp , mi_row , mi_col + <S2SV_ModStart> , mi_col + hbs , subsize , output_enabled , dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis + hbs , tp , mi_row + hbs , mi_col + hbs , subsize , output_enabled , dummy_cost , pc_tree -> split [ 3 ] ) ; } break ; default : assert ( 0 && "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; break ; } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cpi , const TileInfo * const tile , MACROBLOCKD * const xd , <S2SV_ModStart> * const cm = & cpi -> common ; MODE_INFO * * mi <S2SV_ModEnd> = xd -> mi ; const int left_in_image = <S2SV_ModStart> ; const int left_in_image = xd -> left_available && mi <S2SV_ModEnd> [ - 1 ] ; const int above_in_image = <S2SV_ModStart> ; const int above_in_image = xd -> up_available && mi [ - xd -> mi_stride ] ; const <S2SV_ModEnd> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_ModStart> int row8x8_remaining = tile -> mi_row_end - mi_row ; const <S2SV_ModStart> BLOCK_SIZE min_size = BLOCK_4X4 ; BLOCK_SIZE max_size = BLOCK_64X64 ; int bs_hist [ BLOCK_SIZES ] = { 0 } <S2SV_ModStart> -> frame_type != KEY_FRAME ) { MODE_INFO * * <S2SV_ModEnd> prev_mi = & cm -> prev_mi_grid_visible [ mi_row * <S2SV_ModStart> xd -> mi_stride + mi_col ] ; get_sb_partition_size_range ( xd , prev_mi , & min_size , & max_size , bs_hist ) ; } if ( left_in_image ) { MODE_INFO * * left_sb64_mi = & mi [ - MI_BLOCK_SIZE ] ; get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist ) ; } if ( above_in_image ) { MODE_INFO * * above_sb64_mi = & mi <S2SV_ModEnd> [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; <S2SV_ModStart> xd -> mi_stride * MI_BLOCK_SIZE ] ; get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; } if ( cpi -> sf . <S2SV_ModStart> col8x8_remaining , & bh , & bw ) ; if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { min_size = BLOCK_4X4 ; } else { min_size = MIN ( cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ; } <S2SV_ModEnd> if ( cpi -> sf . use_square_partition_only && next_square_size
<S2SV_ModStart> <S2SV_null> static void rd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA * * tp , int mi_row , <S2SV_ModStart> int mi_row , int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON * const cm = & cpi <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> tp_orig = * tp ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none <S2SV_ModEnd> ; int i , pl ; BLOCK_SIZE subsize ; <S2SV_ModStart> ; int i , pl ; BLOCK_SIZE subsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int do_split = bsize >= BLOCK_8X8 ; int <S2SV_ModStart> e_mbd . plane [ 1 ] . subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart> >= BLOCK_8X8 ; ( void ) * tp_orig ; <S2SV_ModEnd> assert ( num_8x8_blocks_wide_lookup [ bsize ] == num_8x8_blocks_high_lookup [ <S2SV_ModStart> bsize ] == num_8x8_blocks_high_lookup [ bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> x -> mb_energy = vp9_block_energy ( cpi , x <S2SV_ModStart> vp9_block_energy ( cpi , x , bsize ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> ) ; } if ( cpi -> sf . <S2SV_ModStart> . auto_min_max_partition_size ) { partition_none_allowed &= ( bsize <= max_size && bsize >= min_size ) ; partition_horz_allowed &= ( ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_horz_split ) ; partition_vert_allowed &= ( ( <S2SV_ModStart> force_horz_split ) ; partition_vert_allowed &= ( ( bsize <= max_size && bsize > min_size <S2SV_ModEnd> ) || force_vert_split ) ; do_split &= bsize > <S2SV_ModStart> ) || force_vert_split ) ; do_split &= bsize > min_size <S2SV_ModEnd> ; } if ( cpi -> sf . use_square_partition_only <S2SV_ModStart> force_horz_split ; partition_vert_allowed &= force_vert_split ; } save_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> l , sa , sl , bsize ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed = 0 ; } } # endif <S2SV_ModEnd> if ( partition_none_allowed ) { rd_pick_sb_modes ( cpi , <S2SV_ModStart> if ( partition_none_allowed ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX ) { if ( bsize >= BLOCK_8X8 <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_NONE ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost ) { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> >>= 8 - ( b_width_log2_lookup [ bsize ] + <S2SV_ModStart> bsize ] + b_height_log2_lookup [ bsize ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> ) { do_split = 0 ; do_rect = 0 <S2SV_ModStart> 0 ; do_rect = 0 ; } } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> for ( i = 0 ; i < 4 <S2SV_ModStart> ( i = 0 ; i < 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ i ) { const int x_idx = <S2SV_ModStart> + x_idx >= cm -> mi_cols ) continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i ; rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp , mi_row + y_idx , mi_col + <S2SV_ModStart> y_idx , mi_col + x_idx , subsize , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate == INT_MAX ) { sum_rdc . rdcost = INT64_MAX ; break ; } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && i == 4 ) { pl = partition_plane_context <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } } else { if ( cpi -> <S2SV_ModStart> ) do_rect &= ! partition_none_allowed ; } restore_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> , bsize ) ; } if ( partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> ) { subsize = get_subsize ( bsize , PARTITION_HORZ <S2SV_ModStart> { subsize = get_subsize ( bsize , PARTITION_HORZ ) <S2SV_ModEnd> ; if ( cpi -> sf . adaptive_motion_search ) <S2SV_ModStart> . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost && mi_row + mi_step < cm -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> ; if ( cpi -> sf . adaptive_motion_search ) <S2SV_ModStart> . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx -> mic . mbmi . interp_filter <S2SV_ModStart> . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + mi_step , mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate == INT_MAX ) { sum_rdc . rdcost = INT64_MAX ; } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize = get_subsize ( bsize , PARTITION_VERT ) <S2SV_ModEnd> ; if ( cpi -> sf . adaptive_motion_search ) <S2SV_ModStart> . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost && mi_col + mi_step < cm -> mi_cols && bsize > BLOCK_8X8 ) { update_state ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> ; if ( cpi -> sf . adaptive_motion_search ) <S2SV_ModStart> . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> pred_interp_filter = ctx -> mic . mbmi . interp_filter <S2SV_ModStart> . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + mi_step , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate == INT_MAX ) { sum_rdc . rdcost = INT64_MAX ; } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate < INT_MAX && best_rdc . dist < INT64_MAX && pc_tree -> index != 3 <S2SV_ModEnd> ) { int output_enabled = ( bsize == BLOCK_64X64 <S2SV_ModStart> int output_enabled = ( bsize == BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; } if ( bsize == BLOCK_64X64 ) <S2SV_ModStart> ( tp_orig < * tp ) ; assert ( best_rdc . rate < INT_MAX ) ; assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX ) ; } else { assert (
<S2SV_ModStart> <S2SV_null> static void rd_pick_sb_modes ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD * const xd = & x -> <S2SV_ModStart> oxcf . aq_mode ; int i , orig_rdmult ; vpx_clear_system_state ( ) ; x -> use_lp32x32fdct = 1 ; set_offsets ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , mi_col , bsize ) ; mbmi <S2SV_ModStart> ] ; } ctx -> is_coded = 0 ; ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ; <S2SV_ModStart> = 0 ; mbmi -> skip = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> source_variance = vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult <S2SV_ModEnd> ; if ( aq_mode == VARIANCE_AQ ) { const <S2SV_ModStart> : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , map , bsize , mi_row , <S2SV_ModStart> , bsize , mi_row , mi_col ) ; } x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; } else if ( aq_mode == COMPLEXITY_AQ <S2SV_ModStart> } else if ( aq_mode == COMPLEXITY_AQ ) { x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; } else if ( aq_mode == CYCLIC_REFRESH_AQ <S2SV_ModStart> -> segmentation_map : cm -> last_frame_seg_map ; if ( cyclic_refresh_segment_id_boosted ( get_segment_id <S2SV_ModEnd> ( cm , map , bsize , mi_row , <S2SV_ModStart> map , bsize , mi_row , mi_col ) ) ) <S2SV_ModStart> ) ) { vp9_rd_pick_intra_mode_sb ( cpi , x , rd_cost <S2SV_ModEnd> , bsize , ctx , best_rd ) ; } <S2SV_ModStart> } else { if ( bsize >= BLOCK_8X8 ) { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else vp9_rd_pick_inter_mode_sb ( cpi , tile_data , x , mi_row , mi_col , rd_cost , bsize , ctx , best_rd ) ; } else { vp9_rd_pick_inter_mode_sub8x8 ( cpi , tile_data , x , mi_row , mi_col , rd_cost <S2SV_ModEnd> , bsize , ctx , best_rd ) ; } <S2SV_ModStart> , bsize , ctx , best_rd ) ; } } if ( ( rd_cost -> rate != INT_MAX ) && ( aq_mode == COMPLEXITY_AQ ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void rd_use_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO * * mi_8x8 , TOKENEXTRA * * <S2SV_ModStart> * rate , int64_t * dist , int do_recon , PC_TREE * pc_tree <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> = cm -> mi_stride ; const int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] <S2SV_ModStart> [ 8 ] , sa [ 8 ] ; RD_COST last_part_rdc , none_rdc , chosen_rdc <S2SV_ModEnd> ; BLOCK_SIZE sub_subsize = BLOCK_4X4 ; int splits_below = <S2SV_ModStart> mbmi . sb_type ; int do_partition_search = 1 ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; <S2SV_ModStart> bsize ] == num_4x4_blocks_high_lookup [ bsize ] ) ; vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ; <S2SV_ModStart> subsize = get_subsize ( bsize , partition ) ; pc_tree -> partitioning = partition ; save_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> , bsize ) ; if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) { set_offsets ( cpi , tile_info , x <S2SV_ModEnd> , mi_row , mi_col , bsize ) ; x <S2SV_ModStart> vp9_block_energy ( cpi , x , bsize ) ; <S2SV_ModEnd> } if ( do_partition_search && cpi -> sf . <S2SV_ModStart> >> 1 ) < cm -> mi_cols ) { pc_tree -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX ) ; pl = partition_plane_context ( xd <S2SV_ModStart> mi_row , mi_col , bsize ) ; if ( none_rdc . rate < INT_MAX ) { none_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_NONE ] ; none_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , none_rdc . rate , none_rdc . dist ) ; } restore_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> 0 ] -> mbmi . sb_type = bs_type ; pc_tree -> partitioning = partition <S2SV_ModEnd> ; } } switch ( partition ) { case <S2SV_ModStart> ) { case PARTITION_NONE : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX ) ; break ; case PARTITION_HORZ : <S2SV_ModStart> , INT64_MAX ) ; break ; case PARTITION_HORZ : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] , INT64_MAX ) ; if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX && bsize >= BLOCK_8X8 && mi_row + <S2SV_ModStart> >> 1 ) < cm -> mi_rows ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) ; update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) ; rd_pick_sb_modes ( cpi , tile_data , x <S2SV_ModEnd> , mi_row + ( mi_step >> 1 ) , <S2SV_ModStart> ( mi_step >> 1 ) , mi_col , & tmp_rdc , subsize , & pc_tree -> horizontal [ 1 ] , INT64_MAX ) ; if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) ; break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost ; } break ; case PARTITION_VERT : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ] , INT64_MAX ) ; if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX && bsize >= BLOCK_8X8 && mi_col + <S2SV_ModStart> >> 1 ) < cm -> mi_cols ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) ; update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) ; rd_pick_sb_modes ( cpi , tile_data , x <S2SV_ModEnd> , mi_row , mi_col + ( mi_step >> 1 <S2SV_ModStart> mi_col + ( mi_step >> 1 ) , & tmp_rdc , subsize , & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , INT64_MAX ) ; if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) ; break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost ; } break ; case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost <S2SV_ModEnd> = 0 ; for ( i = 0 ; <S2SV_ModStart> >> 1 , ii = i & 0x01 ; RD_COST tmp_rdc <S2SV_ModEnd> ; if ( ( mi_row + y_idx >= cm <S2SV_ModStart> x_idx >= cm -> mi_cols ) ) continue ; vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & tmp_rdc . rate , & tmp_rdc . dist , i != 3 , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { vp9_rd_cost_reset ( & last_part_rdc ) ; break ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; } break ; default : assert ( 0 <S2SV_ModStart> break ; default : assert ( 0 ) ; break ; <S2SV_ModStart> mi_row , mi_col , bsize ) ; if ( last_part_rdc . rate < INT_MAX ) { last_part_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ partition ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ partition ] ; last_part_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , last_part_rdc . rate , last_part_rdc . dist <S2SV_ModEnd> ) ; } if ( do_partition_search && cpi -> <S2SV_ModStart> split_subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; chosen_rdc . rate = 0 ; chosen_rdc . dist = 0 ; restore_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> , l , sa , sl , bsize ) ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModStart> 1 ) * ( mi_step >> 1 ) ; RD_COST tmp_rdc <S2SV_ModEnd> ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , <S2SV_ModStart> x_idx >= cm -> mi_cols ) ) continue ; save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> l , sa , sl , bsize ) ; if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { vp9_rd_cost_reset ( & chosen_rdc ) ; break ; } chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; if ( i != 3 ) encode_sb ( <S2SV_ModStart> ( i != 3 ) encode_sb ( cpi , td , tile_info <S2SV_ModEnd> , tp , mi_row + y_idx , mi_col + <S2SV_ModStart> y_idx , mi_col + x_idx , 0 , split_subsize , pc_tree -> split [ i ] <S2SV_ModStart> y_idx , mi_col + x_idx , split_subsize ) ; chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_ModStart> mi_row , mi_col , bsize ) ; if ( chosen_rdc . rate < INT_MAX ) { chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_ModStart> -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; chosen_rdc . rdcost <S2SV_ModEnd> = RDCOST ( x -> rdmult , x -> <S2SV_ModStart> ( x -> rdmult , x -> rddiv , chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> ) { mi_8x8 [ 0 ] -> mbmi . <S2SV_ModStart> = bsize ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost ) { if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc ; } restore_context ( x <S2SV_ModEnd> , mi_row , mi_col , a , l , <S2SV_ModStart> ; if ( bsize == BLOCK_64X64 ) assert ( chosen_rdc . rate < INT_MAX && chosen_rdc . dist <S2SV_ModEnd> < INT64_MAX ) ; if ( do_recon ) { <S2SV_ModStart> int output_enabled = ( bsize == BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate ; * dist = chosen_rdc . dist <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void restore_context ( MACROBLOCK * const x <S2SV_ModEnd> , int mi_row , int mi_col , ENTROPY_CONTEXT a <S2SV_ModStart> sl [ 8 ] , BLOCK_SIZE bsize ) { <S2SV_ModEnd> MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModStart> ; p < MAX_MB_PLANE ; p ++ ) { memcpy <S2SV_ModEnd> ( xd -> above_context [ p ] + ( <S2SV_ModStart> -> plane [ p ] . subsampling_x ) ; memcpy <S2SV_ModEnd> ( xd -> left_context [ p ] + ( <S2SV_ModStart> plane [ p ] . subsampling_y ) ; } memcpy <S2SV_ModEnd> ( xd -> above_seg_context + mi_col , sa , <S2SV_ModStart> * xd -> above_seg_context ) * mi_width ) ; memcpy <S2SV_ModEnd> ( xd -> left_seg_context + ( mi_row & MI_MASK
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void save_context ( MACROBLOCK * const x <S2SV_ModEnd> , int mi_row , int mi_col , ENTROPY_CONTEXT a <S2SV_ModStart> [ 8 ] , BLOCK_SIZE bsize ) { const <S2SV_ModEnd> MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModStart> ; p < MAX_MB_PLANE ; ++ p ) { memcpy <S2SV_ModEnd> ( a + num_4x4_blocks_wide * p , xd -> <S2SV_ModStart> -> plane [ p ] . subsampling_x ) ; memcpy <S2SV_ModEnd> ( l + num_4x4_blocks_high * p , xd -> <S2SV_ModStart> plane [ p ] . subsampling_y ) ; } memcpy <S2SV_ModEnd> ( sa , xd -> above_seg_context + mi_col , <S2SV_ModStart> * xd -> above_seg_context ) * mi_width ) ; memcpy <S2SV_ModEnd> ( sl , xd -> left_seg_context + ( mi_row
<S2SV_ModStart> <S2SV_null> static TX_MODE select_tx_mode ( const VP9_COMP * cpi , MACROBLOCKD * const xd ) { if ( xd -> lossless ) return ONLY_4X4 ; if ( cpi -> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL <S2SV_ModStart> ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) return ALLOW_32X32 ; <S2SV_ModEnd> else if ( cpi -> sf . tx_size_search_method == <S2SV_ModStart> if ( cpi -> sf . tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ; else return cpi -> common . tx_mode ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> static void set_block_size ( VP9_COMP * const cpi , MACROBLOCK * const x , MACROBLOCKD * const xd <S2SV_ModEnd> , int mi_row , int mi_col , BLOCK_SIZE bsize <S2SV_ModStart> cpi -> common . mi_rows > mi_row ) { set_mode_info_offsets ( & cpi -> common , x <S2SV_ModEnd> , xd , mi_row , mi_col ) ; xd <S2SV_ModStart> 0 ] -> mbmi . sb_type = bsize ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; const int mis = cm -> mi_stride ; const <S2SV_ModStart> int row8x8_remaining = tile -> mi_row_end - mi_row ; const <S2SV_ModStart> sb_type = bsize ; } } } else { set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cpi , const TileInfo * const tile , MACROBLOCK * const x , <S2SV_ModStart> mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_ModEnd> VP9_COMMON * const cm = & cpi -> common <S2SV_ModStart> int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; const <S2SV_ModEnd> struct segmentation * const seg = & cm -> <S2SV_ModStart> set_skip_context ( xd , mi_row , mi_col ) ; set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd , mi_row , mi_col ) ; mbmi <S2SV_ModStart> [ 0 ] -> mbmi ; vp9_setup_dst_planes ( xd -> plane <S2SV_ModStart> mi_col ) ; x -> rddiv = cpi -> rd . RDDIV ; x -> rdmult = cpi -> rd . <S2SV_ModEnd> RDMULT ; if ( seg -> enabled ) { <S2SV_ModStart> : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id <S2SV_ModEnd> ( cm , map , bsize , mi_row , <S2SV_ModStart> x -> encode_breakout = cpi -> encode_breakout ; } xd -> tile = * tile ;
<S2SV_ModStart> * cpi , const TileInfo * const tile , MACROBLOCK * const x , <S2SV_ModStart> * const cm = & cpi -> common ; const int mis = cm -> mi_stride ; const <S2SV_ModEnd> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_ModStart> int row8x8_remaining = tile -> mi_row_end - mi_row ; const <S2SV_ModStart> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_ModEnd> MODE_INFO * mi_upper_left = cm -> mi + mi_row <S2SV_ModStart> cm -> mi + mi_row * mis + mi_col ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) <S2SV_ModStart> ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { int i , j ; int index ; diff d32 [ 4 ] ; const int offset = ( mi_row >> 1 ) * cm -> mb_cols + ( mi_col >> 1 ) ; int is_larger_better = 0 ; int use32x32 = 0 ; unsigned int thr = cpi -> source_var_thresh ; memset ( d32 , 0 , 4 * sizeof ( diff ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { diff * d16 [ 4 ] ; for ( j = 0 ; j < 4 ; j ++ ) { int b_mi_row = coord_lookup [ i * 4 + j ] . row ; int b_mi_col = coord_lookup [ i * 4 + j ] . col ; int boffset = b_mi_row / 2 * cm -> mb_cols + b_mi_col / 2 ; d16 [ j ] = cpi -> source_diff_var + offset + boffset ; index = b_mi_row * mis + b_mi_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ; } is_larger_better = ( d16 [ 0 ] -> var < thr ) && ( d16 [ 1 ] -> var < thr ) && ( d16 [ 2 ] -> var < thr ) && ( d16 [ 3 ] -> var < thr ) ; if ( is_larger_better ) { use32x32 += 1 ; for ( j = 0 ; j < 4 ; j ++ ) { d32 [ i ] . sse += d16 [ j ] -> sse ; d32 [ i ] . sum += d16 [ j ] -> sum ; } d32 [ i ] . var = d32 [ i ] . sse - ( ( ( <S2SV_ModEnd> int64_t ) d32 [ i ] . sum * <S2SV_ModStart> index ] -> mbmi . sb_type = BLOCK_32X32 ; } } if ( use32x32 == 4 ) { thr <<= 1 ; is_larger_better = ( d32 [ 0 ] . var < thr ) && ( d32 [ 1 ] . var < thr ) && ( d32 [ 2 ] . var < thr ) && ( d32 [ 3 ] . var < thr ) ; if ( is_larger_better ) { mi_8x8 [ 0 ] = mi_upper_left ; mi_8x8 [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; } } } else { int bh = num_8x8_blocks_high_lookup [ BLOCK_16X16 ] ; int bw = num_8x8_blocks_wide_lookup [ BLOCK_16X16 ] ; set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , BLOCK_16X16 , mi_8x8 ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int set_vt_partitioning ( VP9_COMP * cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , void * data , <S2SV_ModEnd> BLOCK_SIZE bsize , int mi_row , int mi_col , <S2SV_ModStart> BLOCK_SIZE bsize , int mi_row , int mi_col , int64_t threshold , BLOCK_SIZE bsize_min , int force_split <S2SV_ModEnd> ) { VP9_COMMON * const cm = & cpi <S2SV_ModStart> int block_height = num_8x8_blocks_high_lookup [ bsize ] ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) <S2SV_ModEnd> ; assert ( block_height == block_width ) ; tree_to_node <S2SV_ModStart> , bsize , & vt ) ; if ( force_split == 1 ) return 0 ; if ( bsize == bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( <S2SV_ModStart> variance < threshold ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } return 0 ; } else if ( bsize > bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( cm -> frame_type == KEY_FRAME && ( bsize > BLOCK_32X32 || vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { return 0 ; } if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_ModEnd> mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModStart> < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModEnd> ) { BLOCK_SIZE subsize = get_subsize ( bsize , <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_VERT ) ; get_variance ( & vt . part_variances -> vert [ 0 ] ) ; get_variance ( & vt . part_variances -> vert [ 1 ] ) ; if ( vt . part_variances -> vert [ 0 ] . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row , mi_col , subsize ) ; set_block_size <S2SV_ModStart> mi_col , subsize ) ; set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row , mi_col + block_width / 2 , <S2SV_ModStart> 2 , subsize ) ; return 1 ; } } <S2SV_ModStart> mi_col + block_width / 2 < cm -> mi_cols <S2SV_ModEnd> ) { BLOCK_SIZE subsize = get_subsize ( bsize , <S2SV_ModStart> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; get_variance ( & vt . part_variances -> horz [ 0 ] ) ; get_variance ( & vt . part_variances -> horz [ 1 ] ) ; if ( vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row , mi_col , subsize ) ; set_block_size <S2SV_ModStart> mi_col , subsize ) ; set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row + block_height / 2 , mi_col , <S2SV_ModStart> mi_col , subsize ) ; return 1 ; } } return 0 ; }
<S2SV_ModStart> MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { memcpy <S2SV_ModEnd> ( ctx -> pred_mv , x -> pred_mv ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> var * b , var * r ) { assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> -> sum_error + b -> sum_error , a -> log2_count + 1 <S2SV_ModEnd> , r ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> counts , const MODE_INFO * mi ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = mi -> mbmi . mode ; const <S2SV_ModStart> y_mode = mi -> mbmi . mode ; const PREDICTION_MODE <S2SV_ModEnd> uv_mode = mi -> mbmi . uv_mode ; const
<S2SV_ModStart> , variance_node * node ) { int i ; node -> part_variances = NULL ; <S2SV_ModStart> ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] <S2SV_ModStart> } default : { assert ( 0 ) ; break ;
<S2SV_ModStart> <S2SV_null> static void update_state ( VP9_COMP * cpi , ThreadData * td , <S2SV_ModStart> * const cm = & cpi -> common ; RD_COUNTS * const rdc = & td -> rd_counts ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> segmentation * const seg = & cm -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <S2SV_ModStart> bsize ) ; * mi_addr = * mi ; * x -> mbmi_ext = ctx -> mbmi_ext ; if ( seg -> enabled <S2SV_ModEnd> ) { if ( cpi -> oxcf . aq_mode <S2SV_ModStart> -> last_frame_seg_map ; mi_addr -> mbmi . segment_id = get_segment_id <S2SV_ModEnd> ( cm , map , bsize , mi_row , <S2SV_ModStart> , bsize , mi_row , mi_col ) ; } <S2SV_ModEnd> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ <S2SV_ModStart> -> mbmi , mi_row , mi_col , bsize , ctx -> rate , ctx -> dist , x -> skip <S2SV_ModEnd> ) ; } } max_plane = is_inter_block ( mbmi <S2SV_ModStart> vp9_init_plane_quantizers ( cpi , x ) ; if ( <S2SV_ModEnd> is_inter_block ( mbmi ) && mbmi -> sb_type < <S2SV_ModStart> } x -> skip = ctx -> skip ; memcpy <S2SV_ModEnd> ( x -> zcoeff_blk [ mbmi -> tx_size ] <S2SV_ModStart> tx_size ] , ctx -> zcoeff_blk , sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * ctx -> num_4x4_blk ) ; if ( <S2SV_ModStart> ) ; if ( ! output_enabled ) return ; <S2SV_ModEnd> # if CONFIG_INTERNAL_STATS if ( frame_is_intra_only ( cm ) <S2SV_ModStart> ( is_inter_block ( mbmi ) ) { vp9_update_mv_count ( td <S2SV_ModEnd> ) ; if ( cm -> interp_filter == SWITCHABLE <S2SV_ModStart> int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; ++ td -> counts -> <S2SV_ModEnd> switchable_interp [ ctx ] [ mbmi -> interp_filter ] <S2SV_ModStart> ] [ mbmi -> interp_filter ] ; } } rdc -> comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ; rdc -> comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; rdc -> comp_pred_diff <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; for <S2SV_ModStart> 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) rdc -> filter_diff <S2SV_ModEnd> [ i ] += ctx -> best_filter_diff [ i <S2SV_ModStart> += ctx -> best_filter_diff [ i ] ; } for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } }
<S2SV_ModStart> <S2SV_null> static void update_state_rt ( VP9_COMP * cpi , ThreadData * td , <S2SV_ModStart> -> common ; MACROBLOCK * const x = & td <S2SV_ModEnd> -> mb ; MACROBLOCKD * const xd = & <S2SV_ModStart> MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * const mi = xd -> mi [ 0 ] <S2SV_ModStart> * const seg = & cm -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; <S2SV_ModStart> [ 0 ] ) = ctx -> mic ; * ( x -> mbmi_ext ) = ctx -> mbmi_ext ; if ( seg -> enabled && cpi -> oxcf . aq_mode ) { if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ || cpi -> oxcf . aq_mode == VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; } else { vp9_cyclic_refresh_update_segment ( cpi , mbmi , mi_row , mi_col , bsize , ctx -> rate , ctx -> dist , x -> skip ) ; } <S2SV_ModEnd> vp9_init_plane_quantizers ( cpi , x ) ; } if <S2SV_ModStart> ( is_inter_block ( mbmi ) ) { vp9_update_mv_count ( td <S2SV_ModEnd> ) ; if ( cm -> interp_filter == SWITCHABLE <S2SV_ModStart> int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ; ++ td -> counts -> <S2SV_ModEnd> switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] <S2SV_ModStart> pred_ctx ] [ mbmi -> interp_filter ] ; } if ( mbmi -> sb_type < BLOCK_8X8 ) { mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; } } if ( cm -> use_prev_frame_mvs ) { MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h ; for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } <S2SV_ModStart> } x -> skip = ctx -> skip ; x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void update_stats ( VP9_COMMON * cm , ThreadData * td ) { const MACROBLOCK * x = & td <S2SV_ModEnd> -> mb ; const MACROBLOCKD * const xd = <S2SV_ModStart> * const mbmi = & mi -> mbmi ; const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_ModStart> if ( ! frame_is_intra_only ( cm ) ) { FRAME_COUNTS * const counts = td -> counts ; const int inter_block = is_inter_block ( mbmi ) ; const int seg_ref_active = segfeature_active <S2SV_ModEnd> ( & cm -> seg , mbmi -> segment_id <S2SV_ModStart> SEG_LVL_REF_FRAME ) ; if ( ! seg_ref_active ) { <S2SV_ModEnd> counts -> intra_inter [ vp9_get_intra_inter_context ( xd ) ] <S2SV_ModStart> ref0 != GOLDEN_FRAME ] ++ ; } } } if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; if ( bsize >= BLOCK_8X8 ) { const PREDICTION_MODE mode = mbmi -> mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int j = idy * 2 + idx ; const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; } } } }
<S2SV_ModStart> cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) { cpi -> allow_comp_inter_inter = 0 ; } else { cpi <S2SV_ModEnd> -> allow_comp_inter_inter = 1 ; cm -> comp_fixed_ref = <S2SV_ModStart> cpi -> sf . frame_parameter_update ) { int i ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; int64_t * const mode_thrs = rd_opt -> prediction_type_threshes [ frame_type ] ; int64_t * const filter_thrs = rd_opt -> filter_threshes [ frame_type ] ; const int is_alt_ref = frame_type == ALTREF_FRAME ; if ( is_alt_ref || ! cpi <S2SV_ModEnd> -> allow_comp_inter_inter ) cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_ModStart> cm -> reference_mode = SINGLE_REFERENCE ; else if ( mode_thrs [ COMPOUND_REFERENCE ] > mode_thrs [ SINGLE_REFERENCE ] && mode_thrs [ COMPOUND_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] && check_dual_ref_flags ( cpi ) && <S2SV_ModStart> cm -> reference_mode = COMPOUND_REFERENCE ; else if ( mode_thrs [ SINGLE_REFERENCE ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT ] ) cm -> reference_mode = SINGLE_REFERENCE <S2SV_ModStart> ; if ( cm -> interp_filter == SWITCHABLE ) cm -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> encode_frame_internal ( cpi ) ; for ( i = <S2SV_ModStart> 0 ; i < REFERENCE_MODES ; ++ i ) mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff [ i ] / cm -> MBs ) / 2 ; <S2SV_ModEnd> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS <S2SV_ModStart> ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff [ i ] / cm -> MBs ) / 2 ; <S2SV_ModEnd> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_ModStart> < COMP_INTER_CONTEXTS ; i ++ ) { single_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i ] [ 0 ] ; comp_count_zero <S2SV_ModStart> [ i ] [ 0 ] ; comp_count_zero += counts -> <S2SV_ModEnd> comp_inter [ i ] [ 1 ] ; } <S2SV_ModStart> { cm -> reference_mode = SINGLE_REFERENCE ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; } else if ( single_count_zero == <S2SV_ModStart> { cm -> reference_mode = COMPOUND_REFERENCE ; vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) ; } } if ( cm -> <S2SV_ModStart> < TX_SIZE_CONTEXTS ; ++ i ) { count4x4 += counts -> <S2SV_ModEnd> tx . p32x32 [ i ] [ TX_4X4 ] <S2SV_ModStart> [ i ] [ TX_4X4 ] ; count4x4 += counts -> <S2SV_ModEnd> tx . p16x16 [ i ] [ TX_4X4 ] <S2SV_ModStart> [ i ] [ TX_4X4 ] ; count4x4 += counts -> <S2SV_ModEnd> tx . p8x8 [ i ] [ TX_4X4 ] <S2SV_ModStart> [ i ] [ TX_4X4 ] ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p32x32 [ i ] [ TX_8X8 ] <S2SV_ModStart> [ i ] [ TX_8X8 ] ; count8x8_lp += counts -> <S2SV_ModEnd> tx . p16x16 [ i ] [ TX_8X8 ] <S2SV_ModStart> [ i ] [ TX_8X8 ] ; count8x8_8x8p += counts -> <S2SV_ModEnd> tx . p8x8 [ i ] [ TX_8X8 ] <S2SV_ModStart> [ i ] [ TX_8X8 ] ; count16x16_16x16p += counts -> <S2SV_ModEnd> tx . p16x16 [ i ] [ TX_16X16 ] <S2SV_ModStart> [ i ] [ TX_16X16 ] ; count16x16_lp += counts -> <S2SV_ModEnd> tx . p32x32 [ i ] [ TX_16X16 ] <S2SV_ModStart> [ i ] [ TX_16X16 ] ; count32x32 += counts -> <S2SV_ModEnd> tx . p32x32 [ i ] [ TX_32X32 ] <S2SV_ModStart> 0 ) { cm -> tx_mode = ALLOW_8X8 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , TX_8X8 ) ; } else if <S2SV_ModStart> 0 ) { cm -> tx_mode = ONLY_4X4 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , TX_4X4 ) ; } else if <S2SV_ModStart> 0 ) { cm -> tx_mode = ALLOW_16X16 ; reset_skip_tx_size <S2SV_ModEnd> ( cm , TX_16X16 ) ; } } } <S2SV_ModStart> } else { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_ModEnd> encode_frame_internal ( cpi ) ; } } <S2SV_null> <S2SV_null>
<S2SV_ModStart> int mi_col ) { uint8_t * const buffers [ 3 <S2SV_ModEnd> ] = { src -> y_buffer , src -> <S2SV_ModStart> y_buffer , src -> u_buffer , src -> v_buffer } ; const int strides [ 3 <S2SV_ModEnd> ] = { src -> y_stride , src -> <S2SV_ModStart> y_stride , src -> uv_stride , src -> uv_stride <S2SV_ModEnd> } ; int i ; x -> e_mbd .
<S2SV_ModStart> = & xd -> plane [ plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff <S2SV_ModStart> ; } if ( ! x -> skip_recode ) { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> plane , block , plane_bsize , tx_size ) ; } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> skip_recode || ! x -> skip_optimize ) ) { const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> ; } else { * a = * l <S2SV_ModStart> eobs [ block ] == 0 ) return ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : vp9_highbd_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; break ; case TX_16X16 : vp9_highbd_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; break ; case TX_8X8 : vp9_highbd_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; break ; case TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; break ; default : assert ( 0 <S2SV_ModStart> : assert ( 0 && "Invalid<S2SV_blank>transform<S2SV_blank>size" ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && "Invalid<S2SV_blank>transform<S2SV_blank>size" ) ; break ; }
<S2SV_ModStart> = & xd -> plane [ plane ] ; tran_low_t <S2SV_ModEnd> * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff <S2SV_ModStart> p -> eobs [ block ] > 0 ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; return ; } # endif x <S2SV_ModEnd> -> itxm_add ( dqcoeff , dst , pd -> <S2SV_ModStart> , p -> eobs [ block ] ) ; }
<S2SV_ModStart> ( int rd_transform , const int16_t * src , tran_low_t <S2SV_ModEnd> * dst , int src_stride ) { if ( <S2SV_ModStart> , int src_stride ) { if ( rd_transform ) vpx_fdct32x32_rd <S2SV_ModEnd> ( src , dst , src_stride ) ; else <S2SV_ModStart> ( src , dst , src_stride ) ; else vpx_fdct32x32 <S2SV_ModEnd> ( src , dst , src_stride ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int optimize_b ( MACROBLOCK * mb , int plane , int block , TX_SIZE tx_size , int ctx <S2SV_ModEnd> ) { MACROBLOCKD * const xd = & mb <S2SV_ModStart> = & mb -> e_mbd ; struct macroblock_plane * const <S2SV_ModStart> -> plane [ plane ] ; struct macroblockd_plane * const <S2SV_ModStart> unsigned best_index [ 1025 ] [ 2 ] ; uint8_t token_cache [ 1024 ] ; const tran_low_t * const <S2SV_ModEnd> coeff = BLOCK_OFFSET ( mb -> plane [ plane <S2SV_ModStart> [ plane ] . coeff , block ) ; tran_low_t * const <S2SV_ModEnd> qcoeff = BLOCK_OFFSET ( p -> qcoeff , block <S2SV_ModStart> BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t * const <S2SV_ModEnd> dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block <S2SV_ModStart> BLOCK_OFFSET ( pd -> dqcoeff , block ) ; const <S2SV_ModStart> int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type <S2SV_ModEnd> ; const int default_eob = 16 << ( tx_size <S2SV_ModStart> = 1 + ( tx_size == TX_32X32 ) ; const int16_t * dequant_ptr = pd -> dequant ; const uint8_t * const band_translate = get_band_translate ( tx_size ) ; const scan_order * const so = get_scan ( xd , tx_size , type , block ) ; const int16_t * const scan = so -> scan ; const int16_t * const nb = so -> neighbors ; int next = eob , sz = 0 ; int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ; int64_t rd_cost0 , rd_cost1 ; int rate0 , rate1 , error0 , error1 ; int16_t t0 , t1 ; EXTRABIT e0 ; int best , band , pt , i , final_eob ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModEnd> assert ( ( ! type && ! plane ) <S2SV_ModStart> ) ; assert ( eob <= default_eob ) ; if ( ! ref <S2SV_ModEnd> ) rdmult = ( rdmult * 9 ) >> <S2SV_ModStart> = ( rdmult * 9 ) >> 4 ; <S2SV_ModEnd> tokens [ eob ] [ 0 ] . rate <S2SV_ModStart> ] [ 0 ] . qc = 0 ; tokens [ eob ] [ 1 ] = tokens [ eob ] [ 0 ] <S2SV_ModEnd> ; for ( i = 0 ; i < <S2SV_ModStart> [ scan [ i ] ] = vp9_pt_energy_class [ vp9_get_token ( qcoeff [ scan [ i ] ] ) <S2SV_ModEnd> ] ; for ( i = eob ; i <S2SV_ModStart> for ( i = eob ; i -- > 0 <S2SV_ModEnd> ; ) { int base_bits , d2 , dx <S2SV_ModStart> ) { int base_bits , d2 , dx ; const int rc = scan [ i ] ; int <S2SV_ModEnd> x = qcoeff [ rc ] ; if ( <S2SV_ModStart> [ next ] [ 1 ] . rate ; vp9_get_token_extra ( x , & t0 , & e0 ) <S2SV_ModEnd> ; if ( next < default_eob ) { band <S2SV_ModStart> ; best = rd_cost1 < rd_cost0 ; base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> ) ; dx = mul * ( dqcoeff [ <S2SV_ModStart> rc ] - coeff [ rc ] ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { dx >>= xd -> bd - 8 ; } # endif <S2SV_ModStart> . token == EOB_TOKEN ? EOB_TOKEN : ZERO_TOKEN ; e0 = 0 ; } else { vp9_get_token_extra ( x , & t0 , & e0 ) ; t1 = t0 <S2SV_ModEnd> ; } if ( next < default_eob ) { <S2SV_ModStart> ; best = rd_cost1 < rd_cost0 ; base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ; if ( shortcut ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { dx -= ( ( dequant_ptr [ rc != 0 ] >> ( xd -> bd - 8 ) ) + sz ) ^ sz ; } else { dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; } # else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; # endif <S2SV_ModEnd> d2 = dx * dx ; } tokens [ <S2SV_ModStart> band = band_translate [ i + 1 ] ; <S2SV_ModEnd> rate0 = tokens [ next ] [ 0 ] <S2SV_ModStart> ref ] [ band ] [ 0 ] [ ctx <S2SV_ModEnd> ] [ t0 ] ; rate1 += mb -> <S2SV_ModStart> ref ] [ band ] [ 0 ] [ ctx <S2SV_ModEnd> ] [ t1 ] ; UPDATE_RD_COST ( ) ; <S2SV_ModStart> ; best = rd_cost1 < rd_cost0 ; final_eob = - 1 ; memset <S2SV_ModEnd> ( qcoeff , 0 , sizeof ( * qcoeff <S2SV_ModStart> << ( tx_size * 2 ) ) ) ; memset <S2SV_ModEnd> ( dqcoeff , 0 , sizeof ( * dqcoeff <S2SV_ModStart> i < eob ; i = next ) { const int <S2SV_ModStart> tokens [ i ] [ best ] . qc ; const int rc = scan [ i ] <S2SV_ModStart> ( x ) { final_eob = i ; } <S2SV_ModEnd> qcoeff [ rc ] = x ; dqcoeff [ <S2SV_ModStart> ] . eobs [ block ] = final_eob ; return final_eob <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_encode_block_intra ( <S2SV_ModEnd> int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_ModStart> int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct encode_b_args * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; const scan_order * scan_order ; TX_TYPE tx_type = DCT_DCT ; PREDICTION_MODE mode ; const int bwl = b_width_log2_lookup [ plane_bsize ] ; const int diff_stride = 4 * ( 1 << bwl ) ; uint8_t * src , * dst ; int16_t * src_diff ; uint16_t * eob = & p -> eobs [ block ] ; const int src_stride = p -> src . stride ; const int dst_stride = pd -> dst . stride ; int i , j ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ; src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; if ( tx_size == TX_4X4 ) { tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ; scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ; } else { mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ; if ( tx_size == TX_32X32 ) { scan_order = & vp9_default_scan_orders [ TX_32X32 ] ; } else { tx_type = get_tx_type ( pd -> plane_type , xd ) ; scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ; } } vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) { x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } else { vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ; } } break ; default : assert ( 0 ) ; return ; } if ( * eob ) * ( args -> skip ) = 0 ; return ; } # endif switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ; else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ; } break ; default : assert ( 0 ) ; break ; } if ( * eob ) * ( args -> skip ) = 0 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , & mbmi -> skip } ; int plane ; mbmi -> skip = 1 ; if ( x -> skip ) return <S2SV_ModStart> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd
<S2SV_ModStart> bh = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ; return ; } # endif vpx_subtract_block <S2SV_ModEnd> ( bh , bw , p -> src_diff ,
<S2SV_ModStart> const scan_order = & vp9_default_scan_orders [ tx_size ] ; tran_low_t <S2SV_ModEnd> * const coeff = BLOCK_OFFSET ( p -> coeff <S2SV_ModStart> BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t <S2SV_ModEnd> * const qcoeff = BLOCK_OFFSET ( p -> qcoeff <S2SV_ModStart> BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff <S2SV_ModStart> ( j * diff_stride + i ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : highbd_fdct32x32 <S2SV_ModEnd> ( x -> use_lp32x32fdct , src_diff , coeff , <S2SV_ModStart> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> ( coeff , 1024 , x -> skip_block , <S2SV_ModStart> quant_shift , qcoeff , dqcoeff , pd -> dequant <S2SV_ModEnd> , eob , scan_order -> scan , scan_order -> <S2SV_ModStart> -> iscan ) ; break ; case TX_16X16 : vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , 256 , x -> skip_block , <S2SV_ModStart> quant_shift , qcoeff , dqcoeff , pd -> dequant <S2SV_ModEnd> , eob , scan_order -> scan , scan_order -> <S2SV_ModStart> -> iscan ) ; break ; case TX_8X8 : vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , 64 , x -> skip_block , <S2SV_ModStart> quant_shift , qcoeff , dqcoeff , pd -> dequant <S2SV_ModEnd> , eob , scan_order -> scan , scan_order -> <S2SV_ModStart> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , 16 , x -> skip_block , <S2SV_ModStart> , qcoeff , dqcoeff , pd -> dequant , <S2SV_ModEnd> eob , scan_order -> scan , scan_order -> iscan <S2SV_ModStart> ; break ; default : assert ( 0 ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_mv_component ( vpx_writer <S2SV_ModEnd> * w , int comp , const nmv_component * <S2SV_ModStart> 1 ; assert ( comp != 0 ) ; vpx_write <S2SV_ModEnd> ( w , sign , mvcomp -> sign ) <S2SV_ModStart> 0 ; i < n ; ++ i ) vpx_write <S2SV_ModEnd> ( w , ( d >> i ) & <S2SV_ModStart> [ fr ] ) ; if ( usehp ) vpx_write <S2SV_ModEnd> ( w , hp , mv_class == MV_CLASS_0 ?
<S2SV_ModStart> <S2SV_null> static void inc_mvs ( const MB_MODE_INFO * mbmi , const MB_MODE_INFO_EXT * mbmi_ext <S2SV_ModStart> i ) { const MV * ref = & mbmi_ext <S2SV_ModEnd> -> ref_mvs [ mbmi -> ref_frame [ i ]
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int update_mv ( vpx_writer <S2SV_ModEnd> * w , const unsigned int ct [ 2 <S2SV_ModStart> , const unsigned int ct [ 2 ] , vpx_prob * cur_p , vpx_prob upd_p ) { const vpx_prob <S2SV_ModEnd> new_p = get_binary_prob ( ct [ 0 ] , <S2SV_ModStart> vp9_cost_one ( upd_p ) + 7 * 256 ; vpx_write <S2SV_ModEnd> ( w , update , upd_p ) ; if <S2SV_ModStart> ( update ) { * cur_p = new_p ; vpx_write_literal <S2SV_ModEnd> ( w , new_p >> 1 , 7 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> void vp9_encode_mv ( VP9_COMP * cpi , vpx_writer <S2SV_ModEnd> * w , const MV * mv , const <S2SV_ModStart> [ 1 ] , usehp ) ; if ( cpi -> sf . mv <S2SV_ModEnd> . auto_mv_step_size ) { unsigned int maxv = MAX
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_entropy_mv_init ( void
<S2SV_ModStart> vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vpx_writer * w , nmv_context_counts * const counts <S2SV_ModEnd> ) { int i , j ; nmv_context * <S2SV_ModStart> nmv_context * const mvc = & cm -> fc -> nmvc <S2SV_ModEnd> ; write_mv_update ( vp9_mv_joint_tree , mvc -> joints ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void write_mv_update ( const vpx_tree_index * tree , vpx_prob <S2SV_ModEnd> probs [ ] , const unsigned int counts [ <S2SV_ModStart> unsigned int counts [ ] , int n , vpx_writer <S2SV_ModEnd> * w ) { int i ; unsigned int
<S2SV_ModStart> ; i < h ; i ++ ) { memset <S2SV_ModEnd> ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left <S2SV_ModStart> , src_ptr1 [ 0 ] , extend_left ) ; memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right <S2SV_ModStart> ; i < extend_top ; i ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr1 , src_ptr1 , linesize ) ; dst_ptr1 <S2SV_ModStart> ; i < extend_bottom ; i ++ ) { memcpy <S2SV_ModEnd> ( dst_ptr2 , src_ptr2 , linesize ) ; dst_ptr2
<S2SV_ModStart> ; const int el_y = 16 ; const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int eb_y = MAX ( src -> y_height + 16 , ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) ) - src -> y_crop_height <S2SV_ModEnd> ; const int uv_width_subsampling = ( src -> uv_width <S2SV_ModStart> int er_uv = er_y >> uv_width_subsampling ; # if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> # endif copy_and_extend_plane ( src -> y_buffer , src <S2SV_ModStart> -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height <S2SV_ModEnd> , et_y , el_y , eb_y , er_y ) <S2SV_ModStart> -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv , el_uv , eb_uv , er_uv ) <S2SV_ModStart> -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv , el_uv , eb_uv , er_uv )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void accumulate_frame_motion_stats ( const FIRSTPASS_STATS * stats , double * mv_in_out <S2SV_ModEnd> , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , <S2SV_ModStart> double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { const double pct = stats -> pcnt_motion ; * mv_in_out = stats -> mv_in_out_count * pct ; * mv_in_out_accumulator += * mv_in_out ; * abs_mv_in_out_accumulator += fabs ( * mv_in_out ) ; if ( pct > 0.05 ) { const double mvr_ratio = fabs ( stats -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( stats -> MVr ) ) ; const double mvc_ratio = fabs ( stats -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( stats -> MVc ) ) ; * mv_ratio_accumulator += pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats -> mvr_abs ) ; * mv_ratio_accumulator += pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats -> mvc_abs ) <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { section -> frame += frame -> frame ; section -> weight += frame -> weight <S2SV_ModStart> -> sr_coded_error += frame -> sr_coded_error ; section -> <S2SV_ModEnd> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion <S2SV_ModStart> pcnt_second_ref ; section -> pcnt_neutral += frame -> pcnt_neutral ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols
<S2SV_ModStart> int * f_boost , int * b_boost ) { TWO_PASS <S2SV_ModEnd> * const twopass = & cpi -> twopass ; <S2SV_ModStart> ; i < f_frames ; ++ i ) { const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL ) break ; accumulate_frame_motion_stats ( <S2SV_ModEnd> this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & <S2SV_ModStart> ( ! flash_detected ) { decay_accumulator *= get_prediction_decay_rate ( cpi , <S2SV_ModEnd> this_frame ) ; decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? <S2SV_ModStart> MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ; } boost_score += decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; } * f_boost = ( int ) <S2SV_ModStart> i >= - b_frames ; -- i ) { const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL ) break ; accumulate_frame_motion_stats ( <S2SV_ModEnd> this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & <S2SV_ModStart> ( ! flash_detected ) { decay_accumulator *= get_prediction_decay_rate ( cpi , <S2SV_ModEnd> this_frame ) ; decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? <S2SV_ModStart> MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ; } boost_score += decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; } * b_boost = ( int ) <S2SV_ModStart> ( b_frames + f_frames ) * 20 ) ; arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST ) ;
<S2SV_ModStart> , double pt_low , double pt_high , int q , vpx_bit_depth_t bit_depth <S2SV_ModStart> const double power_term = MIN ( vp9_convert_qindex_to_q ( q , bit_depth ) * 0.01 <S2SV_ModEnd> + pt_low , pt_high ) ; if ( power_term
<S2SV_ModStart> <S2SV_null> static double calc_frame_boost ( VP9_COMP * cpi , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out , double max_boost ) { double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += <S2SV_ModStart> / 2.0 ) ; return MIN ( frame_boost , max_boost * boost_q_correction <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> double calculate_modified_err ( const VP9_COMP * cpi , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const FIRSTPASS_STATS * this_frame ) { const FIRSTPASS_STATS * const stats = & twopass -> total_stats ; const double av_weight = stats -> weight / stats -> count ; const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double modified_error = av_err * pow ( this_frame -> coded_error * this_frame -> weight / DOUBLE_DIVIDE_CHECK ( av_err ) , oxcf -> two_pass_vbrbias / 100.0 ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION <S2SV_ModEnd> ) ; return fclamp ( modified_error , twopass ->
<S2SV_ModStart> VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModStart> * const rc = & cpi -> rc ; VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> * const oxcf = & cpi -> oxcf ; TWO_PASS <S2SV_ModEnd> * const twopass = & cpi -> twopass ; <S2SV_ModStart> twopass = & cpi -> twopass ; FIRSTPASS_STATS next_frame ; const FIRSTPASS_STATS * const start_pos = twopass -> stats_in <S2SV_ModEnd> ; int i ; double boost_score = 0.0 ; <S2SV_ModStart> old_boost_score = 0.0 ; double gf_group_err = 0.0 ; # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ; <S2SV_ModStart> ; double abs_mv_in_out_accumulator = 0.0 ; double mv_ratio_accumulator_thresh ; unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) { gf_group_err -= gf_first_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , cpi -> common . bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , cpi -> common . bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval <S2SV_ModEnd> ; if ( active_max_gf_interval > rc -> max_gf_interval ) <S2SV_ModStart> -> max_gf_interval ) active_max_gf_interval = rc -> max_gf_interval ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } } <S2SV_ModStart> ++ i ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_group_err += mod_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; <S2SV_ModEnd> if ( EOF == input_stats ( twopass , & <S2SV_ModStart> { last_loop_decay_rate = loop_decay_rate ; loop_decay_rate = get_prediction_decay_rate ( cpi <S2SV_ModEnd> , & next_frame ) ; decay_accumulator = decay_accumulator * <S2SV_ModStart> next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; if ( detect_transition_to_still ( cpi <S2SV_ModEnd> , i , 5 , loop_decay_rate , last_loop_decay_rate ) <S2SV_ModStart> = 0 ; break ; } } boost_score += <S2SV_ModEnd> decay_accumulator * calc_frame_boost ( cpi , & next_frame , <S2SV_ModStart> * calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ; if ( ( i >= ( active_max_gf_interval + arf_active_or_kf ) && zero_motion_accumulator < 0.995 ) || ( ( i >= active_min_gf_interval + arf_active_or_kf <S2SV_ModEnd> ) && ( ! flash_detected ) && ( ( <S2SV_ModStart> ) || ( ( boost_score - old_boost_score ) < BOOST_BREAKOUT <S2SV_ModEnd> ) ) ) ) { boost_score = old_boost_score ; <S2SV_ModStart> ( int ) ( zero_motion_accumulator * 1000.0 ) ; rc -> constrained_gf_group = ( i >= rc -> frames_to_key ) ? 1 : 0 ; if ( allow_alt_ref && ( i < cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { <S2SV_ModEnd> if ( EOF == input_stats ( twopass , this_frame <S2SV_ModStart> input_stats ( twopass , this_frame ) ) break ; gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; } rc -> baseline_gf_interval = new_gf_interval ; } rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1 ) ; } # endif gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if <S2SV_ModEnd> ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_ModStart> ( cpi -> common . frame_type != KEY_FRAME ) { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int detect_flash ( const TWO_PASS * twopass , int offset ) { const FIRSTPASS_STATS * const next_frame = read_frame_stats ( twopass , offset ) ; return next_frame != NULL && next_frame -> pcnt_second_ref > next_frame -> pcnt_inter && next_frame -> pcnt_second_ref >= 0.5 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int detect_transition_to_still ( VP9_COMP * cpi <S2SV_ModEnd> , int frame_interval , int still_interval , double loop_decay_rate <S2SV_ModStart> still_interval , double loop_decay_rate , double last_decay_rate ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; if ( frame_interval > rc -> min_gf_interval <S2SV_ModEnd> && loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) <S2SV_ModStart> 0.999 && last_decay_rate < 0.9 ) { int j <S2SV_ModEnd> ; for ( j = 0 ; j < <S2SV_ModStart> ; j < still_interval ; ++ j ) { const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; if ( stats >= twopass -> stats_in_end ) break ; if ( stats -> pcnt_inter - stats -> pcnt_motion < 0.999 ) break ; } return j == still_interval ; } return 0 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * const rc = & cpi -> rc ; TWO_PASS * const twopass = & cpi -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group ; const VP9EncoderConfig * const oxcf = & cpi -> oxcf <S2SV_ModEnd> ; const FIRSTPASS_STATS first_frame = * this_frame ; const <S2SV_ModStart> FIRSTPASS_STATS first_frame = * this_frame ; const FIRSTPASS_STATS * const <S2SV_ModStart> -> stats_in ; FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS last_frame ; int kf_bits = 0 ; int loop_decay_counter = 0 ; double decay_accumulator = 1.0 ; double av_decay_accumulator = 0.0 <S2SV_ModEnd> ; double zero_motion_accumulator = 1.0 ; double boost_score = <S2SV_ModStart> ; cpi -> common . frame_type = KEY_FRAME ; vp9_zero ( * gf_group ) ; <S2SV_ModStart> -> next_key_frame_forced ; rc -> source_alt_ref_active = 0 ; cpi -> multi_arf_last_grp_enabled = 0 ; <S2SV_ModStart> kf_group_error_left = 0 ; kf_mod_err = calculate_modified_err ( cpi , twopass , oxcf <S2SV_ModStart> while ( twopass -> stats_in < twopass -> stats_in_end && rc -> frames_to_key < cpi -> oxcf . key_freq ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModEnd> this_frame ) ; last_frame = * this_frame ; input_stats <S2SV_ModStart> ; if ( cpi -> oxcf . auto_key && twopass -> stats_in < twopass -> stats_in_end <S2SV_ModEnd> ) { double loop_decay_rate ; if ( test_candidate_kf ( <S2SV_ModStart> test_candidate_kf ( twopass , & last_frame , this_frame , twopass -> stats_in ) ) break ; loop_decay_rate = get_prediction_decay_rate ( cpi , twopass -> stats_in <S2SV_ModEnd> ) ; recent_loop_decay [ i % 8 ] = <S2SV_ModStart> recent_loop_decay [ j ] ; if ( detect_transition_to_still ( cpi , i , cpi -> oxcf . key_freq <S2SV_ModEnd> - i , loop_decay_rate , decay_accumulator ) ) break <S2SV_ModStart> ; if ( rc -> frames_to_key >= 2 * cpi -> oxcf . key_freq <S2SV_ModEnd> ) break ; } else { ++ rc -> <S2SV_ModStart> -> oxcf . auto_key && rc -> frames_to_key > cpi -> oxcf . key_freq <S2SV_ModEnd> ) { FIRSTPASS_STATS tmp_frame = first_frame ; rc -> <S2SV_ModStart> reset_fpf_position ( twopass , start_position ) ; kf_group_err = 0.0 <S2SV_ModEnd> ; for ( i = 0 ; i < <S2SV_ModStart> i ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModStart> if ( twopass -> stats_in == twopass -> stats_in_end || rc -> frames_to_key >= cpi -> oxcf . key_freq <S2SV_ModStart> rc -> next_key_frame_forced = 0 ; } if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_frame_to_key - rc -> frames_to_key ; ++ j ) { if ( EOF == input_stats ( twopass , this_frame ) ) break ; kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; } rc -> frames_to_key = new_frame_to_key ; } if ( twopass -> stats_in >= twopass -> stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModEnd> this_frame ) ; } if ( twopass -> bits_left <S2SV_ModStart> else { twopass -> kf_group_bits = 0 ; } twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; <S2SV_ModStart> ; for ( i = 0 ; i < ( rc -> frames_to_key - 1 ) <S2SV_ModEnd> ; ++ i ) { if ( EOF == <S2SV_ModStart> ( twopass , & next_frame ) ) break ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; if ( ( i <= rc -> max_gf_interval ) || ( ( i <= ( rc -> max_gf_interval * 4 ) ) && ( decay_accumulator > 0.5 ) ) ) { const double frame_boost = calc_frame_boost ( cpi , this_frame , 0 , KF_MAX_BOOST ) <S2SV_ModEnd> ; if ( ! detect_flash ( twopass , 0 <S2SV_ModStart> ) ) { const double loop_decay_rate = get_prediction_decay_rate ( cpi <S2SV_ModEnd> , & next_frame ) ; decay_accumulator *= loop_decay_rate ; <S2SV_ModStart> decay_accumulator = MAX ( decay_accumulator , MIN_DECAY_FACTOR ) ; av_decay_accumulator += decay_accumulator ; ++ loop_decay_counter ; } boost_score += ( decay_accumulator * frame_boost ) ; } } av_decay_accumulator /= ( double ) loop_decay_counter ; reset_fpf_position ( twopass , start_position ) ; twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 ) ; twopass -> section_intra_rating = calculate_section_intra_ratio ( start_position , twopass -> stats_in_end , rc -> frames_to_key ) ; rc -> kf_boost = ( int ) ( av_decay_accumulator * boost_score ) ; rc -> kf_boost = MAX ( rc -> kf_boost , ( rc -> frames_to_key * 3 ) ) ; rc -> kf_boost = MAX ( rc -> kf_boost , MIN_KF_BOOST ) ; kf_bits = calculate_boost_bits ( ( rc -> frames_to_key - 1 ) , rc -> kf_boost , twopass -> kf_group_bits ) ; if ( twopass -> kf_group_bits ) { twopass -> kfgroup_inter_fraction = ( double ) ( twopass -> kf_group_bits - kf_bits ) / ( double ) twopass -> kf_group_bits ; } else { twopass -> kfgroup_inter_fraction = 1.0 ; } twopass -> kf_group_bits -= kf_bits ; gf_group -> bit_allocation [ 0 ] = kf_bits ; gf_group -> update_type [ 0 ] = KF_UPDATE ; gf_group -> rf_level [ 0 ] = KF_STD ; <S2SV_ModEnd> twopass -> kf_group_error_left = ( int ) ( kf_group_err <S2SV_ModStart> kf_mod_err ) ; twopass -> modified_error_left -= kf_group_err ; if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED ; }
<S2SV_ModStart> 3 } ; int num00 , tmp_err , n <S2SV_ModEnd> ; const BLOCK_SIZE bsize = xd -> mi [ <S2SV_ModStart> v_fn_ptr = cpi -> fn_ptr [ bsize ] ; const int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const int sr = get_search_range ( cpi ) <S2SV_ModEnd> ; step_param += sr ; further_steps -= sr ; <S2SV_ModStart> v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & <S2SV_ModStart> x -> sadperbit16 , & num00 , & v_fn_ptr <S2SV_ModEnd> , ref_mv ) ; if ( tmp_err < INT_MAX <S2SV_ModStart> * best_motion_err ) { * best_motion_err = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } n = num00 ; num00 = 0 <S2SV_ModStart> tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & <S2SV_ModStart> x -> sadperbit16 , & num00 , & v_fn_ptr <S2SV_ModEnd> , ref_mv ) ; if ( tmp_err < INT_MAX <S2SV_ModStart> * best_motion_err ) { * best_motion_err = tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int frame_max_bits ( const RATE_CONTROL * rc , const VP9EncoderConfig <S2SV_ModEnd> * oxcf ) { int64_t max_bits = ( ( <S2SV_ModStart> int64_t max_bits = ( ( int64_t ) rc -> avg_frame_bandwidth <S2SV_ModEnd> * ( int64_t ) oxcf -> two_pass_vbrmax_section ) /
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static vpx_variance_fn_t <S2SV_ModEnd> get_block_variance_fn ( BLOCK_SIZE bsize ) { switch ( bsize <S2SV_ModStart> switch ( bsize ) { case BLOCK_8X8 : return vpx_mse8x8 ; case BLOCK_16X8 : return vpx_mse16x8 ; case BLOCK_8X16 : return vpx_mse8x16 ; default : return vpx_mse16x16 <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static double get_prediction_decay_rate ( const VP9_COMP * cpi <S2SV_ModEnd> , const FIRSTPASS_STATS * next_frame ) { const double <S2SV_ModStart> , const FIRSTPASS_STATS * next_frame ) { const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) ; const double zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int input_stats ( TWO_PASS <S2SV_ModEnd> * p , FIRSTPASS_STATS * fps ) { if
<S2SV_ModStart> "firstpass.stt" , "a" ) ; fprintf ( fpfile , "%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf" "%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf" "%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\n" , stats -> frame , stats -> weight <S2SV_ModEnd> , stats -> intra_error , stats -> coded_error , <S2SV_ModStart> intra_error , stats -> coded_error , stats -> sr_coded_error <S2SV_ModEnd> , stats -> pcnt_inter , stats -> pcnt_motion , <S2SV_ModStart> pcnt_motion , stats -> pcnt_second_ref , stats -> pcnt_neutral , stats -> intra_skip_pct , stats -> inactive_zone_rows , stats -> inactive_zone_cols
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static const FIRSTPASS_STATS * read_frame_stats ( const TWO_PASS * p , int offset ) { if ( ( offset >= 0 && p -> stats_in + offset >= p -> stats_in_end ) || ( offset < 0 && p -> stats_in + offset < p -> stats_in_start ) ) { return NULL ; } return & p -> stats_in [ offset ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void reset_fpf_position ( TWO_PASS <S2SV_ModEnd> * p , const FIRSTPASS_STATS * position ) {
<S2SV_ModStart> -> frame -= frame -> frame ; section -> weight -= frame -> weight ; section -> <S2SV_ModStart> coded_error ; section -> sr_coded_error -= frame -> sr_coded_error <S2SV_ModEnd> ; section -> pcnt_inter -= frame -> pcnt_inter ; <S2SV_ModStart> pcnt_second_ref ; section -> pcnt_neutral -= frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int test_candidate_kf ( TWO_PASS <S2SV_ModEnd> * twopass , const FIRSTPASS_STATS * last_frame , const <S2SV_ModStart> * next_frame ) { int is_viable_kf = 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; if ( ( this_frame -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( next_frame -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <S2SV_ModEnd> ) && ( ( this_frame -> intra_error / DOUBLE_DIVIDE_CHECK <S2SV_ModStart> / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < KF_II_ERR_THRESHOLD <S2SV_ModEnd> ) && ( ( fabs ( last_frame -> coded_error <S2SV_ModStart> ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || ( fabs ( last_frame -> intra_error - <S2SV_ModStart> ) / DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || ( ( next_frame -> intra_error / DOUBLE_DIVIDE_CHECK <S2SV_ModStart> / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > II_IMPROVEMENT_THRESHOLD <S2SV_ModEnd> ) ) ) ) ) { int i ; <S2SV_ModStart> ; ++ i ) { double next_iiratio = ( BOOST_FACTOR <S2SV_ModEnd> * local_next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame . <S2SV_ModStart> . coded_error ) ) ; if ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX <S2SV_ModEnd> ; if ( local_next_frame . pcnt_inter > 0.85 )
<S2SV_ModStart> vp9_end_first_pass ( VP9_COMP * cpi ) { if ( is_two_pass_svc ( cpi ) <S2SV_ModEnd> ) { int i ; for ( i =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_first_pass ( VP9_COMP * cpi , const struct lookahead_entry * source <S2SV_ModStart> ; MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> -> plane ; const PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none <S2SV_ModEnd> ; int i ; int recon_yoffset , recon_uvoffset ; <S2SV_ModStart> ; int i ; int recon_yoffset , recon_uvoffset ; <S2SV_ModEnd> int64_t intra_error = 0 ; int64_t coded_error = 0 <S2SV_ModStart> intercount = 0 ; int second_ref_count = 0 ; const int intrapenalty = INTRA_MODE_PENALTY ; double neutral_count ; int intra_skip_count = 0 ; int image_data_start_row = INVALID_ROW <S2SV_ModEnd> ; int new_mv_count = 0 ; int sum_in_vectors = <S2SV_ModStart> new_mv_count = 0 ; int sum_in_vectors = 0 ; MV lastmv = { 0 , 0 } ; TWO_PASS <S2SV_ModEnd> * twopass = & cpi -> twopass ; const <S2SV_ModStart> MV zero_mv = { 0 , 0 } ; int recon_y_stride , recon_uv_stride , uv_mb_height ; YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; double intra_factor ; double brightness_factor ; BufferPool * const pool = cm -> buffer_pool ; assert ( new_yv12 != NULL ) ; assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; } # endif vpx_clear_system_state ( ) ; intra_factor = 0.0 ; brightness_factor = 0.0 ; neutral_count = 0.0 ; set_first_pass_params ( cpi ) ; vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; if ( lc != NULL ) { twopass = & lc -> twopass ; cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags = VP9_LAST_FLAG ; if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) { cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; } else { cpi -> refresh_golden_frame = 0 ; } if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) { first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; } if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; if ( gld_yv12 == NULL ) { gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } } else { gld_yv12 = NULL ; } set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ; } vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; } xd -> mi = cm -> mi_grid_visible ; xd -> mi [ 0 ] = cm -> mi <S2SV_ModEnd> ; vp9_frame_init_quantizer ( cpi ) ; for ( i <S2SV_ModStart> tile , cm , 0 , 0 ) ; recon_y_stride = new_yv12 -> y_stride ; recon_uv_stride = new_yv12 -> uv_stride ; uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; <S2SV_ModStart> < cm -> mb_rows ; ++ mb_row ) { MV best_ref_mv = { 0 , 0 } <S2SV_ModEnd> ; xd -> up_available = ( mb_row != 0 <S2SV_ModStart> && ( ! mb_col || ! mb_row ) ; <S2SV_ModEnd> const BLOCK_SIZE bsize = get_bsize ( cm , mb_row <S2SV_ModStart> get_bsize ( cm , mb_row , mb_col ) ; double log_intra ; int level_sample ; # if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) ; xd -> plane [ 0 ] <S2SV_ModStart> cm -> mi_rows , cm -> mi_cols ) ; x -> skip_encode = 0 ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; vp9_encode_intra_block_plane ( x , bsize , 0 ) ; this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; if ( this_error < UL_INTRA_THRESH ) { ++ intra_skip_count ; } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = mb_row ; } # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { switch ( cm -> bit_depth ) { case VPX_BITS_8 : break ; case VPX_BITS_10 : this_error >>= 4 ; break ; case VPX_BITS_12 : this_error >>= 8 ; break ; default : assert ( 0 && "cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>" "VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return ; } } # endif vpx_clear_system_state ( ) ; log_intra = log ( this_error + 1.0 ) ; if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; else intra_factor += 1.0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; else brightness_factor += 1.0 ; <S2SV_ModEnd> this_error += intrapenalty ; intra_error += ( int64_t ) <S2SV_ModStart> intrapenalty ; intra_error += ( int64_t ) this_error ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; } # endif <S2SV_ModStart> ) * 16 ) + BORDER_MV_PIXELS_B16 ; if ( ( lc == NULL && cm -> current_video_frame > 0 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) { int tmp_err , motion_error , raw_motion_error ; MV mv = { 0 , 0 } , tmp_mv = { 0 , 0 } ; struct buf_2d unscaled_last_source_buf_2d <S2SV_ModEnd> ; xd -> plane [ 0 ] . pre <S2SV_ModStart> . buf = first_ref_buf -> y_buffer + recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; } else { raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; } # else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; # endif if ( raw_motion_error > 25 || lc != NULL ) { first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; if ( ! is_zero_mv ( & best_ref_mv ) ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; <S2SV_ModEnd> if ( tmp_err < motion_error ) { motion_error = <S2SV_ModStart> < motion_error ) { motion_error = tmp_err ; mv = tmp_mv ; } } if ( ( ( lc == NULL && cm -> current_video_frame > 1 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) <S2SV_ModEnd> && gld_yv12 != NULL ) { int gf_motion_error ; <S2SV_ModStart> . buf = gld_yv12 -> y_buffer + recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif <S2SV_ModEnd> first_pass_motion_search ( cpi , x , & zero_mv , <S2SV_ModStart> cpi , x , & zero_mv , & tmp_mv , & gf_motion_error ) ; <S2SV_ModEnd> if ( gf_motion_error < motion_error && gf_motion_error < this_error <S2SV_ModStart> ; } else { sr_coded_error += motion_error ; } } else { sr_coded_error += motion_error ; } best_ref_mv . row = 0 ; best_ref_mv . col = 0 ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( motion_error <= this_error ) { vpx_clear_system_state ( ) ; <S2SV_ModEnd> if ( ( ( this_error - intrapenalty ) * <S2SV_ModStart> ) * 9 <= motion_error * 10 ) && ( this_error < ( 2 * intrapenalty ) ) ) { neutral_count += 1.0 ; } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; } mv . row *= 8 ; mv . <S2SV_ModEnd> col *= 8 ; this_error = motion_error ; xd <S2SV_ModStart> 0 ] -> mbmi . mv [ 0 ] . as_mv <S2SV_ModStart> x , bsize ) ; sum_mvr += mv . row ; sum_mvr_abs += abs ( mv . row ) ; sum_mvc += mv . col ; sum_mvc_abs += abs ( mv . col ) ; sum_mvrs += mv . row * mv . row ; sum_mvcs += mv . col * mv . col ; ++ intercount ; best_ref_mv = mv ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( ! is_zero_mv ( & mv ) ) { ++ mvcount ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_MOTION_ZERO_MASK ; if ( mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ; } else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ; } else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ; } else { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ; } } # endif if ( ! is_equal_mv ( & mv , & lastmv ) ) ++ new_mv_count ; lastmv = mv <S2SV_ModEnd> ; if ( mb_row < cm -> mb_rows / <S2SV_ModStart> mb_rows / 2 ) { if ( mv . <S2SV_ModEnd> row > 0 ) -- sum_in_vectors ; else if <S2SV_ModStart> 0 ) -- sum_in_vectors ; else if ( mv <S2SV_ModEnd> . row < 0 ) ++ sum_in_vectors ; } <S2SV_ModStart> mb_rows / 2 ) { if ( mv . <S2SV_ModEnd> row > 0 ) ++ sum_in_vectors ; else if <S2SV_ModStart> 0 ) ++ sum_in_vectors ; else if ( mv <S2SV_ModEnd> . row < 0 ) -- sum_in_vectors ; } <S2SV_ModStart> mb_cols / 2 ) { if ( mv . <S2SV_ModEnd> col > 0 ) -- sum_in_vectors ; else if <S2SV_ModStart> 0 ) -- sum_in_vectors ; else if ( mv <S2SV_ModEnd> . col < 0 ) ++ sum_in_vectors ; } <S2SV_ModStart> mb_cols / 2 ) { if ( mv . <S2SV_ModEnd> col > 0 ) ++ sum_in_vectors ; else if <S2SV_ModStart> 0 ) ++ sum_in_vectors ; else if ( mv <S2SV_ModEnd> . col < 0 ) -- sum_in_vectors ; } <S2SV_ModStart> . stride - uv_mb_height * cm -> mb_cols ; vpx_clear_system_state ( ) ; } if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = cm -> mb_rows / 2 ; } if ( image_data_start_row > 0 ) { intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; } { FIRSTPASS_STATS fps ; const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; const double min_err = 200 * sqrt ( num_mbs ) ; intra_factor = intra_factor / ( double ) num_mbs ; brightness_factor = brightness_factor / ( double ) num_mbs ; fps . weight = intra_factor * brightness_factor ; fps . <S2SV_ModEnd> frame = cm -> current_video_frame ; fps . spatial_layer_id <S2SV_ModStart> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err <S2SV_ModStart> = ( double ) ( intra_error >> 8 ) + min_err <S2SV_ModEnd> ; fps . count = 1.0 ; fps . <S2SV_ModStart> fps . pcnt_inter = ( double ) intercount / num_mbs <S2SV_ModEnd> ; fps . pcnt_second_ref = ( double ) second_ref_count <S2SV_ModStart> fps . pcnt_second_ref = ( double ) second_ref_count / num_mbs <S2SV_ModEnd> ; fps . pcnt_neutral = ( double ) neutral_count <S2SV_ModStart> fps . pcnt_neutral = ( double ) neutral_count / num_mbs ; fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; fps . inactive_zone_rows = ( double ) image_data_start_row ; fps . inactive_zone_cols = ( double ) 0 <S2SV_ModEnd> ; if ( mvcount > 0 ) { fps <S2SV_ModStart> MVrv = ( ( double ) sum_mvrs - ( ( double ) sum_mvr * sum_mvr <S2SV_ModEnd> / mvcount ) ) / mvcount ; fps . <S2SV_ModStart> MVcv = ( ( double ) sum_mvcs - ( ( double ) sum_mvc * sum_mvc <S2SV_ModEnd> / mvcount ) ) / mvcount ; fps . <S2SV_ModStart> fps . pcnt_motion = ( double ) mvcount / num_mbs <S2SV_ModEnd> ; } else { fps . MVr = 0.0 <S2SV_ModStart> } fps . duration = ( double ) ( source -> ts_end - <S2SV_ModEnd> source -> ts_start ) ; twopass -> this_frame_stats = <S2SV_ModStart> & twopass -> total_stats , & fps ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; } # endif <S2SV_ModStart> ) { if ( gld_yv12 != NULL ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; } twopass -> sr_update_lag = 1 ; <S2SV_ModStart> } else { ++ twopass -> sr_update_lag ; } vpx_extend_frame_borders ( new_yv12 ) ; if ( lc != NULL <S2SV_ModEnd> ) { vp9_update_reference_frames ( cpi ) ; } else <S2SV_ModStart> { vp9_update_reference_frames ( cpi ) ; } else { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ; } if ( cm -> current_video_frame == 0 && cpi -> gld_fb_idx != INVALID_IDX && lc == NULL ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; } if ( 0 ) { char <S2SV_ModStart> recon_file ) ; } ++ cm -> current_video_frame ; if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;
<S2SV_ModStart> * const svc = & cpi -> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> oxcf = & cpi -> oxcf ; const int is_two_pass_svc = ( svc -> number_spatial_layers > 1 ) || ( svc -> number_temporal_layers > 1 ) ; TWO_PASS * const twopass = is_two_pass_svc ? & svc -> layer_context [ svc -> spatial_layer_id ] . twopass : & cpi -> twopass ; double frame_rate ; FIRSTPASS_STATS * stats ; zero_stats ( & twopass -> total_stats ) ; zero_stats ( & twopass -> total_left_stats ) ; if ( ! twopass -> stats_in_end ) return ; stats = & twopass -> total_stats ; * stats = * twopass -> stats_in_end ; twopass -> total_left_stats = * stats ; frame_rate = 10000000.0 * stats -> count / stats -> duration ; if ( is_two_pass_svc ) { vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ; twopass -> bits_left = ( int64_t ) ( stats -> duration * <S2SV_ModEnd> svc -> layer_context [ svc -> spatial_layer_id ] . <S2SV_ModStart> svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / 10000000.0 ) ; } else { vp9_new_framerate ( cpi , frame_rate ) ; twopass -> bits_left = ( int64_t ) ( stats -> duration * oxcf -> target_bandwidth / 10000000.0 ) ; } twopass -> sr_update_lag = 1 ; { const double avg_error = stats -> coded_error / DOUBLE_DIVIDE_CHECK ( stats -> count ) ; const FIRSTPASS_STATS * s = twopass -> stats_in ; double modified_error_total = 0.0 ; twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ; twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 ; while ( s < twopass -> stats_in_end ) { modified_error_total += calculate_modified_err ( cpi , twopass , oxcf , s ) ; ++ s ; } twopass -> modified_error_left = modified_error_total ; } cpi -> rc . vbr_bits_off_target = 0 ; cpi -> rc . vbr_bits_off_target_fast = 0 ; cpi -> rc . rate_error_estimate = 0 ; twopass -> kf_zeromotion_pct = 100 ; twopass -> last_kfgroup_zeromotion_pct = 100 ; if ( oxcf -> resize_mode != RESIZE_NONE ) { vp9_init_subsampling ( cpi <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * const rc = & cpi -> rc ; TWO_PASS * const twopass = & cpi -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group ; int frames_left ; FIRSTPASS_STATS this_frame ; int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { <S2SV_ModEnd> frames_left = ( int ) ( twopass -> total_stats <S2SV_ModStart> ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q <S2SV_ModEnd> ) { twopass -> active_worst_quality = cpi -> oxcf <S2SV_ModStart> if ( cm -> current_video_frame == 0 || ( lc != NULL <S2SV_ModEnd> && lc -> current_video_frame_in_layer == 0 ) ) { <S2SV_ModStart> ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] <S2SV_ModEnd> ; } vp9_zero ( this_frame ) ; if ( <S2SV_ModStart> ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { FIRSTPASS_STATS this_frame_copy ; this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( "arf.stt" , "a" ) ; ++ arf_count ; fprintf ( fpfile , "%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n" , cm -> current_video_frame , rc -> frames_till_gf_update_due , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; } <S2SV_ModEnd> subtract_stats ( & twopass -> total_left_stats , & this_frame
<S2SV_ModStart> ( FIRSTPASS_STATS * section ) { section -> frame = 0.0 ; section -> weight <S2SV_ModStart> section -> coded_error = 0.0 ; section -> sr_coded_error <S2SV_ModEnd> = 0.0 ; section -> pcnt_inter = 0.0 ; <S2SV_ModStart> section -> pcnt_second_ref = 0.0 ; section -> pcnt_neutral = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols
<S2SV_ModStart> i < ctx -> max_sz ; i ++ ) vpx_free_frame_buffer <S2SV_ModEnd> ( & ctx -> buf [ i ] .
<S2SV_ModStart> , unsigned int subsampling_x , unsigned int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> ctx ) ) ; if ( ctx ) { const int legacy_byte_alignment = 0 ; <S2SV_ModStart> i < depth ; i ++ ) if ( vpx_alloc_frame_buffer <S2SV_ModEnd> ( & ctx -> buf [ i ] . <S2SV_ModStart> , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <S2SV_ModEnd> ) ) goto bail ; } return ctx ;
<S2SV_ModStart> * src , int64_t ts_start , int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> y_width + 15 ) >> 4 ; # endif int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> ( ctx , & ctx -> write_idx ) ; new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; # if USE_PARTIAL_COPY if ( ! new_dimensions && <S2SV_ModEnd> ctx -> max_sz == 1 && active_map && ! <S2SV_ModStart> } active_map += mb_cols ; } } else { # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> ( src , & buf -> img ) ; # if USE_PARTIAL_COPY } <S2SV_ModEnd> # endif buf -> ts_start = ts_start ; buf
<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> * const xd = & x -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; const <S2SV_ModStart> = x -> mv_row_max ; MV ref_full ; int cost_list [ 5 ] ; int step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS - 2 <S2SV_ModEnd> ) ; vp9_set_mv_search_range ( x , ref_mv ) ; <S2SV_ModStart> , step_param , x -> errorperbit , 0 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> x -> errorperbit , & v_fn_ptr , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , <S2SV_ModEnd> NULL , NULL , & distortion , & sse <S2SV_ModStart> NULL , NULL , & distortion , & sse , NULL , 0 , 0 <S2SV_ModStart> tmp_row_min ; x -> mv_row_max = tmp_row_max ; return vpx_sad16x16 <S2SV_ModEnd> ( x -> plane [ 0 ] . src <S2SV_ModStart> -> plane [ 0 ] . dst . stride <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> static int do_16x16_motion_search ( VP9_COMP * cpi , const MV * ref_mv , int_mv * <S2SV_ModEnd> dst_mv , int mb_row , int mb_col ) { <S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> -> e_mbd ; unsigned int err , tmp_err ; MV tmp_mv ; err = vpx_sad16x16 <S2SV_ModEnd> ( x -> plane [ 0 ] . src <S2SV_ModStart> 0 ] . pre [ 0 ] . stride <S2SV_ModEnd> ) ; dst_mv -> as_int = 0 ; tmp_err <S2SV_ModStart> = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <S2SV_ModEnd> ; err = tmp_err ; } } return err
<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> -> e_mbd ; unsigned int err ; err = vpx_sad16x16 <S2SV_ModEnd> ( x -> plane [ 0 ] . src <S2SV_ModStart> 0 ] . pre [ 0 ] . stride <S2SV_ModEnd> ) ; dst_mv -> as_int = 0 ; return
<S2SV_ModStart> <S2SV_null> static int find_best_16x16_intra ( VP9_COMP * cpi , PREDICTION_MODE <S2SV_ModEnd> * pbest_mode ) { MACROBLOCK * const x = <S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> * const xd = & x -> e_mbd ; PREDICTION_MODE <S2SV_ModEnd> best_mode = - 1 , mode ; unsigned int <S2SV_ModStart> . mode = mode ; vp9_predict_intra_block ( xd , <S2SV_ModEnd> 2 , TX_16X16 , mode , x -> plane <S2SV_ModStart> 0 , 0 , 0 ) ; err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride <S2SV_ModEnd> ) ; if ( err < best_err ) {
<S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td . <S2SV_ModStart> , arf_y_offset = 0 , gld_y_offset = 0 ; MV gld_top_mv = { 0 , 0 } ; MODE_INFO mi_local ; vp9_zero ( mi_local ) <S2SV_ModEnd> ; x -> mv_row_min = - BORDER_MV_PIXELS_B16 ; x <S2SV_ModStart> < cm -> mb_rows ; mb_row ++ ) { MV gld_left_mv = gld_top_mv <S2SV_ModEnd> ; int mb_y_in_offset = mb_y_offset ; int arf_y_in_offset = <S2SV_ModStart> int arf_y_in_offset = arf_y_offset ; int gld_y_in_offset = gld_y_offset <S2SV_ModEnd> ; x -> mv_col_min = - BORDER_MV_PIXELS_B16 ; x <S2SV_ModStart> gld_left_mv , alt_ref , mb_row , mb_col ) ; gld_left_mv = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv <S2SV_ModEnd> ; } xd -> left_available = 1 ; mb_y_in_offset
<S2SV_ModStart> buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , const MV <S2SV_ModEnd> * prev_golden_ref_mv , YV12_BUFFER_CONFIG * alt_ref , int mb_row <S2SV_ModStart> { MACROBLOCK * const x = & cpi -> td .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int get_max_filter_level ( const VP9_COMP * cpi ) { if ( cpi -> oxcf . pass == 2 <S2SV_ModEnd> ) { return cpi -> twopass . section_intra_rating > <S2SV_ModStart> ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ; } else { return MAX_LOOP_FILTER ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * <S2SV_ModStart> , VP9_COMP * cpi , int partial_frame ) { const <S2SV_ModStart> * const cm = & cpi -> common ; const <S2SV_ModStart> int max_filter_level = get_max_filter_level ( cpi ) ; int filt_direction = 0 ; int64_t best_err ; int filt_best <S2SV_ModEnd> ; int filt_mid = clamp ( lf -> filter_level <S2SV_ModStart> < 16 ? 4 : filt_mid / 4 ; int64_t ss_err [ MAX_LOOP_FILTER + 1 ] ; memset <S2SV_ModEnd> ( ss_err , 0xFF , sizeof ( ss_err ) <S2SV_ModStart> MAX ( filt_mid - filter_step , min_filter_level ) ; int64_t <S2SV_ModEnd> bias = ( best_err >> ( 15 - ( <S2SV_ModStart> / 8 ) ) ) * filter_step ; if ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) <S2SV_ModEnd> / 20 ; if ( cm -> tx_mode != <S2SV_ModStart> ( ss_err [ filt_low ] < 0 ) { ss_err [ filt_low ] <S2SV_ModEnd> = try_filter_frame ( sd , cpi , filt_low , <S2SV_ModStart> sd , cpi , filt_low , partial_frame ) ; } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> - bias ) < best_err ) { if ( <S2SV_ModStart> - bias ) < best_err ) { if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> ; filt_best = filt_low ; } } if ( <S2SV_ModStart> ( ss_err [ filt_high ] < 0 ) { ss_err [ filt_high ] <S2SV_ModEnd> = try_filter_frame ( sd , cpi , filt_high , <S2SV_ModStart> sd , cpi , filt_high , partial_frame ) ; } if ( ss_err [ filt_high ] <S2SV_ModEnd> < ( best_err - bias ) ) { best_err <S2SV_ModStart> ( best_err - bias ) ) { best_err = ss_err [ filt_high ] <S2SV_ModEnd> ; filt_best = filt_high ; } } if ( <S2SV_ModStart> : 1 ; filt_mid = filt_best ; } } return <S2SV_ModEnd> filt_best ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int64_t <S2SV_ModEnd> try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * <S2SV_ModStart> * const cm = & cpi -> common ; int64_t filt_err ; if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> lf_row_sync ) ; else vp9_loop_filter_frame ( cm -> frame_to_show , cm , & cpi -> td . <S2SV_ModEnd> mb . e_mbd , filt_level , 1 , partial_frame <S2SV_ModStart> e_mbd , filt_level , 1 , partial_frame ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ; } else { <S2SV_ModStart> vp9_get_y_sse ( sd , cm -> frame_to_show ) ; } # else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; # endif
<S2SV_ModStart> xd , int * out_rate_sum , int64_t * out_dist_sum , unsigned int * var_y , unsigned int * sse_y <S2SV_ModStart> = & xd -> plane [ 0 ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> 6 ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> 6 ; const uint32_t dc_quant = pd -> dequant [ 0 ] ; const uint32_t ac_quant = pd -> dequant [ 1 ] ; unsigned <S2SV_ModStart> -> dst . stride , & sse ) ; int skip_dc = 0 ; * var_y = var ; * sse_y = sse ; if ( cpi -> common . tx_mode == TX_MODE_SELECT ) { if ( sse > ( var << 2 ) ) xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; else xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; else if ( xd -> mi [ 0 ] -> mbmi . tx_size > TX_16X16 ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_16X16 ; } else { xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; } { const BLOCK_SIZE unit_size = txsize_to_bsize [ xd -> mi [ 0 ] -> mbmi . tx_size ] ; const unsigned int num_blk_log2 = ( b_width_log2_lookup [ bsize ] - b_width_log2_lookup [ unit_size ] ) + ( b_height_log2_lookup [ bsize ] - b_height_log2_lookup [ unit_size ] ) ; const unsigned int sse_tx = sse >> num_blk_log2 ; const unsigned int var_tx = var >> num_blk_log2 ; x -> skip_txfm [ 0 ] = SKIP_TXFM_NONE ; if ( var_tx < ac_thr || var == 0 ) { x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_ONLY ; if ( sse_tx - var_tx < dc_thr || sse == var ) x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } else { if ( sse_tx - var_tx < dc_thr || sse == var ) skip_dc = 1 ; } } if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC ) { * out_rate_sum = 0 ; * out_dist_sum = sse << 4 ; return ; } if ( ! skip_dc ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; # endif } if ( ! skip_dc ) { * out_rate_sum = rate >> 1 ; * out_dist_sum = dist << 3 ; } else { * out_rate_sum = 0 ; * out_dist_sum = ( sse - var ) << 4 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; # endif * out_rate_sum += rate ; * out_dist_sum += dist << 4 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { vp9_init_plane_quantizers ( cpi , & cpi -> td . <S2SV_ModEnd> mb ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> cpi , qindex + cm -> y_dc_delta_q ) ; int <S2SV_ModEnd> i ; x -> plane [ 0 ] . <S2SV_ModStart> ] ; x -> plane [ 0 ] . quant_fp = quants -> y_quant_fp [ qindex ] ; x -> plane [ 0 ] . round_fp = quants -> y_round_fp [ qindex ] ; x -> plane [ 0 ] . <S2SV_ModStart> round = quants -> y_round [ qindex ] ; xd -> plane [ 0 ] . dequant = cpi -> y_dequant [ qindex ] ; x -> plane [ 0 ] . quant_thred [ 0 ] = x -> plane [ 0 ] . zbin [ 0 ] * x -> plane [ 0 ] . zbin [ 0 ] ; x -> plane [ 0 ] . quant_thred [ 1 ] = x -> plane [ 0 ] . zbin [ 1 ] * x -> plane [ 0 ] . zbin [ 1 <S2SV_ModEnd> ] ; for ( i = 1 ; i <S2SV_ModStart> ] ; x -> plane [ i ] . quant_fp = quants -> uv_quant_fp [ qindex ] ; x -> plane [ i ] . round_fp = quants -> uv_round_fp [ qindex ] ; x -> plane [ i ] . <S2SV_ModStart> round = quants -> uv_round [ qindex ] ; xd -> plane [ i ] . dequant = cpi -> uv_dequant [ qindex ] ; x -> plane [ i ] . quant_thred [ 0 ] = x -> plane [ i ] . zbin [ 0 ] * x -> plane [ i ] . zbin [ 0 ] ; x -> plane [ i ] . quant_thred [ 1 ] = x -> plane [ i ] . zbin [ 1 ] * x -> plane [ i ] . zbin [ 1 ] ; } x -> skip_block = segfeature_active <S2SV_ModEnd> ( & cm -> seg , segment_id , SEG_LVL_SKIP <S2SV_ModStart> == 0 ) ; vp9_initialize_me_consts ( cpi , x , x
<S2SV_ModStart> ; q ++ ) { const int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> ) ; const int qrounding_factor = q == 0 <S2SV_ModStart> ; i < 2 ; ++ i ) { int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q , cm -> bit_depth ) : vp9_ac_quant ( q , 0 , cm -> bit_depth <S2SV_ModEnd> ) ; invert_quant ( & quants -> y_quant [ <S2SV_ModStart> [ i ] , quant ) ; quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ; quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> -> y_dequant [ q ] [ i ] = <S2SV_ModStart> 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q , cm -> bit_depth <S2SV_ModStart> ) : vp9_ac_quant ( q , cm -> uv_ac_delta_q , cm -> bit_depth <S2SV_ModStart> [ i ] , quant ) ; quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ; quants -> uv_zbin <S2SV_ModEnd> [ q ] [ i ] = ROUND_POWER_OF_TWO ( <S2SV_ModStart> qzbin_factor * quant , 7 ) ; quants -> uv_round <S2SV_ModEnd> [ q ] [ i ] = ( qrounding_factor <S2SV_ModStart> = ( qrounding_factor * quant ) >> 7 ; cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> } for ( i = 2 ; i < <S2SV_ModStart> [ q ] [ 1 ] ; quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> -> y_round [ q ] [ 1 ] ; cpi <S2SV_ModEnd> -> y_dequant [ q ] [ i ] = <S2SV_ModStart> -> y_dequant [ q ] [ i ] = cpi <S2SV_ModEnd> -> y_dequant [ q ] [ 1 ] ; <S2SV_ModStart> [ q ] [ 1 ] ; quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> -> uv_round [ q ] [ 1 ] ; cpi <S2SV_ModEnd> -> uv_dequant [ q ] [ i ] = <S2SV_ModStart> -> uv_dequant [ q ] [ i ] = cpi <S2SV_ModEnd> -> uv_dequant [ q ] [ 1 ] ; <S2SV_ModStart> -> uv_dequant [ q ] [ 1 ] ; <S2SV_ModEnd> } } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = & xd -> plane [ plane ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_quantize_b <S2SV_ModEnd> ( BLOCK_OFFSET ( p -> coeff , block ) <S2SV_ModStart> dqcoeff , block ) , pd -> dequant , <S2SV_ModEnd> & p -> eobs [ block ] , scan <S2SV_ModStart> [ block ] , scan , iscan ) ; return ; } # endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , & p -> eobs [ block ] , scan , iscan ) ;
<S2SV_ModStart> const cm = & cpi -> common ; const RATE_CONTROL * rc = & cpi -> rc ; int64_t critical_level = rc -> optimal_buffer_level >> 3 <S2SV_ModEnd> ; int64_t buff_lvl_step = 0 ; int adjustment = <S2SV_ModStart> 0 ; int adjustment = 0 ; int active_worst_quality ; int ambient_qp ; unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers <S2SV_ModStart> frame_type == KEY_FRAME ) return rc -> worst_quality ; ambient_qp = ( cm -> current_video_frame < num_frames_weight_key ) ? MIN ( rc -> avg_frame_qindex [ INTER_FRAME ] , rc -> avg_frame_qindex [ KEY_FRAME ] ) : rc -> avg_frame_qindex [ INTER_FRAME ] ; active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ; if ( rc -> buffer_level > rc -> optimal_buffer_level ) { int max_adjustment_down = active_worst_quality / 3 ; if ( max_adjustment_down ) { buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ; if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ; active_worst_quality -= adjustment ; } } else if ( rc -> buffer_level > critical_level ) { if ( critical_level ) { buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ; if ( buff_lvl_step ) { adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ; } active_worst_quality = ambient_qp <S2SV_ModEnd> + adjustment ; } } else { active_worst_quality =
<S2SV_ModStart> const RATE_CONTROL * rc = & cpi -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <S2SV_ModStart> current_video_frame == 0 ) { target = ( ( rc -> <S2SV_ModEnd> starting_buffer_level / 2 ) > INT_MAX ) ? INT_MAX <S2SV_ModStart> INT_MAX ) ? INT_MAX : ( int ) ( rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } kf_boost = MAX ( kf_boost , ( int ) ( 2 * framerate <S2SV_ModEnd> - 16 ) ) ; if ( rc -> <S2SV_ModStart> ) ) ; if ( rc -> frames_since_key < framerate <S2SV_ModEnd> / 2 ) { kf_boost = ( int ) <S2SV_ModStart> ) ( kf_boost * rc -> frames_since_key / ( framerate <S2SV_ModEnd> / 2 ) ) ; } target = ( <S2SV_ModStart> ( ( 16 + kf_boost ) * rc -> avg_frame_bandwidth <S2SV_ModEnd> ) >> 4 ; } return vp9_rc_clamp_iframe_target_size ( cpi
<S2SV_ModStart> RATE_CONTROL * rc = & cpi -> rc ; const int target = rc -> avg_frame_bandwidth <S2SV_ModEnd> * kf_ratio ; return vp9_rc_clamp_iframe_target_size ( cpi , target
<S2SV_ModStart> calc_pframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf = & cpi -> oxcf ; const <S2SV_ModStart> & cpi -> svc ; const int64_t diff = rc <S2SV_ModEnd> -> optimal_buffer_level - rc -> buffer_level ; const int64_t <S2SV_ModStart> -> buffer_level ; const int64_t one_pct_bits = 1 + rc <S2SV_ModEnd> -> optimal_buffer_level / 100 ; int min_frame_target = MAX <S2SV_ModStart> 100 ; int min_frame_target = MAX ( rc -> avg_frame_bandwidth >> 4 , FRAME_OVERHEAD_BITS ) ; int target ; if ( oxcf -> gf_cbr_boost_pct ) { const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ; target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ; } else { target = rc -> avg_frame_bandwidth ; } if ( is_one_pass_cbr_svc ( cpi ) ) { int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) <S2SV_ModEnd> ; const LAYER_CONTEXT * lc = & svc -> <S2SV_ModStart> LAYER_CONTEXT * lc = & svc -> layer_context [ layer <S2SV_ModEnd> ] ; target = lc -> avg_frame_size ; min_frame_target <S2SV_ModStart> ( target * pct_high ) / 200 ; } if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; }
<S2SV_ModStart> cpi -> refresh_alt_ref_frame ) ) ? ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> baseline_gf_interval * af_ratio ) / ( <S2SV_ModStart> + af_ratio - 1 ) : ( rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc -> baseline_gf_interval ) / ( rc -> <S2SV_ModStart> 1 ) ; # else target = rc -> avg_frame_bandwidth <S2SV_ModEnd> ; # endif return vp9_rc_clamp_pframe_target_size ( cpi , target
<S2SV_ModStart> , double x3 , double x2 , double x1 , vpx_bit_depth_t bit_depth <S2SV_ModStart> 0 ; i < QINDEX_RANGE ; i ++ ) { if ( minqtarget <= vp9_convert_qindex_to_q ( i , bit_depth ) ) return i ; } <S2SV_ModEnd> return QINDEX_RANGE - 1 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> double get_rate_correction_factor ( const VP9_COMP * cpi ) { const RATE_CONTROL * const rc = & cpi -> rc ; double rcf ; <S2SV_ModStart> cpi -> common . frame_type == KEY_FRAME ) { rcf = rc -> rate_correction_factors [ KF_STD ] ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rcf = rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> ; } else { if ( ( cpi -> <S2SV_ModStart> -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] ; else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] ; } rcf *= rcf_mult [ rc -> frame_size_selector ] ; return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = calc_active_worst_quality_one_pass_cbr ( cpi ) ; int q ; int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <S2SV_ModStart> -> last_boosted_qindex ; double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> rc , last_boosted_q , ( last_boosted_q * 0.75 ) , cm -> bit_depth <S2SV_ModStart> q_adj_factor = 1.0 ; double q_val ; active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if ( ( cm -> width * <S2SV_ModStart> -= 0.25 ; } q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth <S2SV_ModStart> else { q = active_worst_quality ; } active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } else { if ( cm -> <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq <S2SV_ModEnd> [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME ] ] ; else active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality ] ; } else { if ( <S2SV_ModStart> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq <S2SV_ModEnd> [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_ModStart> avg_frame_qindex [ KEY_FRAME ] ] ; else active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality ] ; } } active_best_quality = clamp <S2SV_ModStart> -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm -> current_video_frame == 0 ) ) <S2SV_ModStart> ! ( cm -> current_video_frame == 0 ) ) { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } # endif if ( cm -> frame_type
<S2SV_ModStart> const rc = & cpi -> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> * const oxcf = & cpi -> oxcf ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> = calc_active_worst_quality_one_pass_vbr ( cpi ) ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; if ( frame_is_intra_only ( cm ) ) { <S2SV_ModEnd> if ( rc -> this_key_frame_forced ) { int qindex <S2SV_ModStart> -> last_boosted_qindex ; double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth <S2SV_ModStart> delta_qindex , rc -> best_quality ) ; } else <S2SV_ModEnd> { double q_adj_factor = 1.0 ; double q_val ; <S2SV_ModStart> q_adj_factor = 1.0 ; double q_val ; active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if ( ( cm -> width * <S2SV_ModStart> -= 0.25 ; } q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if ( ! rc -> is_src_frame_alt_ref && <S2SV_ModStart> [ KEY_FRAME ] ; } if ( oxcf -> rc_mode == VPX_CQ ) { if ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality * 15 / 16 ; } <S2SV_ModStart> / 16 ; } else if ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if ( ! cpi -> refresh_alt_ref_frame ) <S2SV_ModStart> ( ! cpi -> refresh_alt_ref_frame ) { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } } else { if ( oxcf <S2SV_ModStart> ; } } else { if ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else { if ( cm -> current_video_frame <S2SV_ModStart> KEY_FRAME ] ] ; if ( ( oxcf -> rc_mode == VPX_CQ ) && ( active_best_quality < cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> ; } } } active_best_quality = clamp ( active_best_quality <S2SV_ModStart> ; * bottom_index = active_best_quality ; # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm -> current_video_frame == 0 ) ) <S2SV_ModStart> ! ( cm -> current_video_frame == 0 ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) <S2SV_ModEnd> ; } else if ( ! rc -> is_src_frame_alt_ref <S2SV_ModStart> -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index ; } # endif if ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { q = active_best_quality ; } else if <S2SV_ModStart> ; else q = * top_index ; } } <S2SV_ModEnd> assert ( * top_index <= rc -> worst_quality &&
<S2SV_ModStart> const rc = & cpi -> rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> * const oxcf = & cpi -> oxcf ; const GF_GROUP * gf_group = & cpi -> twopass . gf_group ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; int active_best_quality ; int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; if ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) { if ( rc -> this_key_frame_forced ) { double last_boosted_q ; int delta_qindex ; int qindex ; if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { qindex = MIN ( rc -> last_kf_qindex , rc -> last_boosted_qindex ) ; active_best_quality = qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; <S2SV_ModEnd> delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q <S2SV_ModStart> = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 1.25 , cm -> bit_depth ) ; active_worst_quality = MIN ( qindex + delta_qindex , active_worst_quality ) ; } else { qindex = rc -> last_boosted_qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ; active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; } <S2SV_ModEnd> } else { double q_adj_factor = 1.0 ; double <S2SV_ModStart> q_adj_factor = 1.0 ; double q_val ; active_best_quality = get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth <S2SV_ModEnd> ) ; if ( ( cm -> width * <S2SV_ModStart> . kf_zeromotion_pct ) ; q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if ( ! rc -> is_src_frame_alt_ref && <S2SV_ModStart> q = active_worst_quality ; } if ( oxcf -> rc_mode == VPX_CQ ) { if ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality * 15 / 16 ; } <S2SV_ModStart> / 16 ; } else if ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if ( ! cpi -> refresh_alt_ref_frame ) <S2SV_ModStart> ( ! cpi -> refresh_alt_ref_frame ) { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; if ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) active_best_quality = ( active_best_quality + cq_level + 1 ) / 2 ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } } else { if ( oxcf <S2SV_ModStart> ; } } else { if ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else { active_best_quality = inter_minq [ active_worst_quality <S2SV_ModStart> [ active_worst_quality ] ; if ( ( oxcf -> rc_mode == VPX_CQ ) && ( active_best_quality < cq_level ) ) { active_best_quality = cq_level ; } } } if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) ) { if ( frame_is_intra_only ( cm ) || ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ) { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) ; active_worst_quality += ( cpi -> twopass . extend_maxq / 2 ) ; } else { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) / 2 ; active_worst_quality += cpi -> twopass . extend_maxq ; } } # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY vpx_clear_system_state ( ) ; if ( ! ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) ) || ! rc -> this_key_frame_forced || ( cpi -> twopass . last_kfgroup_zeromotion_pct < STATIC_MOTION_THRESH ) ) { int qdelta = vp9_frame_type_qdelta ( cpi , gf_group -> rf_level [ gf_group -> index ] , active_worst_quality ) ; active_worst_quality = MAX ( active_worst_quality + qdelta , active_best_quality ) ; } # endif if ( rc -> frame_size_selector != UNSCALED && ! frame_is_kf_gf_arf ( cpi ) ) { int qdelta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , active_best_quality , 2.0 , cm -> bit_depth ) ; active_best_quality = MAX ( active_best_quality + qdelta , rc -> best_quality ) ; } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; if ( oxcf -> rc_mode == VPX_Q ) { q = active_best_quality ; } else if ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) && rc -> this_key_frame_forced ) { if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { q = MIN ( rc -> last_kf_qindex , rc -> last_boosted_qindex ) ; } else { q = rc -> last_boosted_qindex ; } <S2SV_ModEnd> } else { q = vp9_rc_regulate_q ( cpi , <S2SV_ModStart> active_best_quality , active_worst_quality ) ; if ( q > active_worst_quality <S2SV_ModEnd> ) { if ( rc -> this_frame_target >= rc <S2SV_ModStart> ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) active_worst_quality = q ; else q = active_worst_quality ; } } clamp ( q , active_best_quality , active_worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; <S2SV_ModEnd> assert ( * top_index <= rc -> worst_quality &&
<S2SV_ModStart> ( VP9_COMP * cpi , double factor ) { RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> cpi -> common . frame_type == KEY_FRAME ) { rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> = factor ; } else { if ( ( <S2SV_ModStart> -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] = factor ; else rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> = factor ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> rc ; rc -> frames_since_golden = 0 ; <S2SV_ModEnd> rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active
<S2SV_ModStart> VP9_COMMON * const cm = & cpi -> common <S2SV_ModEnd> ; RATE_CONTROL * const rc = & cpi -> <S2SV_ModStart> } else { rc -> bits_off_target += rc -> avg_frame_bandwidth <S2SV_ModEnd> - encoded_frame_size ; } rc -> bits_off_target = MIN <S2SV_ModStart> -> bits_off_target = MIN ( rc -> bits_off_target , rc <S2SV_ModEnd> -> maximum_buffer_size ) ; rc -> buffer_level = rc <S2SV_ModStart> -> buffer_level = rc -> bits_off_target ; if ( is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> ) { update_layer_buffer_level ( & cpi -> svc ,
<S2SV_ModStart> 0 ; if ( ! rc -> source_alt_ref_pending ) { rc -> source_alt_ref_active = 0 ; } <S2SV_ModEnd> if ( rc -> frames_till_gf_update_due > 0 ) rc
<S2SV_ModStart> SVC * svc , int encoded_frame_size ) { int i <S2SV_ModEnd> = 0 ; int current_temporal_layer = svc -> temporal_layer_id <S2SV_ModStart> int current_temporal_layer = svc -> temporal_layer_id ; for ( i = current_temporal_layer + 1 ; i < svc -> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; <S2SV_ModEnd> LAYER_CONTEXT * lc = & svc -> layer_context [ <S2SV_ModStart> LAYER_CONTEXT * lc = & svc -> layer_context [ layer <S2SV_ModEnd> ] ; RATE_CONTROL * lrc = & lc -> <S2SV_ModStart> -> bits_off_target = MIN ( lrc -> bits_off_target , lrc <S2SV_ModEnd> -> maximum_buffer_size ) ; lrc -> buffer_level = lrc
<S2SV_ModStart> RATE_CONTROL * rc , double qstart , double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> start_index = i ; if ( vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> target_index = i ; if ( vp9_convert_qindex_to_q ( i , bit_depth
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> double vp9_convert_qindex_to_q ( int qindex , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ; case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1.0 ; } # else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( FRAME_TYPE frame_type , int qindex , double correction_factor , vpx_bit_depth_t bit_depth <S2SV_ModStart> ) { const double q = vp9_convert_qindex_to_q ( qindex , bit_depth <S2SV_ModStart> ) ; int enumerator = frame_type == KEY_FRAME ? 2700000 : 1800000 ; assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) <S2SV_ModEnd> ; enumerator += ( int ) ( enumerator * <S2SV_ModStart> ) >> 12 ; return ( int ) ( enumerator * correction_factor / q ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * rc = & cpi -> rc ; const VP9EncoderConfig <S2SV_ModEnd> * oxcf = & cpi -> oxcf ; if <S2SV_ModStart> rc_max_intra_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf -> rc_max_intra_bitrate_pct / 100 ; target =
<S2SV_ModStart> * rc = & cpi -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const <S2SV_ModStart> = MAX ( rc -> min_frame_bandwidth , rc -> avg_frame_bandwidth <S2SV_ModEnd> >> 5 ) ; if ( target < min_frame_target <S2SV_ModStart> -> max_frame_bandwidth ) target = rc -> max_frame_bandwidth ; if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; }
<S2SV_ModStart> void vp9_rc_compute_frame_size_bounds ( const VP9_COMP * cpi , int frame_target <S2SV_ModEnd> , int * frame_under_shoot_limit , int * frame_over_shoot_limit ) <S2SV_ModStart> frame_over_shoot_limit ) { if ( cpi -> oxcf . rc_mode == VPX_Q <S2SV_ModEnd> ) { * frame_under_shoot_limit = 0 ; * frame_over_shoot_limit <S2SV_ModStart> ; * frame_over_shoot_limit = INT_MAX ; } else { const int tolerance = ( cpi -> sf . recode_tolerance * frame_target ) / 100 ; * frame_under_shoot_limit = MAX ( frame_target - tolerance - 200 , 0 ) ; * frame_over_shoot_limit = MIN ( frame_target + tolerance + 200 , cpi -> rc . max_frame_bandwidth ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int vp9_rc_drop_frame ( VP9_COMP * cpi ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf = & cpi -> oxcf ; RATE_CONTROL <S2SV_ModStart> = ( int ) ( oxcf -> drop_frames_water_mark * rc <S2SV_ModEnd> -> optimal_buffer_level / 100 ) ; if ( (
<S2SV_ModStart> ( ( cm -> current_video_frame == 0 || ( cpi <S2SV_ModEnd> -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key <S2SV_ModStart> 0 || ( cpi -> oxcf . auto_key && 0 <S2SV_ModEnd> ) ) ) { cm -> frame_type = KEY_FRAME <S2SV_ModStart> == 0 ; rc -> frames_to_key = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> kf_boost = DEFAULT_KF_BOOST ; rc -> <S2SV_ModStart> = DEFAULT_KF_BOOST ; rc -> source_alt_ref_active = 0 ; } else { cm -> frame_type = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; vp9_rc_set_frame_target ( cpi , target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> && ( cm -> current_video_frame == 0 || ( cpi <S2SV_ModEnd> -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key <S2SV_ModStart> 0 || ( cpi -> oxcf . auto_key && 0 <S2SV_ModEnd> ) ) ) { cm -> frame_type = KEY_FRAME <S2SV_ModStart> == 0 ; rc -> frames_to_key = cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc -> kf_boost = DEFAULT_KF_BOOST ; rc -> <S2SV_ModStart> frames_till_gf_update_due == 0 ) { rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 <S2SV_ModEnd> ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; <S2SV_ModStart> ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) { rc -> frames_till_gf_update_due = rc -> frames_to_key ; rc -> constrained_gf_group = 1 ; } else { rc -> constrained_gf_group = 0 ; } <S2SV_ModEnd> cpi -> refresh_golden_frame = 1 ; rc -> source_alt_ref_pending
<S2SV_ModStart> cpi -> rc ; int target = rc -> avg_frame_bandwidth ; const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) <S2SV_ModEnd> ; if ( ( cm -> current_video_frame == 0 <S2SV_ModStart> ( cm -> current_video_frame == 0 ) || ( cpi <S2SV_ModEnd> -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> <S2SV_ModStart> auto_key && ( rc -> frames_since_key % cpi -> oxcf . key_freq <S2SV_ModEnd> == 0 ) ) ) { cm -> frame_type <S2SV_ModStart> ; rc -> source_alt_ref_active = 0 ; if ( is_two_pass_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; reset_temporal_layer_to_zero ( cpi ) ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( is_two_pass_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; } target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( cpi , target ) ; rc ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rc_init ( const VP9EncoderConfig <S2SV_ModEnd> * oxcf , int pass , RATE_CONTROL * rc <S2SV_ModStart> , int pass , RATE_CONTROL * rc ) { int i ; if ( pass == 0 && oxcf -> rc_mode == VPX_CBR ) { rc -> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = oxcf -> worst_allowed_q ; rc -> avg_frame_qindex <S2SV_ModStart> = oxcf -> worst_allowed_q ; rc -> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = oxcf -> worst_allowed_q ; } else { <S2SV_ModStart> worst_allowed_q ; } else { rc -> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = ( oxcf -> worst_allowed_q + oxcf -> <S2SV_ModStart> best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = ( oxcf -> worst_allowed_q + oxcf -> <S2SV_ModStart> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; } rc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; rc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; rc -> buffer_level = rc -> starting_buffer_level ; rc -> bits_off_target = rc -> starting_buffer_level ; rc -> rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q , oxcf -> bit_depth ) ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { rc -> rate_correction_factors [ i ] = 1.0 ; } rc -> min_gf_interval = oxcf -> min_gf_interval ; rc -> max_gf_interval = oxcf -> max_gf_interval ; if ( rc -> min_gf_interval == 0 ) rc -> min_gf_interval = vp9_rc_get_default_min_gf_interval ( oxcf -> width , oxcf -> height , oxcf -> init_framerate ) ; if ( rc -> max_gf_interval == 0 ) rc -> max_gf_interval = vp9_rc_get_default_max_gf_interval ( oxcf -> init_framerate , rc -> min_gf_interval ) ; rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rc_init_minq_luts ( void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { int q ; if ( cpi -> oxcf . <S2SV_ModStart> 0 ) { if ( cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , <S2SV_ModStart> cpi -> sf . use_nonrd_pick_mode ) { if ( <S2SV_ModEnd> cpi -> sf . force_frame_boost == 1 ) q
<S2SV_ModStart> ( VP9_COMP * cpi , uint64_t bytes_used ) { const <S2SV_ModStart> const cm = & cpi -> common ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> * const rc = & cpi -> rc ; const int qindex = cm -> base_qindex ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { vp9_cyclic_refresh_postencode ( cpi ) ; } <S2SV_ModEnd> rc -> projected_frame_size = ( int ) ( bytes_used <S2SV_ModStart> ( bytes_used << 3 ) ; vp9_rc_update_rate_correction_factors ( cpi <S2SV_ModEnd> ) ; if ( cm -> frame_type == KEY_FRAME <S2SV_ModStart> ) { rc -> last_q [ KEY_FRAME ] = qindex <S2SV_ModEnd> ; rc -> avg_frame_qindex [ KEY_FRAME ] = ROUND_POWER_OF_TWO <S2SV_ModStart> 3 * rc -> avg_frame_qindex [ KEY_FRAME ] + qindex , 2 ) ; if ( cpi -> use_svc ) { int i = 0 ; SVC * svc = & cpi -> svc ; for ( i = 0 ; i < svc -> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * lrc = & lc -> rc ; lrc -> last_q [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; lrc -> avg_frame_qindex [ KEY_FRAME ] = rc -> avg_frame_qindex [ KEY_FRAME ] ; } } } else { if ( rc -> is_src_frame_alt_ref || ! <S2SV_ModEnd> ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) <S2SV_ModStart> ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) || ( cpi -> use_svc && oxcf -> rc_mode == VPX_CBR ) ) { rc -> last_q [ INTER_FRAME ] = qindex ; rc -> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex <S2SV_ModStart> = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ INTER_FRAME ] + qindex <S2SV_ModEnd> , 2 ) ; rc -> ni_frames ++ ; <S2SV_ModStart> ni_frames ++ ; rc -> tot_q += vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModEnd> ) ; rc -> avg_q = rc -> tot_q <S2SV_ModStart> ; rc -> avg_q = rc -> tot_q / rc -> ni_frames ; rc -> ni_tot_qi += qindex <S2SV_ModEnd> ; rc -> ni_av_qi = rc -> ni_tot_qi / <S2SV_ModStart> rc -> ni_tot_qi / rc -> ni_frames ; } } if ( ( qindex < rc -> last_boosted_qindex ) || ( cm -> frame_type == KEY_FRAME ) || ( ! rc -> constrained_gf_group && ( <S2SV_ModEnd> cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && <S2SV_ModStart> ) ) ) ) { rc -> last_boosted_qindex = qindex ; } if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ; <S2SV_ModEnd> update_buffer_level ( cpi , rc -> projected_frame_size ) ; <S2SV_ModStart> += rc -> projected_frame_size ; rc -> total_target_bits += cm -> show_frame ? rc -> avg_frame_bandwidth : 0 <S2SV_ModEnd> ; rc -> total_target_vs_actual = rc -> total_actual_bits - <S2SV_ModStart> -> total_actual_bits - rc -> total_target_bits ; if ( ! cpi -> use_svc ) { if ( is_altref_enabled ( cpi ) <S2SV_ModEnd> && cpi -> refresh_alt_ref_frame && ( cm -> frame_type <S2SV_ModStart> cpi ) ; else update_golden_frame_stats ( cpi ) ; } <S2SV_ModStart> frames_since_key ++ ; rc -> frames_to_key -- ; } if ( oxcf -> pass != 0 ) { cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ; rc -> frame_size_selector = rc -> next_frame_size_selector ; }
<S2SV_ModStart> update_buffer_level ( cpi , 0 ) ; cpi -> <S2SV_ModEnd> rc . frames_since_key ++ ; cpi -> rc . <S2SV_ModStart> ++ ; cpi -> rc . frames_to_key -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;
<S2SV_ModStart> int last_error = INT_MAX ; int i , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> -> MBs ; i = active_best_quality ; do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> <S2SV_ModStart> vp9_rc_bits_per_mb ( cm -> frame_type , i , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( <S2SV_ModStart> } while ( ++ i <= active_worst_quality ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
<S2SV_ModStart> -> rc ; rc -> this_frame_target = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi <S2SV_ModEnd> ) { const VP9_COMMON * const cm = & <S2SV_ModStart> ; double adjustment_limit ; int projected_size_based_on_q = 0 ; if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> frame_type , cm -> base_qindex , cm -> MBs <S2SV_ModStart> cm -> base_qindex , cm -> MBs , rate_correction_factor , cm -> bit_depth ) ; } if ( projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> if ( correction_factor > 102 ) { correction_factor =
<S2SV_ModStart> mbmi ; int64_t rd1 , rd2 , rd ; int rate ; int64_t dist ; int64_t sse ; if ( args -> exit_early <S2SV_ModEnd> ) return ; if ( ! is_inter_block ( mbmi <S2SV_ModStart> ; if ( ! is_inter_block ( mbmi ) ) { struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; vp9_encode_block_intra ( <S2SV_ModEnd> plane , block , plane_bsize , tx_size , & <S2SV_ModStart> plane , block , plane_bsize , tx_size , & arg ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) { <S2SV_ModEnd> vp9_xform_quant ( x , plane , block , plane_bsize <S2SV_ModStart> block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) { tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; if ( x -> plane [ plane ] . eobs [ block ] ) { const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; int64_t dc_correct = orig_sse - resd_sse * resd_sse ; # if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; # endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ; dist = MAX ( 0 , sse - dc_correct ) ; } } else { x -> plane [ plane ] . eobs [ block ] = 0 ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; if ( args -> this_rd + rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } rate = <S2SV_ModEnd> rate_block ( plane , block , plane_bsize , tx_size <S2SV_ModStart> ( x -> rdmult , x -> rddiv , rate , <S2SV_ModEnd> dist ) ; rd2 = RDCOST ( x -> <S2SV_ModStart> -> rdmult , x -> rddiv , 0 , <S2SV_ModEnd> sse ) ; rd = MIN ( rd1 , <S2SV_ModStart> xd -> lossless ) ; args -> this_rate += rate ; args -> this_dist += dist ; args -> this_sse += <S2SV_ModEnd> sse ; args -> this_rd += rd ; if <S2SV_ModStart> this_rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] == NONE || frame_mv [ this_mode ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int == 0 ) ) { int <S2SV_ModStart> 0 ) ) { int rfc = mode_context [ ref_frames [ 0 ] <S2SV_ModEnd> ] ; int c1 = cost_mv_ref ( cpi , <S2SV_ModStart> assert ( this_mode == ZEROMV ) ; if ( ref_frames [ 1 ] <S2SV_ModEnd> == NONE ) { if ( ( c3 >= <S2SV_ModStart> c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . as_int == 0 ) || ( c3 <S2SV_ModStart> c3 >= c1 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . as_int == 0 ) ) return 0 <S2SV_ModStart> c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int == 0 ) || ( c3 <S2SV_ModStart> c3 >= c1 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . as_int == 0 ) ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void choose_intra_uv_mode ( VP9_COMP * cpi , MACROBLOCK * const x <S2SV_ModStart> , int64_t * dist_uv , int * skip_uv , PREDICTION_MODE * mode_uv ) { <S2SV_ModEnd> if ( cpi -> sf . use_uv_intra_rd_estimate ) {
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> best_intra_mode ) { if ( mode == D117_PRED &&
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int cost_coeffs ( MACROBLOCK * x , int plane <S2SV_ModStart> = p -> eobs [ block ] ; const tran_low_t <S2SV_ModEnd> * const qcoeff = BLOCK_OFFSET ( p -> qcoeff <S2SV_ModStart> * L ) ; int c , cost ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModStart> mbmi -> tx_size == tx_size : get_uv_tx_size ( mbmi , pd <S2SV_ModStart> ; int v = qcoeff [ 0 ] ; int16_t prev_t ; EXTRABIT e ; vp9_get_token_extra ( v , & prev_t , & e ) <S2SV_ModEnd> ; cost = ( * token_costs ) [ 0 <S2SV_ModStart> 0 ] [ pt ] [ prev_t ] + vp9_get_cost ( prev_t , e , cat6_high_cost ) <S2SV_ModEnd> ; token_cache [ 0 ] = vp9_pt_energy_class [ prev_t <S2SV_ModStart> const int rc = scan [ c ] ; int16_t <S2SV_ModEnd> t ; v = qcoeff [ rc ] ; <S2SV_ModStart> t ; v = qcoeff [ rc ] ; vp9_get_token_extra ( v , & t , & e ) <S2SV_ModEnd> ; if ( use_fast_coef_costing ) { cost += ( <S2SV_ModStart> ] [ ! prev_t ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> ; } else { pt = get_coef_context ( nb <S2SV_ModStart> prev_t ] [ pt ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> ; token_cache [ rc ] = vp9_pt_energy_class [ t
<S2SV_ModStart> static int cost_mv_ref ( const VP9_COMP * cpi , PREDICTION_MODE mode , int mode_context <S2SV_ModEnd> ) { assert ( is_inter_mode ( mode ) ) <S2SV_ModStart> assert ( is_inter_mode ( mode ) ) ; return cpi <S2SV_ModEnd> -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode <S2SV_ModStart> mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void dist_block ( MACROBLOCK * x , <S2SV_ModStart> int plane , int block , TX_SIZE tx_size , int64_t * out_dist , int64_t * out_sse <S2SV_ModEnd> ) { const int ss_txfrm_size = tx_size << 1 <S2SV_ModStart> ) { const int ss_txfrm_size = tx_size << 1 <S2SV_ModEnd> ; MACROBLOCKD * const xd = & x -> <S2SV_ModStart> = tx_size == TX_32X32 ? 0 : 2 ; tran_low_t <S2SV_ModEnd> * const coeff = BLOCK_OFFSET ( p -> coeff <S2SV_ModStart> BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff <S2SV_ModStart> BLOCK_OFFSET ( pd -> dqcoeff , block ) ; # if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ; * out_dist = vp9_highbd_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse , bd ) >> shift ; # else * out_dist <S2SV_ModEnd> = vp9_block_error ( coeff , dqcoeff , 16 << <S2SV_ModStart> << ss_txfrm_size , & this_sse ) >> shift ; # endif * out_sse <S2SV_ModEnd> = this_sse >> shift ; if ( x -> <S2SV_ModStart> ] * ( 1 << ss_txfrm_size ) ) >> # if CONFIG_VP9_HIGHBITDEPTH ( shift + 2 + ( bd - 8 ) * 2 ) ; # else ( shift + 2 ) ; # endif * out_dist += ( p >> 4 ) ; * out_sse <S2SV_ModEnd> += p ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> src = & p -> src . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , p -> src . <S2SV_ModStart> dst = & pd -> dst . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , pd -> dst . <S2SV_ModStart> -> mbmi ) ; const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ] <S2SV_ModEnd> ; for ( ref = 0 ; ref < <S2SV_ModStart> pd -> pre [ ref ] . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , pd -> pre [ <S2SV_ModStart> pre [ ref ] . stride ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> ( pre , pd -> pre [ ref ] <S2SV_ModStart> MI_SIZE + 4 * ( i / 2 ) , xd -> bd ) ; } else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , i , p -> src_diff ) <S2SV_ModStart> stride , dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> k = i ; for ( idy = 0 <S2SV_ModStart> int64_t ssz , rd , rd1 , rd2 ; tran_low_t <S2SV_ModEnd> * coeff ; k += ( idy * 2 <S2SV_ModStart> coeff , k ) ; x -> fwd_txm4x4 ( vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , k , p -> src_diff ) <S2SV_ModStart> so -> scan , so -> iscan ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> k ) , 16 , & ssz ) ; } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd <S2SV_ModEnd> , int segment_id , unsigned int * ref_costs_single , <S2SV_ModStart> int * ref_costs_single , unsigned int * ref_costs_comp , vpx_prob * comp_mode_p ) { int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <S2SV_ModEnd> ( ref_costs_single , 0 , MAX_REF_FRAMES * sizeof ( <S2SV_ModStart> MAX_REF_FRAMES * sizeof ( * ref_costs_single ) ) ; memset <S2SV_ModEnd> ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( <S2SV_ModStart> ; * comp_mode_p = 128 ; } else { vpx_prob <S2SV_ModEnd> intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; <S2SV_ModStart> intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; vpx_prob <S2SV_ModEnd> comp_inter_p = 128 ; if ( cm -> reference_mode <S2SV_ModStart> if ( cm -> reference_mode != COMPOUND_REFERENCE ) { vpx_prob <S2SV_ModEnd> ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <S2SV_ModStart> ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; vpx_prob <S2SV_ModEnd> ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <S2SV_ModStart> if ( cm -> reference_mode != SINGLE_REFERENCE ) { vpx_prob <S2SV_ModEnd> ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ;
<S2SV_ModStart> ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int * rate2 , int64_t <S2SV_ModEnd> * distortion , int * skippable , int * <S2SV_ModStart> , int * skippable , int * rate_y , int * rate_uv , int * disable_skip <S2SV_ModEnd> , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] <S2SV_ModStart> , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) <S2SV_ModStart> ] , int64_t * psse , const int64_t ref_best_rd , int64_t * mask_filter , int64_t filter_cache [ ] <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const int is_comp_pred = has_second_ref ( mbmi ) <S2SV_ModEnd> ; const int this_mode = mbmi -> mode ; <S2SV_ModStart> ) } ; int_mv cur_mv [ 2 ] ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , tmp_buf16 [ MAX_MB_PLANE * 64 * 64 ] ) ; uint8_t * tmp_buf ; # else DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf [ MAX_MB_PLANE * 64 * 64 ] ) ; # endif <S2SV_ModEnd> int pred_exists = 0 ; int intpel_mv ; int64_t <S2SV_ModStart> = 0 ; int intpel_mv ; int64_t rd , tmp_rd , <S2SV_ModStart> [ MAX_MB_PLANE ] ; int rs = 0 ; INTERP_FILTER best_filter = SWITCHABLE ; uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = { 0 } ; int64_t bsse [ MAX_MB_PLANE << 2 ] = { 0 } ; int bsl = mi_width_log2_lookup [ bsize ] ; int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int skip_txfm_sb = 0 ; int64_t skip_sse_sb = INT64_MAX ; int64_t distortion_y = 0 , distortion_uv = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ; } else { tmp_buf = ( uint8_t * ) tmp_buf16 ; } # endif if ( pred_filter_search ) { INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ; if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ; if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ; } <S2SV_ModStart> ] . as_int == INVALID_MV ) return INT64_MAX ; if ( cpi -> sf . adaptive_mode_search ) { if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ; } <S2SV_ModStart> refs [ 0 ] ] . as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ refs [ 0 ] ] [ <S2SV_ModStart> refs [ 1 ] ] . as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ refs [ 1 ] ] [ <S2SV_ModStart> int_mv tmp_mv ; single_motion_search ( cpi , x , <S2SV_ModEnd> bsize , mi_row , mi_col , & tmp_mv , <S2SV_ModStart> tmp_mv . as_int == INVALID_MV ) return INT64_MAX ; frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) { * rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ; } else { * rate2 += rate_mv ; } <S2SV_ModEnd> } } for ( i = 0 ; i <S2SV_ModStart> } for ( i = 0 ; i < is_comp_pred + 1 <S2SV_ModEnd> ; ++ i ) { cur_mv [ i ] <S2SV_ModStart> [ i ] . dst . stride ; } if ( discount_newmv_test ( cpi , this_mode , frame_mv [ refs [ 0 ] ] , mode_mv , refs [ 0 ] ) ) { * rate2 += MIN ( cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) , cost_mv_ref ( cpi , NEARESTMV , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ) ; } else { <S2SV_ModStart> * rate2 += cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ; } if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && mbmi -> mode != NEARESTMV ) return INT64_MAX <S2SV_ModEnd> ; pred_exists = 0 ; intpel_mv = ! mv_has_subpel <S2SV_ModStart> -> mv [ 1 ] . as_mv ) ; <S2SV_ModEnd> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS <S2SV_ModStart> 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache <S2SV_ModEnd> [ i ] = INT64_MAX ; if ( cm <S2SV_ModStart> if ( cm -> interp_filter != BILINEAR ) { <S2SV_ModEnd> if ( x -> source_variance < cpi -> sf <S2SV_ModStart> source_variance < cpi -> sf . disable_filter_search_var_thresh ) { best_filter = EIGHTTAP ; } else if ( best_filter == SWITCHABLE ) <S2SV_ModEnd> { int newbest ; int tmp_rate_sum = 0 ; <S2SV_ModStart> i ) { int j ; int64_t rs_rd ; int tmp_skip_sb = 0 ; int64_t tmp_skip_sse = INT64_MAX ; <S2SV_ModStart> -> interp_filter = i ; rs = vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; rs_rd = RDCOST ( x -> rdmult <S2SV_ModStart> x -> rddiv , tmp_rate_sum , tmp_dist_sum ) ; filter_cache [ i ] = rd ; filter_cache [ SWITCHABLE_FILTERS ] = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_ModStart> -> interp_filter == SWITCHABLE ) rd += rs_rd ; * mask_filter = MAX ( * mask_filter <S2SV_ModEnd> , rd ) ; } else { int rate_sum <S2SV_ModStart> rate_sum = 0 ; int64_t dist_sum = 0 ; if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) { rate_sum = INT_MAX ; dist_sum = INT64_MAX ; continue ; } <S2SV_ModStart> x , xd , & rate_sum , & dist_sum , & tmp_skip_sb , & tmp_skip_sse <S2SV_ModStart> x -> rddiv , rate_sum , dist_sum ) ; filter_cache [ i ] = rd ; filter_cache [ SWITCHABLE_FILTERS ] = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_ModStart> -> interp_filter == SWITCHABLE ) rd += rs_rd ; * mask_filter = MAX ( * mask_filter <S2SV_ModEnd> , rd ) ; if ( i == 0 <S2SV_ModStart> if ( newbest ) { best_rd = rd ; <S2SV_ModEnd> best_filter = mbmi -> interp_filter ; if ( cm <S2SV_ModStart> -> interp_filter ) ) { pred_exists = 1 ; tmp_rd = best_rd ; skip_txfm_sb = tmp_skip_sb ; skip_sse_sb = tmp_skip_sse ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; <S2SV_ModStart> -> interp_filter != SWITCHABLE ? cm -> interp_filter : <S2SV_ModEnd> best_filter ; rs = cm -> interp_filter == SWITCHABLE <S2SV_ModStart> = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) : 0 ; if ( pred_exists ) { <S2SV_ModStart> . dst . stride = 64 ; } } rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; } else { int tmp_rate ; int64_t tmp_dist ; <S2SV_ModEnd> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize <S2SV_ModStart> xd , mi_row , mi_col , bsize ) ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; } if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ; if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ; <S2SV_ModEnd> if ( cpi -> sf . use_rd_breakout && ref_best_rd <S2SV_ModStart> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { <S2SV_ModEnd> if ( rd / 2 > ref_best_rd ) { <S2SV_ModStart> cm -> interp_filter == SWITCHABLE ) * rate2 += rs ; memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( x -> bsse , bsse , sizeof ( bsse ) ) ; if ( ! skip_txfm_sb ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; vp9_subtract_plane ( x , bsize , 0 ) ; super_block_yrd ( cpi , x , rate_y , & distortion_y , & skippable_y , psse , bsize , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; if ( ! super_block_uvrd ( cpi , x , rate_uv , & distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv ; * distortion += distortion_uv ; * skippable = skippable_y && skippable_uv ; } else { x -> skip = 1 ; * disable_skip <S2SV_ModEnd> = 1 ; * rate2 += vp9_cost_bit ( vp9_get_skip_prob <S2SV_ModStart> cm , xd ) , 1 ) ; * distortion = skip_sse_sb ; } if ( ! is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable <S2SV_ModEnd> ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) <S2SV_ModStart> ( xd , orig_dst , orig_dst_stride ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> MAX_REF_FRAMES ] , int * rate_mv ) { const VP9_COMMON * const cm = & cpi -> common ; const <S2SV_ModStart> [ 2 ] ; int ite , ref ; const InterpKernel * kernel = vp9_filter_kernels [ mbmi -> interp_filter ] ; struct scale_factors sf <S2SV_ModEnd> ; struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE <S2SV_ModStart> buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ; <S2SV_ModEnd> int last_besterr [ 2 ] = { INT_MAX , <S2SV_ModStart> mbmi -> ref_frame [ 1 ] ) } ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <S2SV_ModStart> ++ ref ) { ref_mv [ ref ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ refs [ ref ] ] [ <S2SV_ModStart> refs [ ref ] ] . as_int ; } # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <S2SV_ModStart> INT_MAX ; int sadpb = x -> sadperbit16 ; MV <S2SV_ModEnd> tmp_mv ; int search_range = 3 ; int tmp_col_min <S2SV_ModStart> [ 0 ] . pre [ 1 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <S2SV_ModStart> [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <S2SV_ModEnd> plane [ 0 ] . pre [ 0 ] <S2SV_ModStart> ref_mv [ id ] . as_mv ) ; tmp_mv <S2SV_ModEnd> = frame_mv [ refs [ id ] ] . <S2SV_ModStart> = frame_mv [ refs [ id ] ] . as_mv ; tmp_mv . col >>= 3 ; tmp_mv . <S2SV_ModEnd> row >>= 3 ; bestsme = vp9_refining_search_8p_c ( x <S2SV_ModStart> ; bestsme = vp9_refining_search_8p_c ( x , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] . as_mv , second_pred <S2SV_ModEnd> ) ; if ( bestsme < INT_MAX ) bestsme <S2SV_ModStart> ) bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv <S2SV_ModEnd> , & ref_mv [ id ] . as_mv , <S2SV_ModStart> ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , & tmp_mv , & ref_mv [ id ] . as_mv , <S2SV_ModEnd> cpi -> common . allow_high_precision_mv , x -> errorperbit <S2SV_ModStart> bsize ] , 0 , cpi -> sf . mv . subpel_iters_per_step , NULL , <S2SV_ModEnd> x -> nmvjointcost , x -> mvcost , & <S2SV_ModStart> [ 0 ] . pre [ 0 ] = ref_yv12 [ 0 ] <S2SV_ModEnd> ; if ( bestsme < last_besterr [ id ] <S2SV_ModStart> { frame_mv [ refs [ id ] ] . as_mv = tmp_mv <S2SV_ModEnd> ; last_besterr [ id ] = bestsme ; } <S2SV_ModStart> refs [ ref ] ] . as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ refs [ ref ] ] [ <S2SV_ModStart> , x -> mvcost , MV_COST_WEIGHT ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> buf = & p -> src . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , p -> src . <S2SV_ModStart> pd -> pre [ 0 ] . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , pd -> pre [ <S2SV_ModStart> pd -> pre [ 1 ] . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , i , pd -> pre [
<S2SV_ModStart> xd , int * out_rate_sum , int64_t * out_dist_sum , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> . ref_frame [ 0 ] ; unsigned int sse ; unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 <S2SV_ModStart> bs = get_plane_block_size ( bsize , pd ) ; const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = p -> src . buf + ( idy * p -> src . stride << lh ) + ( idx << lw ) ; uint8_t * dst = pd -> dst . buf + ( idy * pd -> dst . stride << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride , & sse ) ; x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; if ( ! x -> select_tx_size ) { if ( var < ac_thr || var == 0 ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> pred_sse [ ref ] += sse ; } } total_sse += sum_sse ; if ( cpi -> sf . simple_model_rd_from_var ) { int64_t rate ; const int64_t square_error = sum_sse ; int quantizer = ( pd -> dequant [ 1 ] >> dequant_shift <S2SV_ModEnd> ) ; if ( quantizer < 120 ) rate <S2SV_ModStart> rate ; dist_sum += dist ; } else { vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift <S2SV_ModEnd> , & rate , & dist ) ; rate_sum <S2SV_ModStart> rate ; dist_sum += dist ; } } * skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> rate_block ( int plane , int block , BLOCK_SIZE <S2SV_ModStart> block , & x_idx , & y_idx ) ; return <S2SV_ModEnd> cost_coeffs ( args -> x , plane , block
<S2SV_ModStart> VP9_COMP * cpi , MACROBLOCK * x , int row , int col , PREDICTION_MODE <S2SV_ModEnd> * best_mode , const int * bmode_costs , ENTROPY_CONTEXT <S2SV_ModStart> bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) { PREDICTION_MODE <S2SV_ModEnd> mode ; MACROBLOCKD * const xd = & x <S2SV_ModStart> src_init = & p -> src . buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; uint8_t * dst_init = & pd -> <S2SV_ModStart> dst_init = & pd -> dst . buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; ENTROPY_CONTEXT ta [ 2 ] , tempa <S2SV_ModStart> ; uint8_t best_dst [ 8 * 8 ] ; # if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ; # endif memcpy <S2SV_ModEnd> ( ta , a , sizeof ( ta ) <S2SV_ModStart> , a , sizeof ( ta ) ) ; memcpy <S2SV_ModEnd> ( tl , l , sizeof ( tl ) <S2SV_ModStart> 0 ] -> mbmi . tx_size = TX_4X4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> mode , * best_mode ) ) continue ; } memcpy <S2SV_ModEnd> ( tempa , ta , sizeof ( ta ) <S2SV_ModStart> , ta , sizeof ( ta ) ) ; memcpy <S2SV_ModEnd> ( templ , tl , sizeof ( tl ) <S2SV_ModStart> ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) <S2SV_ModEnd> ; const uint8_t * const src = & src_init <S2SV_ModStart> * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , block , p -> src_diff ) <S2SV_ModStart> BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t <S2SV_ModEnd> * const coeff = BLOCK_OFFSET ( x -> plane <S2SV_ModStart> ] . as_mode = mode ; vp9_predict_intra_block ( xd <S2SV_ModEnd> , 1 , TX_4X4 , mode , x -> <S2SV_ModStart> ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_highbd_subtract_block <S2SV_ModEnd> ( 4 , 4 , src_diff , 8 , <S2SV_ModStart> 8 , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( xd -> <S2SV_ModEnd> lossless ) { const scan_order * so = & <S2SV_ModStart> * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_highbd_fwht4x4 <S2SV_ModEnd> ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 <S2SV_ModStart> , ratey , distortion ) >= best_rd ) goto next_highbd ; vp9_highbd_iwht4x4_add <S2SV_ModEnd> ( BLOCK_OFFSET ( pd -> dqcoeff , block ) <S2SV_ModStart> , dst_stride , p -> eobs [ block ] , xd -> bd <S2SV_ModStart> & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ; else vp9_highbd_fht4x4 <S2SV_ModEnd> ( src_diff , coeff , 8 , tx_type ) <S2SV_ModStart> cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_highbd_block_error <S2SV_ModEnd> ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , <S2SV_ModStart> dqcoeff , block ) , 16 , & unused , xd -> bd <S2SV_ModStart> , ratey , distortion ) >= best_rd ) goto next_highbd ; vp9_highbd_iht4x4_add <S2SV_ModEnd> ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , <S2SV_ModStart> , dst_stride , p -> eobs [ block ] , xd -> bd <S2SV_ModStart> best_rd = this_rd ; * best_mode = mode ; memcpy <S2SV_ModEnd> ( a , tempa , sizeof ( tempa ) <S2SV_ModStart> , tempa , sizeof ( tempa ) ) ; memcpy <S2SV_ModEnd> ( l , templ , sizeof ( templ ) <S2SV_ModStart> idy < num_4x4_blocks_high * 4 ; ++ idy ) { memcpy ( best_dst16 + idy * 8 , CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ; } } next_highbd <S2SV_ModEnd> : { } } if ( best_rd >= rd_thresh <S2SV_ModStart> idy < num_4x4_blocks_high * 4 ; ++ idy ) { memcpy ( CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , best_dst16 + idy * 8 , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ; } return best_rd ; } # endif for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } memcpy ( tempa , ta , sizeof ( ta ) ) ; memcpy ( templ , tl , sizeof ( tl ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) ; const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_fwht4x4 ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; memcpy ( a , tempa , sizeof ( tempa ) ) ; memcpy ( l , templ , sizeof ( templ ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ; } next : { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ; return best_rd ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> MACROBLOCKD * xd = & x -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , <S2SV_ModStart> , this_rate , s ; int64_t this_distortion , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <S2SV_ModStart> 0 ] -> mbmi . uv_mode = mode ; if ( ! <S2SV_ModStart> s , & this_sse , bsize , best_rd ) ) continue ; this_rate = this_rate_tokenonly + cpi <S2SV_ModEnd> -> intra_uv_mode_cost [ cpi -> common . frame_type ] <S2SV_ModStart> skippable = s ; if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <S2SV_ModEnd> } } xd -> mi [ 0 ] ->
<S2SV_ModStart> , int * skippable , BLOCK_SIZE bsize , int64_t best_rd ) { PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = DC_PRED ; MACROBLOCKD * const xd = <S2SV_ModStart> , this_rd ; TX_SIZE best_tx = TX_4X4 ; int * bmode_costs ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi ; const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = cpi <S2SV_ModEnd> -> y_mode_costs [ A ] [ L ] ; <S2SV_ModStart> -> y_mode_costs [ A ] [ L ] ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { if ( cpi -> sf . use_nonrd_pick_mode ) { if ( conditional_skipintra ( mode , mode_selected ) ) continue ; if ( * skippable ) break ; <S2SV_ModStart> } mic -> mbmi . mode = mode ; super_block_yrd <S2SV_ModEnd> ( cpi , x , & this_rate_tokenonly , & <S2SV_ModStart> & this_distortion , & s , NULL , bsize <S2SV_ModEnd> , best_rd ) ; if ( this_rate_tokenonly == INT_MAX <S2SV_ModStart> = this_distortion ; * skippable = s ; } } <S2SV_ModEnd> mic -> mbmi . mode = mode_selected ; mic
<S2SV_ModStart> ] ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi <S2SV_ModEnd> ; const BLOCK_SIZE bsize = xd -> mi [ <S2SV_ModStart> [ 4 ] ; const int * bmode_costs = cpi -> mbmode_cost ; memcpy <S2SV_ModEnd> ( t_above , xd -> plane [ 0 ] <S2SV_ModStart> . above_context , sizeof ( t_above ) ) ; memcpy <S2SV_ModEnd> ( t_left , xd -> plane [ 0 ] <S2SV_ModStart> idx < 2 ; idx += num_4x4_blocks_wide ) { PREDICTION_MODE <S2SV_ModEnd> best_mode = DC_PRED ; int r = INT_MAX , <S2SV_ModStart> -> common . frame_type == KEY_FRAME ) { const PREDICTION_MODE <S2SV_ModEnd> A = vp9_above_block_mode ( mic , above_mi , i <S2SV_ModStart> ( mic , above_mi , i ) ; const PREDICTION_MODE <S2SV_ModEnd> L = vp9_left_block_mode ( mic , left_mi , i <S2SV_ModStart> mic , left_mi , i ) ; bmode_costs = cpi <S2SV_ModEnd> -> y_mode_costs [ A ] [ L ] ; <S2SV_ModStart> } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <S2SV_ModEnd> , & best_mode , bmode_costs , t_above + idx
<S2SV_ModStart> 0 ] -> mbmi . uv_mode = DC_PRED ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> INT64_MAX ) ; * rate = * rate_tokenonly + cpi <S2SV_ModEnd> -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED
<S2SV_ModStart> ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_ModEnd> BLOCK_SIZE bsize , int mi_row , int mi_col , <S2SV_ModStart> MACROBLOCKD * xd = & x -> e_mbd ; const <S2SV_ModStart> buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 , 0 <S2SV_ModStart> } } ; int bestsme = INT_MAX ; int <S2SV_ModEnd> step_param ; int sadpb = x -> sadperbit16 ; <S2SV_ModStart> -> ref_frame [ 0 ] ; MV ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ ref ] [ 0 ] . <S2SV_ModStart> -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> [ 3 ] ; pred_mv [ 0 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ ref ] [ 0 ] . <S2SV_ModStart> ] . as_mv ; pred_mv [ 1 ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ ref ] [ 1 ] . <S2SV_ModStart> 2 ] = x -> pred_mv [ ref ] <S2SV_ModEnd> ; if ( scaled_ref_frame ) { int i ; <S2SV_ModStart> ref_mv ) ; if ( cpi -> sf . mv . auto_mv_step_size && cm -> show_frame ) { step_param = ( vp9_init_search_range ( <S2SV_ModEnd> x -> max_mv_context [ ref ] ) + cpi <S2SV_ModStart> [ ref ] ) + cpi -> mv_step_param ) / 2 <S2SV_ModEnd> ; } else { step_param = cpi -> mv_step_param <S2SV_ModStart> cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 ) { int boffset = 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) ; step_param = MAX ( step_param , <S2SV_ModStart> ] ; int bhl = b_height_log2_lookup [ bsize ] <S2SV_ModEnd> ; int tlevel = x -> pred_mv_sad [ ref <S2SV_ModStart> ( tlevel < 5 ) step_param += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> ( i = LAST_FRAME ; i <= ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; ++ i ) { if ( ( <S2SV_ModStart> ) { x -> pred_mv [ ref ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 ; tmp_mv -> as_int = INVALID_MV ; <S2SV_ModStart> ( i = 0 ; i < MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd -> plane [ i ] . pre <S2SV_ModStart> = backup_yv12 [ i ] ; } return ; } <S2SV_ModStart> >>= 3 ; mvp_full . row >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x , & tmp_mv -> as_mv , & <S2SV_ModStart> , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref ] , NULL , 0 , 0 ) ; } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; if ( cpi -> sf . adaptive_motion_search ) x -> pred_mv [ ref ] = tmp_mv -> as_mv <S2SV_ModEnd> ; if ( scaled_ref_frame ) { int i ;
<S2SV_ModStart> x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable <S2SV_ModEnd> ) { MACROBLOCKD * const xd = & x <S2SV_ModStart> -> skip = x -> skip ; ctx -> skippable = skippable ; ctx -> <S2SV_ModStart> xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> ; ctx -> single_pred_diff = ( int ) comp_pred_diff <S2SV_ModStart> = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ; memcpy <S2SV_ModEnd> ( ctx -> best_filter_diff , best_filter_diff , sizeof (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * <S2SV_ModStart> xd -> mi [ 0 ] -> mbmi ; const TX_SIZE uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <S2SV_ModEnd> ) ; int plane ; int pnrate = 0 <S2SV_ModStart> ; int64_t pndist = 0 , pnsse = 0 ; int is_cost_valid = 1 ; if ( ref_best_rd < 0 ) is_cost_valid = 0 ; if ( is_inter_block ( mbmi ) && is_cost_valid <S2SV_ModEnd> ) { int plane ; for ( plane = <S2SV_ModStart> & pnsse , ref_best_rd , plane , bsize , uv_tx_size <S2SV_ModEnd> , cpi -> sf . use_fast_coef_costing ) ; if <S2SV_ModStart> use_fast_coef_costing ) ; if ( pnrate == INT_MAX ) { is_cost_valid = 0 ; break ; } <S2SV_ModEnd> * rate += pnrate ; * distortion += pndist <S2SV_ModStart> += pnsse ; * skippable &= pnskip ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int m , int n , int min_plane , int max_plane ) { int i ; for ( i = min_plane ; i < max_plane ; ++ i ) { struct macroblock_plane * const p = & x -> plane [ i ] ; struct macroblockd_plane * const pd = & x -> e_mbd . plane [ i ] ; p -> <S2SV_ModEnd> coeff = ctx -> coeff_pbuf [ i ] [ <S2SV_ModStart> coeff = ctx -> coeff_pbuf [ i ] [ m ] ; p -> <S2SV_ModEnd> qcoeff = ctx -> qcoeff_pbuf [ i ] [ <S2SV_ModStart> qcoeff = ctx -> qcoeff_pbuf [ i ] [ m ] ; pd -> <S2SV_ModEnd> dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ <S2SV_ModStart> dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ m ] ; p -> <S2SV_ModEnd> eobs = ctx -> eobs_pbuf [ i ] [ <S2SV_ModStart> eobs = ctx -> eobs_pbuf [ i ] [ m ] ; ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ; ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ; ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ; ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ; ctx -> coeff_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> coeff ; ctx -> qcoeff_pbuf [ i ] [ <S2SV_ModStart> coeff ; ctx -> qcoeff_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> qcoeff ; ctx -> dqcoeff_pbuf [ i ] [ <S2SV_ModStart> qcoeff ; ctx -> dqcoeff_pbuf [ i ] [ n ] = pd -> <S2SV_ModEnd> dqcoeff ; ctx -> eobs_pbuf [ i ] [ <S2SV_ModStart> dqcoeff ; ctx -> eobs_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> eobs ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> plane [ plane ] ; struct rdcost_block_args args ; vp9_zero ( args ) <S2SV_ModEnd> ; args . x = x ; args . <S2SV_ModStart> best_rd = ref_best_rd ; args . use_fast_coef_costing = use_fast_coef_casting ; args . skippable = 1 <S2SV_ModStart> , & args ) ; if ( args . exit_early <S2SV_ModEnd> ) { * rate = INT_MAX ; * distortion <S2SV_ModStart> sse = args . this_sse ; * skippable = args . skippable <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int64_t vp9_block_error_c ( const tran_low_t * coeff , const tran_low_t <S2SV_ModEnd> * dqcoeff , intptr_t block_size , int64_t * ssz
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * x , int mi_row , int mi_col , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t <S2SV_ModStart> * const cm = & cpi -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModStart> & xd -> mi [ 0 ] -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> * const seg = & cm -> seg ; PREDICTION_MODE <S2SV_ModEnd> this_mode ; MV_REFERENCE_FRAME ref_frame , second_ref_frame ; unsigned char <S2SV_ModStart> = mbmi -> segment_id ; int comp_pred , i , k <S2SV_ModStart> [ MAX_REF_FRAMES ] = { { 0 } } ; INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] <S2SV_ModStart> VP9_ALT_FLAG } ; int64_t best_rd = best_rd_so_far ; int64_t <S2SV_ModEnd> best_pred_diff [ REFERENCE_MODES ] ; int64_t best_pred_rd [ REFERENCE_MODES <S2SV_ModStart> ; int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; MB_MODE_INFO best_mbmode ; int best_mode_skippable = 0 ; int midx , best_mode_index = - 1 <S2SV_ModEnd> ; unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp <S2SV_ModStart> [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; vpx_prob comp_mode_p ; int64_t best_intra_rd = INT64_MAX ; unsigned int best_pred_sse = UINT_MAX ; PREDICTION_MODE best_intra_mode = DC_PRED <S2SV_ModEnd> ; int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ <S2SV_ModStart> TX_SIZES ] ; int skip_uv [ TX_SIZES ] ; PREDICTION_MODE mode_uv [ TX_SIZES ] ; const int intra_cost_penalty = vp9_get_intra_cost_penalty ( cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ; int best_skip2 = 0 ; uint8_t ref_frame_skip_mask [ 2 ] = { 0 } ; uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = { 0 } ; int mode_skip_start = sf -> <S2SV_ModEnd> mode_skip_start + 1 ; const int * const rd_threshes <S2SV_ModStart> + 1 ; const int * const rd_threshes = rd_opt -> threshes <S2SV_ModEnd> [ segment_id ] [ bsize ] ; const int <S2SV_ModStart> bsize ] ; const int * const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ; int64_t mode_threshold [ MAX_MODES ] ; int * mode_map = tile_data -> mode_map [ bsize ] ; const int mode_search_skip_flags = sf -> mode_search_skip_flags ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; vp9_zero ( best_mbmode ) ; x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX ; estimate_ref_frame_costs ( cm , xd <S2SV_ModEnd> , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p <S2SV_ModStart> ; for ( i = 0 ; i < <S2SV_ModEnd> SWITCHABLE_FILTER_CONTEXTS ; i ++ ) best_filter_rd [ i ] <S2SV_ModStart> x -> pred_sse [ i ] = INT_MAX ; for ( i = 0 ; i < MB_MODE_COUNT ; ++ i ) { for ( k = 0 ; k < MAX_REF_FRAMES ; ++ k ) { single_inter_filter [ i ] [ k ] = SWITCHABLE ; single_skippable [ i ] [ k ] = 0 ; } } rd_cost -> rate <S2SV_ModEnd> = INT_MAX ; for ( ref_frame = LAST_FRAME ; <S2SV_ModStart> -> ref_frame_flags & flag_list [ ref_frame ] ) { assert ( get_ref_frame_buffer ( cpi , ref_frame ) != NULL ) ; setup_buffer_inter ( cpi , x <S2SV_ModEnd> , ref_frame , bsize , mi_row , mi_col , <S2SV_ModStart> ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { <S2SV_ModEnd> if ( ! ( cpi -> ref_frame_flags & flag_list <S2SV_ModStart> ref_frame_flags & flag_list [ ref_frame ] ) ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } else if ( sf -> <S2SV_ModEnd> reference_masking ) { for ( i = LAST_FRAME ; <S2SV_ModStart> x -> pred_mv_sad [ i ] ) { mode_skip_mask [ ref_frame ] |= INTER_NEAREST_NEAR_ZERO ; break ; } } } if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && get_segdata <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( <S2SV_ModStart> SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } } if ( ! segfeature_active <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_ModStart> -> oxcf . arnr_max_frames == 0 ) ) { ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> ; if ( frame_mv [ NEARMV ] [ ALTREF_FRAME <S2SV_ModStart> [ ALTREF_FRAME ] . as_int != 0 ) mode_skip_mask [ ALTREF_FRAME ] |= ( 1 << NEARMV <S2SV_ModEnd> ) ; if ( frame_mv [ NEARESTMV ] [ <S2SV_ModStart> [ ALTREF_FRAME ] . as_int != 0 ) mode_skip_mask [ ALTREF_FRAME ] |= ( 1 << NEARESTMV ) ; } } if ( cpi -> rc . is_src_frame_alt_ref ) { if ( sf -> alt_ref_search_fp ) { mode_skip_mask [ ALTREF_FRAME ] = 0 ; ref_frame_skip_mask [ 0 ] = ~ ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; } } if ( sf -> alt_ref_search_fp ) if ( ! cm -> show_frame && x -> pred_mv_sad [ GOLDEN_FRAME ] < INT_MAX ) if ( x -> pred_mv_sad [ ALTREF_FRAME ] > ( x -> pred_mv_sad [ GOLDEN_FRAME ] << 1 ) ) mode_skip_mask [ ALTREF_FRAME ] |= INTER_ALL ; if ( sf -> adaptive_mode_search ) { if ( cm -> show_frame && ! cpi -> rc . is_src_frame_alt_ref && cpi -> rc . frames_since_golden >= 3 ) if ( x -> pred_mv_sad [ GOLDEN_FRAME ] > ( x -> pred_mv_sad [ LAST_FRAME ] << 1 ) ) mode_skip_mask [ GOLDEN_FRAME ] |= INTER_ALL ; } if ( bsize > sf -> max_intra_bsize ) { ref_frame_skip_mask [ 0 ] |= ( 1 << INTRA_FRAME ) ; ref_frame_skip_mask [ 1 ] |= ( 1 << INTRA_FRAME ) ; } mode_skip_mask [ INTRA_FRAME ] |= ~ ( sf -> intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ) ; for ( i = 0 ; i <= LAST_NEW_MV_INDEX ; ++ i ) mode_threshold [ i ] = 0 ; for ( i = LAST_NEW_MV_INDEX + 1 ; i < MAX_MODES ; ++ i ) mode_threshold [ i ] = ( ( int64_t ) rd_threshes [ i ] * rd_thresh_freq_fact [ i ] ) >> 5 ; midx = sf -> schedule_mode_search ? mode_skip_start : 0 ; while ( midx > 4 ) { uint8_t end_pos = 0 ; for ( i = 5 ; i < midx ; ++ i ) { if ( mode_threshold [ mode_map [ i - 1 ] ] > mode_threshold [ mode_map [ i ] ] ) { uint8_t tmp = mode_map [ i ] ; mode_map [ i ] = mode_map [ i - 1 ] ; mode_map [ i - 1 ] = tmp ; end_pos = i ; } } midx = end_pos ; } for ( midx = 0 ; midx < MAX_MODES ; ++ midx ) { int mode_index = mode_map [ midx ] ; <S2SV_ModEnd> int mode_excluded = 0 ; int64_t this_rd = INT64_MAX <S2SV_ModStart> distortion_uv = 0 ; int skippable = 0 ; <S2SV_ModEnd> int this_skip2 = 0 ; int64_t total_sse = INT64_MAX <S2SV_ModStart> total_sse = INT64_MAX ; int early_term = 0 ; this_mode = vp9_mode_order [ mode_index ] . mode ; ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; if ( midx == mode_skip_start && best_mode_index >= 0 ) { switch ( best_mbmode <S2SV_ModEnd> . ref_frame [ 0 ] ) { case INTRA_FRAME <S2SV_ModStart> { case INTRA_FRAME : break ; case LAST_FRAME : ref_frame_skip_mask [ 0 ] |= LAST_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; break ; case GOLDEN_FRAME : ref_frame_skip_mask [ 0 ] |= GOLDEN_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; break ; case ALTREF_FRAME : ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= ALT_REF_MODE_MASK ; break ; case NONE : case <S2SV_ModStart> MAX_REF_FRAMES : assert ( 0 && "Invalid<S2SV_blank>Reference<S2SV_blank>frame" ) ; break ; } } if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) continue ; if ( mode_skip_mask [ ref_frame ] & ( 1 << this_mode ) ) continue ; if ( best_mode_skippable && sf -> schedule_mode_search ) mode_threshold [ mode_index ] <<= 1 ; if ( best_rd < mode_threshold [ mode_index ] ) continue ; if ( sf -> motion_field_mode_search ) { const int mi_width = MIN ( num_8x8_blocks_wide_lookup [ bsize ] , tile_info -> mi_col_end - mi_col ) ; const int mi_height = MIN ( num_8x8_blocks_high_lookup [ bsize ] , tile_info -> mi_row_end - mi_row ) ; const int bsl = mi_width_log2_lookup [ bsize ] ; int cb_partition_search_ctrl = ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; MB_MODE_INFO * ref_mbmi ; int const_motion = 1 ; int skip_ref_frame = ! cb_partition_search_ctrl ; MV_REFERENCE_FRAME rf = NONE ; int_mv ref_mv ; ref_mv . as_int = INVALID_MV ; if ( ( mi_row - 1 ) >= tile_info -> mi_row_start ) { ref_mv = xd -> mi [ - xd -> mi_stride ] -> mbmi . mv [ 0 ] ; rf = xd -> mi [ - xd -> mi_stride ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_width ; ++ i ) { ref_mbmi = & xd -> mi [ - xd -> mi_stride + i ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( ( mi_col - 1 ) >= tile_info -> mi_col_start ) { if ( ref_mv . as_int == INVALID_MV ) ref_mv = xd -> mi [ - 1 ] -> mbmi . mv [ 0 ] ; if ( rf == NONE ) rf = xd -> mi [ - 1 ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_height ; ++ i ) { ref_mbmi = & xd -> mi [ i * xd -> mi_stride - 1 ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( skip_ref_frame && this_mode != NEARESTMV && this_mode != NEWMV ) if ( rf > INTRA_FRAME ) if ( ref_frame != rf ) continue ; if ( const_motion ) if ( this_mode == NEARMV || this_mode == ZEROMV ) continue ; } <S2SV_ModEnd> comp_pred = second_ref_frame > INTRA_FRAME ; if ( comp_pred <S2SV_ModStart> INTRA_FRAME ; if ( comp_pred ) { if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && best_mode_index >= 0 && best_mbmode . ref_frame [ 0 ] == INTRA_FRAME <S2SV_ModEnd> ) continue ; mode_excluded = cm -> reference_mode == <S2SV_ModStart> if ( ref_frame == INTRA_FRAME ) { if ( sf -> adaptive_mode_search ) if ( ( x -> source_variance << num_pels_log2_lookup [ bsize ] ) > best_pred_sse <S2SV_ModEnd> ) continue ; if ( this_mode != DC_PRED ) <S2SV_ModStart> && this_mode <= TM_PRED ) ) { if ( best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> . ref_frame [ 0 ] > INTRA_FRAME ) continue <S2SV_ModStart> ) ) continue ; } } } else { const MV_REFERENCE_FRAME ref_frames [ 2 ] = { ref_frame , second_ref_frame } ; if ( ! check_best_zero_mv ( cpi , mbmi_ext -> mode_context , frame_mv , this_mode , ref_frames ) ) continue ; } mbmi -> mode = this_mode ; mbmi -> uv_mode = DC_PRED <S2SV_ModEnd> ; mbmi -> ref_frame [ 0 ] = ref_frame <S2SV_ModStart> == SWITCHABLE ? EIGHTTAP : cm -> interp_filter ; mbmi -> mv [ 0 ] . as_int = mbmi -> mv [ 1 ] . as_int = 0 ; <S2SV_ModStart> yv12_mb [ second_ref_frame ] [ i ] ; } <S2SV_ModEnd> if ( ref_frame == INTRA_FRAME ) { TX_SIZE uv_tx <S2SV_ModStart> ( ref_frame == INTRA_FRAME ) { TX_SIZE uv_tx ; struct macroblockd_plane * const pd = & xd -> plane [ 1 ] ; memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; super_block_yrd <S2SV_ModEnd> ( cpi , x , & rate_y , & <S2SV_ModStart> & distortion_y , & skippable , NULL , bsize <S2SV_ModEnd> , best_rd ) ; if ( rate_y == INT_MAX <S2SV_ModStart> uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize , pd -> subsampling_x , pd -> subsampling_y <S2SV_ModStart> uv_tx ] == INT_MAX ) { choose_intra_uv_mode ( cpi , x <S2SV_ModStart> mode_uv [ uv_tx ] ; rate2 = rate_y + cpi <S2SV_ModEnd> -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra <S2SV_ModStart> { this_rd = handle_inter_mode ( cpi , x , bsize , <S2SV_ModEnd> & rate2 , & distortion2 , & skippable , <S2SV_ModStart> distortion2 , & skippable , & rate_y , & rate_uv , & disable_skip , frame_mv , mi_row , mi_col , single_newmv , single_inter_filter , single_skippable , & total_sse , best_rd , & mask_filter , filter_cache <S2SV_ModEnd> ) ; if ( this_rd == INT64_MAX ) continue <S2SV_ModStart> ] ; } if ( ! disable_skip ) { <S2SV_ModEnd> if ( skippable ) { rate2 -= ( rate_y <S2SV_ModStart> { rate2 -= ( rate_y + rate_uv ) ; rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else if ( <S2SV_ModEnd> ref_frame != INTRA_FRAME && ! xd -> lossless ) <S2SV_ModStart> ; rate2 -= ( rate_y + rate_uv ) ; this_skip2 = 1 ; } } else <S2SV_ModEnd> { rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , <S2SV_ModStart> -> rddiv , rate2 , distortion2 ) ; } rd_variance_adjustment ( cpi , x , bsize , & this_rd , ref_frame , x -> source_variance ) ; <S2SV_ModStart> ; best_intra_mode = mbmi -> mode ; } } <S2SV_ModEnd> if ( ! disable_skip && ref_frame == INTRA_FRAME ) <S2SV_ModStart> MIN ( best_filter_rd [ i ] , this_rd ) <S2SV_ModEnd> ; } if ( this_rd < best_rd || x <S2SV_ModStart> as_int = 0 ; max_plane = 1 ; } else { best_pred_sse = x -> pred_sse [ ref_frame ] ; } rd_cost -> rate = rate2 ; rd_cost -> dist = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModEnd> ; best_rd = this_rd ; best_mbmode = * mbmi <S2SV_ModStart> best_mbmode = * mbmi ; best_skip2 = this_skip2 ; best_mode_skippable = skippable ; if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 1 , 0 , 0 , max_plane ) ; memcpy <S2SV_ModEnd> ( ctx -> zcoeff_blk , x -> zcoeff_blk [ <S2SV_ModStart> zcoeff_blk [ mbmi -> tx_size ] , sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * ctx -> num_4x4_blk ) ; if ( <S2SV_ModStart> ) && ( mode_index > MIN_EARLY_TERM_INDEX ) ) { <S2SV_ModEnd> int qstep = xd -> plane [ 0 ] <S2SV_ModStart> [ 1 ] ; int scale = 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; <S2SV_ModEnd> } else { if ( single_rd < best_pred_rd [ <S2SV_ModStart> if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; <S2SV_ModEnd> } if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] <S2SV_ModStart> -> interp_filter != BILINEAR ) { int64_t ref = filter_cache <S2SV_ModEnd> [ cm -> interp_filter == SWITCHABLE ? SWITCHABLE_FILTERS : <S2SV_ModStart> INT64_MAX ) adj_rd = 0 ; else if ( filter_cache [ i ] == INT64_MAX ) adj_rd = mask_filter - ref + 10 ; else adj_rd = filter_cache <S2SV_ModEnd> [ i ] - ref ; adj_rd += this_rd <S2SV_ModStart> best_filter_rd [ i ] , adj_rd ) ; } <S2SV_ModEnd> } } if ( early_term ) break ; if <S2SV_ModStart> && ! comp_pred ) break ; } if ( best_mbmode . mode == NEWMV ) { const MV_REFERENCE_FRAME refs [ 2 ] = { best_mbmode . ref_frame [ 0 ] , best_mbmode . ref_frame [ 1 ] } ; int comp_pred_mode = refs [ 1 ] > INTRA_FRAME ; if ( frame_mv [ NEARESTMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARESTMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARESTMV ; else if ( frame_mv [ NEARMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARMV ; else if ( best_mbmode . mv [ 0 ] . as_int == 0 && ( ( comp_pred_mode && best_mbmode . mv [ 1 ] . as_int == 0 ) || ! comp_pred_mode ) ) best_mbmode . mode = ZEROMV ; } if ( best_mode_index < 0 || best_rd >= best_rd_so_far ) { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> use_uv_intra_rd_estimate ) { if ( best_mbmode <S2SV_ModEnd> . ref_frame [ 0 ] == INTRA_FRAME ) { <S2SV_ModStart> mbmi = best_mbmode ; uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <S2SV_ModStart> is_inter_block ( & best_mbmode ) ) ; if ( ! cpi -> rc . is_src_frame_alt_ref ) vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_mode_index ) ; <S2SV_ModEnd> * mbmi = best_mbmode ; x -> skip |= <S2SV_ModStart> ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; } else { vp9_zero ( best_filter_diff ) ; } x -> skip |= best_mode_skippable ; if ( ! x -> skip && ! x -> select_tx_size ) { int has_high_freq_coeff = 0 ; int plane ; int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ? MAX_MB_PLANE : 1 ; for ( plane = 0 ; plane < max_plane ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } for ( plane = max_plane ; plane < MAX_MB_PLANE ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } best_mode_skippable |= ! has_high_freq_coeff ; } assert ( best_mode_index >= 0 ) ; store_coding_context ( x , ctx , best_mode_index , best_pred_diff , best_filter_diff , best_mode_skippable ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( VP9_COMP * cpi , MACROBLOCK * x , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t <S2SV_ModStart> * const xd = & x -> e_mbd ; struct macroblockd_plane * const pd = xd -> plane ; <S2SV_ModStart> ; int64_t dist_y = 0 , dist_uv = 0 <S2SV_ModEnd> ; TX_SIZE max_uv_tx_size ; x -> skip_encode = 0 <S2SV_ModStart> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; <S2SV_ModStart> , & dist_y , & y_skip , bsize , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } <S2SV_ModEnd> } max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ <S2SV_ModStart> [ 0 ] -> mbmi . tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y <S2SV_ModStart> & rate_uv_tokenonly , & dist_uv , & uv_skip , MAX ( BLOCK_8X8 , bsize ) , max_uv_tx_size ) ; if ( y_skip && uv_skip ) { rd_cost -> rate <S2SV_ModEnd> = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly + <S2SV_ModStart> ( cm , xd ) , 1 ) ; rd_cost -> dist = dist_y + dist_uv ; } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } ctx -> mic = * xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( outlength16 >= inlength * 16 ) return filteredinterp_filters1000 <S2SV_ModEnd> ; else if ( outlength16 >= inlength * 13 <S2SV_ModStart> if ( outlength16 >= inlength * 13 ) return filteredinterp_filters875 <S2SV_ModEnd> ; else if ( outlength16 >= inlength * 11 <S2SV_ModStart> if ( outlength16 >= inlength * 11 ) return filteredinterp_filters750 <S2SV_ModEnd> ; else if ( outlength16 >= inlength * 9 <S2SV_ModStart> if ( outlength16 >= inlength * 9 ) return filteredinterp_filters625 ; else return filteredinterp_filters500 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , int length , uint8_t * output ) { <S2SV_ModEnd> const int16_t * filter = vp9_down2_symeven_half_filter ; const int
<S2SV_ModStart> , int length , uint8_t * output ) { <S2SV_ModEnd> const int16_t * filter = vp9_down2_symodd_half_filter ; const int
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> { memcpy ( output , input , sizeof ( output [ 0 ] <S2SV_ModEnd> ) * length ) ; return ; } steps
<S2SV_ModStart> ) * ( height + height2 ) ) ; assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ;
<S2SV_ModStart> <S2SV_null> static void calc_segtree_probs ( int * segcounts , vpx_prob <S2SV_ModEnd> * segment_tree_probs ) { const int c01 = segcounts
<S2SV_ModStart> <S2SV_null> static int cost_segmap ( int * segcounts , vpx_prob <S2SV_ModEnd> * probs ) { const int c01 = segcounts
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi <S2SV_ModEnd> , int * no_pred_segcounts , int ( * temporal_predictor_count <S2SV_ModStart> bh , int mi_row , int mi_col ) { <S2SV_ModEnd> int segment_id ; if ( mi_row >= cm -> <S2SV_ModStart> -> mi_cols ) return ; xd -> mi = mi <S2SV_ModEnd> ; segment_id = xd -> mi [ 0 ] <S2SV_ModStart> frame_type != KEY_FRAME ) { const BLOCK_SIZE bsize = xd -> mi <S2SV_ModEnd> [ 0 ] -> mbmi . sb_type ; const <S2SV_ModStart> -> mbmi . sb_type ; const int pred_segment_id = get_segment_id <S2SV_ModEnd> ( cm , cm -> last_frame_seg_map , bsize ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi <S2SV_ModEnd> , int * no_pred_segcounts , int ( * temporal_predictor_count <S2SV_ModStart> , int mi_col , BLOCK_SIZE bsize ) { const <S2SV_ModEnd> int mis = cm -> mi_stride ; int bw <S2SV_ModStart> -> mi_cols ) return ; bw = num_8x8_blocks_wide_lookup [ mi <S2SV_ModEnd> [ 0 ] -> mbmi . sb_type ] ; <S2SV_ModStart> mbmi . sb_type ] ; bh = num_8x8_blocks_high_lookup [ mi <S2SV_ModEnd> [ 0 ] -> mbmi . sb_type ] ; <S2SV_ModStart> bs && bh == bs ) { count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , <S2SV_ModStart> bs && bh < bs ) { count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs * mis , no_pred_segcounts , temporal_predictor_count , <S2SV_ModStart> bs && bh == bs ) { count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ; count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , <S2SV_ModStart> * ( n >> 1 ) ; count_segs_sb ( cm , xd , tile , & mi <S2SV_ModEnd> [ mi_dr * mis + mi_dc ] , no_pred_segcounts
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) { <S2SV_ModEnd> struct segmentation * seg = & cm -> seg <S2SV_ModStart> t_unpred_seg_counts [ MAX_SEGMENTS ] = { 0 } ; vpx_prob no_pred_tree [ SEG_TREE_PROBS ] ; vpx_prob t_pred_tree [ SEG_TREE_PROBS ] ; vpx_prob t_nopred_prob [ PREDICTION_PROBS ] ; memset <S2SV_ModEnd> ( seg -> tree_probs , 255 , sizeof ( <S2SV_ModStart> , sizeof ( seg -> tree_probs ) ) ; memset <S2SV_ModEnd> ( seg -> pred_probs , 255 , sizeof ( <S2SV_ModStart> log2_tile_cols ; tile_col ++ ) { TileInfo tile ; MODE_INFO * * mi_ptr ; <S2SV_ModStart> ; mi_row += 8 , mi_ptr += 8 * cm -> mi_stride ) { MODE_INFO * * <S2SV_ModEnd> mi = mi_ptr ; for ( mi_col = tile <S2SV_ModStart> += 8 , mi += 8 ) count_segs_sb ( cm , xd <S2SV_ModEnd> , & tile , mi , no_pred_segcounts , temporal_predictor_count <S2SV_ModStart> no_pred_cost ) { seg -> temporal_update = 1 ; memcpy <S2SV_ModEnd> ( seg -> tree_probs , t_pred_tree , sizeof ( <S2SV_ModStart> , t_pred_tree , sizeof ( t_pred_tree ) ) ; memcpy <S2SV_ModEnd> ( seg -> pred_probs , t_nopred_prob , sizeof ( <S2SV_ModStart> } else { seg -> temporal_update = 0 ; memcpy <S2SV_ModEnd> ( seg -> tree_probs , no_pred_tree , sizeof (
<S2SV_ModStart> seg ) { seg -> enabled = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ;
<S2SV_ModStart> abs_delta ) { seg -> abs_delta = abs_delta ; memcpy <S2SV_ModEnd> ( seg -> feature_data , feature_data , sizeof (
<S2SV_ModStart> , SPEED_FEATURES * sf , int speed ) { const int boosted = frame_is_boosted ( cpi ) ; sf -> adaptive_rd_thresh = 1 <S2SV_ModEnd> ; sf -> allow_skip_recode = 1 ; if ( <S2SV_ModStart> 1 ; if ( speed >= 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; } sf -> less_rectangular_check = 1 ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; sf -> mv . auto_mv_step_size = 1 ; sf -> adaptive_rd_thresh = 2 ; sf -> mv . subpel_iters_per_step = 1 ; sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 ; } if ( speed >= 2 ) { sf -> tx_size_search_method = frame_is_boosted ( cpi ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf <S2SV_ModStart> ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } if ( speed >= 3 ) { <S2SV_ModStart> ; } if ( speed >= 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> <S2SV_ModStart> ; sf -> mode_skip_start = 6 ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 ; } if ( speed >= 4 <S2SV_ModStart> ; sf -> tx_size_search_method = USE_LARGESTALL ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE ; sf -> adaptive_rd_thresh = 4 ; if ( cm -> frame_type != KEY_FRAME ) sf -> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ; sf <S2SV_ModStart> ; sf -> disable_filter_search_var_thresh = 200 ; sf -> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModEnd> ; } if ( speed >= 5 ) { <S2SV_ModStart> >= 5 ) { int i ; sf -> optimize_coefficients = 0 ; sf -> mv . <S2SV_ModEnd> search_method = HEX ; sf -> disable_filter_search_var_thresh = 500 <S2SV_ModStart> ) { sf -> intra_y_mode_mask [ i ] = INTRA_DC ; sf -> intra_uv_mode_mask [ i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void set_rt_speed_feature ( VP9_COMP * cpi , SPEED_FEATURES * sf , int speed , vp9e_tune_content content ) { VP9_COMMON * const cm = & cpi -> common ; const int is_keyframe = cm -> frame_type == KEY_FRAME ; const int frames_since_key = is_keyframe ? 0 : cpi -> rc . frames_since_key ; <S2SV_ModEnd> sf -> static_segmentation = 0 ; sf -> adaptive_rd_thresh <S2SV_ModStart> ; sf -> adaptive_rd_thresh = 1 ; sf -> use_fast_coef_costing = 1 ; if ( speed >= <S2SV_ModEnd> 1 ) { sf -> use_square_partition_only = ! frame_is_intra_only <S2SV_ModStart> frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; <S2SV_ModEnd> sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search <S2SV_ModStart> ; sf -> adaptive_pred_interp_filter = 1 ; sf -> mv . <S2SV_ModStart> ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V <S2SV_ModEnd> ; } if ( speed >= 2 ) { <S2SV_ModStart> if ( speed >= 2 ) { sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf <S2SV_ModStart> | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC && cpi -> svc . number_spatial_layers == 1 ) ? 1 : 0 <S2SV_ModEnd> ; sf -> disable_filter_search_var_thresh = 50 ; sf -> <S2SV_ModStart> ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; sf -> lf_motion_threshold = LOW_MOTION_THRESHOLD <S2SV_ModEnd> ; sf -> adjust_partitioning_from_last_frame = 1 ; sf -> <S2SV_ModStart> ; sf -> last_partitioning_redo_frequency = 3 ; sf -> <S2SV_ModEnd> use_lp32x32fdct = 1 ; sf -> mode_skip_start = 11 <S2SV_ModStart> -> mode_skip_start = 11 ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V <S2SV_ModEnd> ; } if ( speed >= 3 ) { <S2SV_ModStart> ; sf -> disable_filter_search_var_thresh = 100 ; sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate = 1 ; sf -> skip_encode_sb = 1 <S2SV_ModStart> ; sf -> skip_encode_sb = 1 ; sf -> mv . subpel_iters_per_step = 1 ; sf -> <S2SV_ModEnd> adaptive_rd_thresh = 4 ; sf -> mode_skip_start = 6 <S2SV_ModStart> disable_split_mask = DISABLE_ALL_SPLIT ; sf -> lpf_pick = LPF_PICK_FROM_Q <S2SV_ModEnd> ; } if ( speed >= 4 ) { <S2SV_ModStart> != cm -> frame_type || ( 0 == ( frames_since_key <S2SV_ModEnd> + 1 ) % sf -> last_partitioning_redo_frequency ) ; <S2SV_ModStart> ) % sf -> last_partitioning_redo_frequency ) ; sf -> mv . <S2SV_ModStart> INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ i ] = INTRA_DC <S2SV_ModEnd> ; } sf -> intra_y_mode_mask [ TX_32X32 ] = <S2SV_ModStart> ; } sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC <S2SV_ModEnd> ; sf -> frame_parameter_update = 0 ; sf -> <S2SV_ModStart> ; sf -> frame_parameter_update = 0 ; sf -> mv . search_method = FAST_HEX ; sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEAR_NEW ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST <S2SV_ModEnd> ; sf -> max_intra_bsize = BLOCK_32X32 ; sf -> <S2SV_ModStart> if ( speed >= 5 ) { sf -> use_quant_fp = ! is_keyframe ; sf -> auto_min_max_partition_size = is_keyframe ? RELAXED_NEIGHBORING_MIN_MAX : STRICT_NEIGHBORING_MIN_MAX ; sf -> default_max_partition_size = BLOCK_32X32 ; sf -> default_min_partition_size = BLOCK_8X8 ; sf -> force_frame_boost = is_keyframe || ( frames_since_key <S2SV_ModEnd> % ( sf -> last_partitioning_redo_frequency << 1 ) == <S2SV_ModStart> ) == 1 ) ; sf -> max_delta_qindex = is_keyframe <S2SV_ModEnd> ? 20 : 15 ; sf -> partition_search_type = <S2SV_ModStart> ; sf -> use_nonrd_pick_mode = 1 ; sf -> allow_skip_recode = 0 ; sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> adaptive_rd_thresh = 2 ; sf -> reuse_inter_pred_sby = 1 ; sf -> partition_search_breakout_rate_thr = 200 ; sf -> coeff_prob_appx_step = 4 ; sf -> use_fast_coef_updates = is_keyframe ? TWO_LOOP : ONE_LOOP_REDUCED ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH ; sf -> tx_size_search_method = is_keyframe ? USE_LARGESTALL : USE_TX_8X8 ; sf -> simple_model_rd_from_var = 1 ; if ( ! is_keyframe ) { int i ; if ( content == VP9E_CONTENT_SCREEN ) { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_TM_H_V ; } else { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) if ( i >= BLOCK_16X16 ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC ; else sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_H_V ; } } <S2SV_ModEnd> } if ( speed >= 6 ) { sf <S2SV_ModStart> speed >= 6 ) { sf -> partition_search_type = VAR_BASED_PARTITION <S2SV_ModEnd> ; sf -> use_nonrd_pick_mode = 1 ; sf -> <S2SV_ModStart> ; sf -> use_nonrd_pick_mode = 1 ; sf -> mv . search_method = NSTEP ; sf -> mv . reduce_first_step_size = 1 ; sf -> skip_encode_sb = 0 <S2SV_ModEnd> ; } if ( speed >= 7 ) { <S2SV_ModStart> ; } if ( speed >= 7 ) { sf -> adaptive_rd_thresh = 3 ; sf -> mv . search_method = FAST_DIAMOND ; sf -> mv . fullpel_search_step_param = 10 ; if ( cpi -> svc . number_temporal_layers > 2 && cpi -> svc . temporal_layer_id == 0 ) { sf -> mv . search_method = NSTEP ; sf -> mv . fullpel_search_step_param = 6 ; } } if ( speed >= 8 ) { sf -> adaptive_rd_thresh = 4 ; sf -> mv . subpel_force_stop = 2 ; sf -> lpf_pick = LPF_PICK_MINIMAL_LPF <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_term_subexp ( vpx_writer <S2SV_ModEnd> * w , int word ) { if ( <S2SV_ModStart> ( w , word , 16 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word , 4 ) ; } <S2SV_ModStart> ( w , word , 32 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word - 16 , 4 ) <S2SV_ModStart> ( w , word , 64 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word - 32 , 5 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_uniform ( vpx_writer <S2SV_ModEnd> * w , int v ) { const int <S2SV_ModStart> 191 ; if ( v < m ) { vpx_write_literal <S2SV_ModEnd> ( w , v , l - 1 ) <S2SV_ModStart> , l - 1 ) ; } else { vpx_write_literal <S2SV_ModEnd> ( w , m + ( ( v - <S2SV_ModStart> >> 1 ) , l - 1 ) ; vpx_write_literal <S2SV_ModEnd> ( w , ( v - m ) &
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int prob_diff_update_cost ( vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) { int delp = remap_prob ( newp
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_cond_prob_diff_update ( vpx_writer * w , vpx_prob <S2SV_ModEnd> * oldp , const unsigned int ct [ 2 <S2SV_ModStart> unsigned int ct [ 2 ] ) { const vpx_prob upd = DIFF_UPDATE_PROB ; vpx_prob <S2SV_ModEnd> newp = get_binary_prob ( ct [ 0 ] , <S2SV_ModStart> ) ; if ( savings > 0 ) { vpx_write <S2SV_ModEnd> ( w , 1 , upd ) ; vp9_write_prob_diff_update <S2SV_ModStart> ; * oldp = newp ; } else { vpx_write <S2SV_ModEnd> ( w , 0 , upd ) ; }
<S2SV_ModStart> int vp9_prob_diff_update_savings_search ( const unsigned int * ct , vpx_prob oldp , vpx_prob * bestp , vpx_prob <S2SV_ModEnd> upd ) { const int old_b = cost_branch256 ( <S2SV_ModStart> , oldp ) ; int bestsavings = 0 ; vpx_prob <S2SV_ModEnd> newp , bestnewp = oldp ; const int step
<S2SV_ModStart> vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , const vpx_prob * oldp , vpx_prob * bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , old_b , new_b , update_b , savings <S2SV_ModStart> savings , bestsavings , step ; int newp ; vpx_prob <S2SV_ModEnd> bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ <S2SV_ModStart> ] ; vp9_model_to_full_probs ( oldp , oldplist ) ; memcpy ( newplist , oldp , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES ) ; for ( i = <S2SV_ModStart> 0 ; bestnewp = oldp [ PIVOT_NODE ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> oldp [ PIVOT_NODE ] ; newp += step ) <S2SV_ModStart> = savings ; bestnewp = newp ; } } } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return bestsavings ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_write_prob_diff_update ( vpx_writer * w , vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) { const int delp = remap_prob (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE int write_bit_gte ( vpx_writer <S2SV_ModEnd> * w , int word , int test ) <S2SV_ModStart> w , int word , int test ) { vpx_write_literal <S2SV_ModEnd> ( w , word >= test , 1 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static LAYER_CONTEXT * get_layer_context ( VP9_COMP * const cpi ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] : & cpi -> svc . layer_context [ cpi -> svc . <S2SV_ModEnd> spatial_layer_id ] ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const svc = & cpi -> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> const oxcf = & cpi -> oxcf ; int sl , tl ; int alt_ref_idx = svc -> number_spatial_layers ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) { if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>" "contexts" ) ; memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ; } for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * const lrc = & lc -> rc ; int i ; lc -> current_video_frame_in_layer = 0 ; lc -> layer_size = 0 ; lc -> frames_from_key_frame = 0 ; lc -> last_frame_type = FRAME_TYPES ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { lrc -> rate_correction_factors [ i ] = 1.0 ; } if ( cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ; else lc -> alt_ref_idx = INVALID_IDX ; lc -> gold_ref_idx = INVALID_IDX ; } lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ; lrc -> bits_off_target = lrc -> buffer_level ; } } if ( ! ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) svc -> layer_context [ 0 ] . gold_ref_idx = alt_ref_idx ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < svc -> number_spatial_layers ; ++ i ) { TWO_PASS <S2SV_ModEnd> * const twopass = & svc -> layer_context [
<S2SV_ModStart> ) { LAYER_CONTEXT * const lc = get_layer_context ( cpi <S2SV_ModEnd> ) ; const int old_frame_since_key = cpi -> rc <S2SV_ModStart> . target_bandwidth = lc -> target_bandwidth ; cpi -> alt_ref_source = lc -> alt_ref_source <S2SV_ModEnd> ; if ( cpi -> svc . number_temporal_layers >
<S2SV_ModStart> vp9_save_layer_context ( VP9_COMP * const cpi ) { const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> oxcf ; LAYER_CONTEXT * const lc = get_layer_context ( cpi <S2SV_ModEnd> ) ; lc -> rc = cpi -> rc <S2SV_ModStart> ( int ) oxcf -> target_bandwidth ; lc -> alt_ref_source = cpi -> alt_ref_source <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const svc = & cpi -> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> const rc = & cpi -> rc ; int sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end ; if ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) { layer_end = svc -> number_temporal_layers ; } <S2SV_ModStart> RATE_CONTROL * const lrc = & lc -> rc ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; if ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ layer ] ; } else { lc -> framerate = cpi -> framerate ; } lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / <S2SV_ModEnd> lc -> framerate ) ; lrc -> max_frame_bandwidth = <S2SV_ModStart> lrc -> best_quality = rc -> best_quality ; } }
<S2SV_ModStart> * const cpi , double framerate ) { const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> oxcf ; LAYER_CONTEXT * const lc = get_layer_context ( cpi <S2SV_ModEnd> ) ; RATE_CONTROL * const lrc = & lc <S2SV_ModStart> ; lc -> framerate = framerate ; lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( int ) ( lc -> target_bandwidth / <S2SV_ModStart> -> min_frame_bandwidth = ( int ) ( lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf -> two_pass_vbrmin_section / 100 ) ; lrc <S2SV_ModStart> int ) ( ( ( int64_t ) lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf -> two_pass_vbrmax_section ) / 100 ) ; <S2SV_ModStart> * oxcf -> two_pass_vbrmax_section ) / 100 ) ; vp9_rc_set_gf_interval_range ( cpi , lrc ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const svc = & cpi -> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf = & cpi -> oxcf ; <S2SV_ModStart> oxcf ; LAYER_CONTEXT * const lc = get_layer_context ( cpi <S2SV_ModEnd> ) ; RATE_CONTROL * const lrc = & lc <S2SV_ModStart> lrc = & lc -> rc ; const int st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + svc -> temporal_layer_id ; const int tl <S2SV_ModEnd> = svc -> temporal_layer_id ; lc -> framerate = <S2SV_ModStart> = svc -> temporal_layer_id ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( int ) ( lc -> target_bandwidth / <S2SV_ModStart> = cpi -> rc . max_frame_bandwidth ; if ( tl <S2SV_ModEnd> == 0 ) { lc -> avg_frame_size = lrc <S2SV_ModStart> 0 ) { lc -> avg_frame_size = lrc -> avg_frame_bandwidth ; } else { const double prev_layer_framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl <S2SV_ModEnd> - 1 ] ; const int prev_layer_target_bandwidth = oxcf <S2SV_ModStart> 1 ] ; const int prev_layer_target_bandwidth = oxcf -> layer_target_bitrate [ st_idx - 1 ] <S2SV_ModEnd> ; lc -> avg_frame_size = ( int ) (
<S2SV_ModStart> * frame_ptr_buf , int stride ) { MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; MACROBLOCKD * const xd = & x <S2SV_ModStart> * const xd = & x -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> = x -> sadperbit16 ; int bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> pre [ 0 ] . stride = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS - 2 ) <S2SV_ModEnd> ; vp9_hex_search ( x , & best_ref_mv1_full , step_param <S2SV_ModStart> & best_ref_mv1_full , step_param , sadpb , 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> , 0 , & best_ref_mv1 , ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> x -> plane [ 0 ] . src =
<S2SV_ModStart> <S2SV_null> static void temporal_filter_iterate_c ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * * frames , <S2SV_ModStart> mb_row ; unsigned int filter_weight ; int mb_cols = ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 ; int mb_rows = ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 <S2SV_ModEnd> ; int mb_y_offset = 0 ; int mb_uv_offset = <S2SV_ModStart> mb_y_offset = 0 ; int mb_uv_offset = 0 ; DECLARE_ALIGNED ( 16 , unsigned int , accumulator [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED ( 16 , uint16_t , count [ 16 * 16 * 3 ] <S2SV_ModEnd> ) ; MACROBLOCKD * mbd = & cpi -> <S2SV_ModStart> ) ; MACROBLOCKD * mbd = & cpi -> td . mb . e_mbd ; YV12_BUFFER_CONFIG * f = <S2SV_ModEnd> frames [ alt_ref_index ] ; uint8_t * dst1 , <S2SV_ModStart> ] ; uint8_t * dst1 , * dst2 ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , predictor8 [ 16 * 16 * 3 ] ) ; uint8_t * predictor ; # else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ 16 * 16 * 3 ] ) ; # endif <S2SV_ModEnd> const int mb_uv_height = 16 >> mbd -> plane <S2SV_ModStart> mbd -> plane [ 1 ] . subsampling_y ; const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ; <S2SV_ModStart> * input_buffer [ MAX_MB_PLANE ] ; int i ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ; } else { predictor = predictor8 ; } # endif <S2SV_ModEnd> for ( i = 0 ; i < MAX_MB_PLANE <S2SV_ModStart> ; mb_row < mb_rows ; mb_row ++ ) { cpi -> td . <S2SV_ModEnd> mb . mv_row_min = - ( ( mb_row * <S2SV_ModStart> - 2 * VP9_INTERP_EXTEND ) ) ; cpi -> td . mb . mv_row_max = ( ( <S2SV_ModEnd> mb_rows - 1 - mb_row ) * 16 ) <S2SV_ModStart> + ( 17 - 2 * VP9_INTERP_EXTEND ) ; <S2SV_ModEnd> for ( mb_col = 0 ; mb_col < mb_cols <S2SV_ModStart> i , j , k ; int stride ; memset <S2SV_ModEnd> ( accumulator , 0 , 16 * 16 * <S2SV_ModStart> sizeof ( accumulator [ 0 ] ) ) ; memset <S2SV_ModEnd> ( count , 0 , 16 * 16 * <S2SV_ModStart> sizeof ( count [ 0 ] ) ) ; cpi -> td . <S2SV_ModEnd> mb . mv_col_min = - ( ( mb_col * <S2SV_ModStart> - 2 * VP9_INTERP_EXTEND ) ) ; cpi -> td . mb . mv_col_max = ( ( <S2SV_ModEnd> mb_cols - 1 - mb_col ) * 16 ) <S2SV_ModStart> + ( 17 - 2 * VP9_INTERP_EXTEND ) ; <S2SV_ModEnd> for ( frame = 0 ; frame < frame_count <S2SV_ModStart> ; frame < frame_count ; frame ++ ) { const int thresh_low = 10000 ; const int thresh_high = 20000 ; if ( <S2SV_ModEnd> frames [ frame ] == NULL ) continue ; <S2SV_ModStart> = 2 ; } else { int err = temporal_filter_find_matching_mb_c ( cpi , <S2SV_ModEnd> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_ModStart> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_ModEnd> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_ModStart> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> y_stride ) ; filter_weight = err < thresh_low ? 2 : err < thresh_high <S2SV_ModEnd> ? 1 : 0 ; } if ( filter_weight <S2SV_ModStart> filter_weight != 0 ) { temporal_filter_predictors_mb_c ( mbd , <S2SV_ModEnd> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_ModStart> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_ModEnd> frames [ frame ] -> u_buffer + mb_uv_offset , <S2SV_ModStart> frames [ frame ] -> u_buffer + mb_uv_offset , <S2SV_ModEnd> frames [ frame ] -> v_buffer + mb_uv_offset , <S2SV_ModStart> frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , <S2SV_ModEnd> mb_uv_height , mbd -> mi [ 0 ] -> <S2SV_ModStart> mb_col * 16 , mb_row * 16 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { int adj_strength = strength + 2 * ( mbd -> bd - 8 ) ; vp9_highbd_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , adj_strength , filter_weight , accumulator , count ) ; vp9_highbd_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_highbd_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 512 , count + 512 ) ; } else { <S2SV_ModStart> , f -> y_stride , predictor , 16 , 16 , <S2SV_ModStart> , f -> uv_stride , predictor + 256 , mb_uv_width , <S2SV_ModStart> , f -> uv_stride , predictor + 512 , mb_uv_width , <S2SV_ModStart> + 512 , count + 512 ) ; } # else vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uint16_t * dst1_16 ; uint16_t * dst2_16 ; dst1 = cpi -> alt_ref_buffer . y_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) <S2SV_ModEnd> ; stride = cpi -> alt_ref_buffer . y_stride ; <S2SV_ModStart> [ k ] >> 1 ) ; pval *= <S2SV_ModEnd> fixed_divide [ count [ k ] ] ; pval <S2SV_ModStart> [ k ] ] ; pval >>= 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; byte ++ ; } byte += <S2SV_ModStart> ; dst2 = cpi -> alt_ref_buffer . v_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ; dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ; <S2SV_ModStart> { for ( j = 0 ; j < mb_uv_width <S2SV_ModEnd> ; j ++ , k ++ ) { int <S2SV_ModStart> [ k ] >> 1 ) ; pval *= <S2SV_ModEnd> fixed_divide [ count [ k ] ] ; pval <S2SV_ModStart> [ k ] ] ; pval >>= 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; pval = accumulator [ m ] <S2SV_ModStart> [ m ] >> 1 ) ; pval *= <S2SV_ModEnd> fixed_divide [ count [ m ] ] ; pval <S2SV_ModStart> [ m ] ] ; pval >>= 19 ; dst2_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval ; byte ++ ; } byte += <S2SV_ModStart> ; byte ++ ; } byte += stride - mb_uv_width ; } } else { dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } } # else dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } # endif mb_y_offset += 16 ; mb_uv_offset += mb_uv_width ; } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) ; mb_uv_offset += mb_uv_height * f -> uv_stride - mb_uv_width * mb_cols <S2SV_ModEnd> ; } for ( i = 0 ; i
<S2SV_ModStart> , uint8_t * v_mb_ptr , int stride , int uv_block_width , int uv_block_height <S2SV_ModEnd> , int mv_row , int mv_col , uint8_t * <S2SV_ModStart> mv_col } ; const InterpKernel * const kernel = vp9_filter_kernels [ <S2SV_ModEnd> xd -> mi [ 0 ] -> mbmi . <S2SV_ModStart> -> mi [ 0 ] -> mbmi . interp_filter ] <S2SV_ModEnd> ; enum mv_precision mv_precision_uv ; int uv_stride ; if <S2SV_ModStart> enum mv_precision mv_precision_uv ; int uv_stride ; if ( uv_block_width <S2SV_ModEnd> == 8 ) { uv_stride = ( stride + <S2SV_ModStart> uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv , kernel , mv_precision_uv , x , <S2SV_ModStart> , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv , kernel , mv_precision_uv , x ,
<S2SV_ModStart> int stride , uint8_t * frame2 , unsigned int block_width , unsigned int block_height <S2SV_ModEnd> , int strength , int filter_weight , unsigned int <S2SV_ModStart> ; int modifier ; int byte = 0 ; const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ; <S2SV_ModStart> = 0 , k = 0 ; i < block_height <S2SV_ModEnd> ; i ++ ) { for ( j = <S2SV_ModStart> { for ( j = 0 ; j < block_width <S2SV_ModEnd> ; j ++ , k ++ ) { int <S2SV_ModStart> *= modifier ; modifier *= 3 ; modifier += rounding <S2SV_ModEnd> ; modifier >>= strength ; if ( modifier > <S2SV_ModStart> ; byte ++ ; } byte += stride - block_width <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> void add_token ( TOKENEXTRA * * t , const vpx_prob * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t token , uint8_t skip_eob_node , unsigned
<S2SV_ModStart> void add_token_no_extra ( TOKENEXTRA * * t , const vpx_prob <S2SV_ModEnd> * context_tree , uint8_t token , uint8_t skip_eob_node ,
<S2SV_ModStart> 16 << ( tx_size << 1 ) ; return segfeature_active <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_SKIP ) ? 0
<S2SV_ModStart> ) { struct is_skippable_args * args = argv ; ( void ) plane ; ( void ) plane_bsize ; ( void ) tx_size ; <S2SV_ModStart> skippable [ 0 ] &= ( ! args -> <S2SV_ModEnd> eobs [ block ] ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> { struct tokenize_b_args * const args = arg ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * p = & x -> <S2SV_ModEnd> plane [ plane ] ; struct macroblockd_plane * pd
<S2SV_ModStart> ; VP9_COMP * cpi = args -> cpi ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <S2SV_ModEnd> ; TOKENEXTRA * * tp = args -> tp <S2SV_ModStart> 32 ] ; struct macroblock_plane * p = & x -> <S2SV_ModEnd> plane [ plane ] ; struct macroblockd_plane * pd <S2SV_ModStart> const PLANE_TYPE type = pd -> plane_type ; const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <S2SV_ModEnd> ( * const coef_probs ) [ COEFF_CONTEXTS ] [ <S2SV_ModStart> [ UNCONSTRAINED_NODES ] = cpi -> common . fc -> <S2SV_ModEnd> coef_probs [ tx_size ] [ type ] [ ref <S2SV_ModStart> ( * const eob_branch ) [ COEFF_CONTEXTS ] = td -> counts -> <S2SV_ModEnd> eob_branch [ tx_size ] [ type ] [ ref <S2SV_ModStart> common . seg , segment_id , tx_size ) ; int16_t token ; EXTRABIT extra ; <S2SV_ModStart> qcoeff [ scan [ c ] ] ; } vp9_get_token_extra ( v , & token , & extra ) ; <S2SV_ModStart> band [ c ] ] [ pt ] , extra , ( uint8_t ) <S2SV_ModEnd> token , ( uint8_t ) skip_eob , counts [ <S2SV_ModStart> [ scan [ c ] ] = vp9_pt_energy_class [ <S2SV_ModEnd> token ] ; ++ c ; pt = get_coef_context
<S2SV_ModStart> = 1 ; struct is_skippable_args args = { x -> plane [ plane ] . eobs
<S2SV_ModStart> static unsigned int convert_distribution ( unsigned int i , vpx_tree <S2SV_ModEnd> tree , unsigned int branch_ct [ ] [ 2
<S2SV_ModStart> void tree2tok ( struct vp9_token * tokens , const vpx_tree_index <S2SV_ModEnd> * tree , int i , int v , <S2SV_ModStart> += v ; ++ l ; do { const vpx_tree_index <S2SV_ModEnd> j = tree [ i ++ ] ; if
<S2SV_ModStart> void vp9_tokens_from_tree ( struct vp9_token * tokens , const vpx_tree_index <S2SV_ModEnd> * tree ) { tree2tok ( tokens , tree
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned int branch_ct [ ] [ 2
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> cospi_8_64 ) ; const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> cospi_16_64 ) ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> sinpi_2_9 ) ; const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> cospi_16_64 ) ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 16 ] ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p08_m24 = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> ) ; const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - <S2SV_ModStart> ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p24_p08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModEnd> u [ 0 ] = _mm_add_epi32 ( v [ <S2SV_ModStart> 1 ] ) ; s [ 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> , t [ 2 ] ) ; s [ 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ <S2SV_ModEnd> 6 ] ) ; u [ 0 ] =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> in ) { const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> in ) { const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> static INLINE void right_shift_8x8 ( __m128i * res , const int bit ) { __m128i sign0 = _mm_srai_epi16 ( res [ 0 ] , 15 ) ; __m128i sign1 = _mm_srai_epi16 ( res [ 1 ] , 15 ) ; __m128i sign2 = _mm_srai_epi16 ( res [ 2 ] , 15 ) ; __m128i sign3 = _mm_srai_epi16 ( res [ 3 ] , 15 ) ; __m128i sign4 = _mm_srai_epi16 ( res [ 4 ] , 15 ) ; __m128i sign5 = _mm_srai_epi16 ( res [ 5 ] , 15 ) ; __m128i sign6 = _mm_srai_epi16 ( res [ 6 ] , 15 ) ; __m128i sign7 = _mm_srai_epi16 ( res [ 7 ] , 15 ) ; if ( bit == 2 ) { const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ; res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ; res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ; res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ; res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ; res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ; res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ; res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ; res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding ) ; } res [ 0 ] = _mm_sub_epi16 ( res [ 0 ] , sign0 ) ; res [ 1 ] = _mm_sub_epi16 ( res [ 1 ] , sign1 ) ; res [ 2 ] = _mm_sub_epi16 ( res [ 2 ] , sign2 ) ; res [ 3 ] = _mm_sub_epi16 ( res [ 3 ] , sign3 ) ; res [ 4 ] = _mm_sub_epi16 ( res [ 4 ] , sign4 ) ; res [ 5 ] = _mm_sub_epi16 ( res [ 5 ] , sign5 ) ; res [ 6 ] = _mm_sub_epi16 ( res [ 6 ] , sign6 ) ; res [ 7 ] = _mm_sub_epi16 ( res [ 7 ] , sign7 ) ; if ( bit == 1 ) { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ; } else { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> void vp9_fht4x4_sse2 ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride , int tx_type ) <S2SV_ModStart> ; switch ( tx_type ) { case DCT_DCT : vpx_fdct4x4_sse2 <S2SV_ModEnd> ( input , output , stride ) ; break
<S2SV_ModStart> <S2SV_null> void vp9_fht8x8_sse2 ( const int16_t * input , tran_low_t <S2SV_ModEnd> * output , int stride , int tx_type ) <S2SV_ModStart> ; switch ( tx_type ) { case DCT_DCT : vpx_fdct8x8_sse2 <S2SV_ModEnd> ( input , output , stride ) ; break
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE void write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output , __m128i * in0 , __m128i *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE void write_buffer_4x4 ( tran_low_t <S2SV_ModEnd> * output , __m128i * res ) { const <S2SV_ModStart> out23 = _mm_srai_epi16 ( out23 , 2 ) ; store_output ( & out01 , ( output + 0 * 8 ) ) ; store_output ( & out23 , ( output + 1 * 8 ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE void write_buffer_8x8 ( tran_low_t <S2SV_ModEnd> * output , __m128i * res , int stride <S2SV_ModStart> , __m128i * res , int stride ) { store_output ( & res [ 0 ] , ( output + 0 * stride ) ) ; store_output ( & res [ 1 ] , ( output + 1 * stride ) ) ; store_output ( & res [ 2 ] , ( output + 2 * stride ) ) ; store_output ( & res [ 3 ] , ( output + 3 * stride ) ) ; store_output ( & res [ 4 ] , ( output + 4 * stride ) ) ; store_output ( & res [ 5 ] , ( output + 5 * stride ) ) ; store_output ( & res [ 6 ] , ( output + 6 * stride ) ) ; store_output ( & res [ 7 ] , ( output + 7 * stride ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * const frame
<S2SV_ModStart> <S2SV_null> static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) { vp9_ref_frame_t * const <S2SV_ModEnd> frame = va_arg ( args , vp9_ref_frame_t * ) <S2SV_ModStart> ( frame != NULL ) { YV12_BUFFER_CONFIG * fb = get_ref_frame ( & ctx -> cpi -> common , frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image ( & frame -> img , fb
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_active_map_t * const map <S2SV_ModStart> ( ctx -> cpi , map -> active_map , ( int ) map -> rows , ( int ) <S2SV_ModEnd> map -> cols ) ) return VPX_CODEC_OK ; else
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t <S2SV_ModStart> config = va_arg ( args , vp8_postproc_cfg_t * ) <S2SV_ModEnd> ; if ( config != NULL ) { ctx <S2SV_ModStart> else ( void ) ctx ; ( void ) <S2SV_ModEnd> args ; return VPX_CODEC_INCAPABLE ; # endif } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * const frame
<S2SV_ModStart> <S2SV_null> static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , va_list args ) { ( void ) ctx ; ( void ) args ; <S2SV_ModEnd> return VPX_CODEC_INVALID_PARAM ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_scaling_mode_t * const mode
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int data = va_arg <S2SV_ModStart> if ( data == 1 && ( cfg -> <S2SV_ModEnd> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_svc_layer_id_t * const data
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { VP9_COMP * const cpi <S2SV_ModStart> VP9_COMP * const cpi = ctx -> cpi ; vpx_svc_extra_cfg_t * const params = va_arg ( args , vpx_svc_extra_cfg_t * ) ; int sl , tl ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < cpi -> svc . number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q = params -> max_quantizers [ sl ] ; lc -> min_q = params -> min_quantizers [ sl ] ; lc -> scaling_factor_num = params -> scaling_factor_num [ sl ] ; lc -> scaling_factor_den = params -> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> return VPX_CODEC_OK ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { const int update =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { const int ref_frame_flags =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { const int reference_flag =
<S2SV_ModStart> ) ; vp9_remove_compressor ( ctx -> cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx ) ; return VPX_CODEC_OK ; } <S2SV_null>
<S2SV_ModStart> long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; if ( img != NULL ) { <S2SV_ModEnd> res = validate_img ( ctx , img ) ; <S2SV_ModStart> res = validate_img ( ctx , img ) ; if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <S2SV_ModStart> . err_detail = "Conflicting<S2SV_blank>flags." ; return VPX_CODEC_INVALID_PARAM ; } vp9_apply_encoding_flags ( cpi , flags ) ; <S2SV_ModEnd> if ( ctx -> cfg . kf_mode == VPX_KF_AUTO <S2SV_ModStart> ; } } if ( res == VPX_CODEC_OK && cpi != NULL ) { unsigned int lib_flags = 0 ; YV12_BUFFER_CONFIG sd ; int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <S2SV_ModEnd> ; size_t size , cx_data_sz ; unsigned char * <S2SV_ModStart> ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) cpi -> b_calculate_psnr = 1 <S2SV_ModEnd> ; if ( img != NULL ) { res <S2SV_ModStart> , & sd ) ; if ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags <S2SV_ModEnd> , & sd , dst_time_stamp , dst_end_time_stamp ) ) <S2SV_ModStart> & sd , dst_time_stamp , dst_end_time_stamp ) ) { <S2SV_ModEnd> res = update_error_state ( ctx , & cpi -> <S2SV_ModStart> & cpi -> common . error ) ; } ctx -> next_frame_flags = 0 ; <S2SV_ModStart> ctx -> cx_data ; cx_data_sz = ctx -> cx_data_sz <S2SV_ModEnd> ; if ( ctx -> pending_cx_data ) { memmove <S2SV_ModStart> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( <S2SV_ModEnd> cpi , & lib_flags , & size , cx_data <S2SV_ModStart> img ) ) { if ( size ) { vpx_codec_cx_pkt_t pkt ; # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! cpi -> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <S2SV_ModEnd> ) { if ( ctx -> pending_cx_data == 0 <S2SV_ModStart> ; cx_data += size ; cx_data_sz -= size ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp ) ; pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <S2SV_ModEnd> kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame <S2SV_ModStart> ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) <S2SV_ModEnd> ; pkt . data . frame . duration = <S2SV_ModStart> . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <S2SV_ModEnd> ) ; pkt . data . frame . flags <S2SV_ModStart> ; pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) <S2SV_ModEnd> ; if ( ctx -> pending_cx_data ) { ctx <S2SV_ModStart> |= size ; ctx -> pending_cx_data_sz += size ; if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <S2SV_ModStart> data . frame . partition_id = - 1 ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <S2SV_ModStart> ; cx_data += size ; cx_data_sz -= size ; # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; }
<S2SV_ModStart> * ctx ) { YV12_BUFFER_CONFIG sd ; vp9_ppflags_t flags ; vp9_zero ( flags ) <S2SV_ModEnd> ; if ( ctx -> preview_ppcfg . post_proc_flag )
<S2SV_ModStart> vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; int force_key = 0 ; if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) { if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( "Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization" ) ; if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ; } <S2SV_ModEnd> if ( cfg -> g_lag_in_frames > ctx -> cfg <S2SV_ModStart> -> cfg , & ctx -> extra_cfg ) ; force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ; <S2SV_ModStart> cpi , & ctx -> oxcf ) ; } if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ;
<S2SV_ModStart> long duration , unsigned long deadline ) { MODE new_mode = BEST ; switch ( ctx -> cfg . g_pass ) { case VPX_RC_ONE_PASS : if ( deadline > 0 ) { const vpx_codec_enc_cfg_t * const cfg = & ctx -> cfg ; <S2SV_ModEnd> const uint64_t duration_us = ( uint64_t ) duration * <S2SV_ModStart> uint64_t ) duration * 1000000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; new_mode = ( deadline > duration_us ) ? GOOD : REALTIME ; } else { new_mode = BEST ; } break ; case VPX_RC_FIRST_PASS : break ; case VPX_RC_LAST_PASS : new_mode = deadline > 0 ? GOOD : BEST ; break ; } if ( ctx -> oxcf . mode != new_mode ) { ctx -> oxcf . mode = new_mode <S2SV_ModEnd> ; vp9_change_config ( ctx -> cpi , & ctx
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static vpx_codec_err_t set_encoder_config ( VP9EncoderConfig <S2SV_ModEnd> * oxcf , const vpx_codec_enc_cfg_t * cfg , const <S2SV_ModStart> cfg , const struct vp9_extracfg * extra_cfg ) { const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ; <S2SV_ModStart> -> profile = cfg -> g_profile ; oxcf -> max_threads = ( int ) cfg -> g_threads ; oxcf -> <S2SV_ModStart> = cfg -> g_h ; oxcf -> bit_depth = cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate <S2SV_ModEnd> = ( double ) cfg -> g_timebase . den <S2SV_ModStart> -> g_timebase . num ; if ( oxcf -> init_framerate > 180 ) oxcf -> init_framerate = 30 ; oxcf -> mode = GOOD <S2SV_ModEnd> ; switch ( cfg -> g_pass ) { case <S2SV_ModStart> -> g_pass ) { case VPX_RC_ONE_PASS : oxcf -> pass = 0 ; break ; case VPX_RC_FIRST_PASS : oxcf -> pass = 1 ; break ; case VPX_RC_LAST_PASS : oxcf -> pass = 2 <S2SV_ModEnd> ; break ; } oxcf -> lag_in_frames = cfg <S2SV_ModStart> ? 0 : cfg -> g_lag_in_frames ; oxcf -> rc_mode = cfg -> rc_end_usage ; oxcf -> target_bandwidth = 1000 * <S2SV_ModEnd> cfg -> rc_target_bitrate ; oxcf -> rc_max_intra_bitrate_pct = extra_cfg <S2SV_ModStart> -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ; oxcf -> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( cfg -> rc_min_quantizer ) ; oxcf -> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( cfg -> rc_max_quantizer ) ; oxcf -> cq_level = vp9_quantizer_to_qindex ( extra_cfg -> cq_level ) <S2SV_ModEnd> ; oxcf -> fixed_q = - 1 ; oxcf <S2SV_ModStart> -> over_shoot_pct = cfg -> rc_overshoot_pct ; oxcf -> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : cfg -> rc_buf_sz ; oxcf -> starting_buffer_level_ms = is_vbr ? 60000 : cfg -> rc_buf_initial_sz ; oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> cfg -> rc_buf_optimal_sz ; oxcf -> drop_frames_water_mark = cfg <S2SV_ModStart> -> key_freq = cfg -> kf_max_dist ; oxcf -> speed = abs ( extra_cfg -> cpu_used ) <S2SV_ModEnd> ; oxcf -> encode_breakout = extra_cfg -> static_thresh ; <S2SV_ModStart> -> encode_breakout = extra_cfg -> static_thresh ; oxcf -> enable_auto_arf <S2SV_ModEnd> = extra_cfg -> enable_auto_alt_ref ; oxcf -> noise_sensitivity = <S2SV_ModStart> ; oxcf -> two_pass_stats_in = cfg -> rc_twopass_stats_in ; # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space <S2SV_ModEnd> ; oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ; <S2SV_ModStart> -> arnr_strength = extra_cfg -> arnr_strength ; oxcf -> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval <S2SV_ModEnd> ; oxcf -> tuning = extra_cfg -> tuning ; <S2SV_ModStart> -> tuning = extra_cfg -> tuning ; oxcf -> content = extra_cfg -> content ; oxcf -> <S2SV_ModStart> -> tile_rows = extra_cfg -> tile_rows ; oxcf -> <S2SV_ModEnd> error_resilient_mode = cfg -> g_error_resilient ; oxcf -> frame_parallel_decoding_mode <S2SV_ModStart> ; oxcf -> ss_number_layers = cfg -> ss_number_layers ; oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if ( oxcf -> ss_number_layers == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers > 1 ) { for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; } } else if ( oxcf -> ts_number_layers == 1 ) { oxcf -> <S2SV_ModEnd> ts_rate_decimator [ 0 ] = 1 ; } return
<S2SV_ModStart> VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 100 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 100 <S2SV_ModEnd> ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 <S2SV_ModStart> g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; if ( extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( cfg -> rc_resize_allowed == 1 ) { RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; } RANGE_CHECK ( <S2SV_ModStart> 1 , VPX_TS_MAX_LAYERS ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( "ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int sl , tl ; for ( sl = 1 ; sl < cfg -> ss_number_layers ; ++ sl ) { for ( tl = 1 ; tl < cfg -> ts_number_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> - 1 ] ) ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing" ) ; <S2SV_ModStart> - 1 ] ) ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing" ) ; } } <S2SV_ModStart> ] , 1 , 1 ) ; for ( tl = cfg -> ts_number_layers - 2 ; tl > 0 ; -- tl ) if ( cfg -> ts_rate_decimator [ tl <S2SV_ModEnd> - 1 ] != 2 * cfg -> ts_rate_decimator <S2SV_ModStart> 1 ] != 2 * cfg -> ts_rate_decimator [ tl ] ) ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; } # if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) { unsigned int i , alt_ref_sum = 0 ; for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { if ( cfg -> ss_enable_auto_alt_ref [ i ] ) ++ alt_ref_sum ; } if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( "Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames" ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( "Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers" ) ; } # endif <S2SV_ModEnd> if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg <S2SV_ModStart> > 0 ) ERROR ( "kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>" "or<S2SV_blank>kf_max_dist<S2SV_blank>instead." ) ; RANGE_CHECK ( extra_cfg , enable_auto_alt_ref , 0 , 2 <S2SV_ModEnd> ) ; RANGE_CHECK ( extra_cfg , cpu_used , - <S2SV_ModStart> ) ; RANGE_CHECK ( extra_cfg , cpu_used , - 8 , 8 <S2SV_ModEnd> ) ; RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 <S2SV_ModStart> arnr_strength , 6 ) ; RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 <S2SV_ModEnd> ) ; if ( extra_cfg -> tuning == VP8_TUNE_SSIM <S2SV_ModStart> if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { const size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; const <S2SV_ModEnd> int n_packets = ( int ) ( cfg -> <S2SV_ModStart> ) ; if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 <S2SV_ModStart> if ( layer_id >= cfg -> ss_number_layers || ( unsigned <S2SV_ModStart> 1 ) ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; } } # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { ERROR ( "Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration" ) ; } # endif <S2SV_ModStart> -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth > VPX_BITS_8 ) { ERROR ( "Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; } if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_input_bit_depth > 8 ) { ERROR ( "Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; } if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) { ERROR ( "Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1" ) ; } RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB <S2SV_ModEnd> ) ; return VPX_CODEC_OK ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I42016 : break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I444 : case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) { ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile." ) ; } break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) { ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile." ) ; } <S2SV_ModEnd> break ; default : ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "supported." ) <S2SV_ModStart> break ; default : ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "supported." ) ; break
<S2SV_ModStart> ctx -> pending_cx_data_sz ; int i , j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( "Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\n" ) ; # endif <S2SV_ModStart> = marker ; ctx -> pending_cx_data_sz += index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * data = <S2SV_ModStart> ( args , vpx_ref_frame_t * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> img , & sd ) ; return vp9_copy_reference_dec ( frame_worker_data <S2SV_ModEnd> -> pbi , ( VP9_REFFRAME ) frame -> frame_type
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * const display_size <S2SV_ModStart> ( args , int * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( display_size ) { if ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; const VP9_COMMON * const cm = & frame_worker_data <S2SV_ModEnd> -> pbi -> common ; display_size [ 0 ] <S2SV_ModStart> display_size [ 1 ] = cm -> display_height ; return VPX_CODEC_OK ; } else { return VPX_CODEC_ERROR ; } } return VPX_CODEC_INVALID_PARAM ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * corrupted = <S2SV_ModStart> if ( corrupted ) { if ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data -> pbi -> common . frame_to_show == NULL ) return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted ; return VPX_CODEC_OK ; } else { return VPX_CODEC_ERROR ; } } return VPX_CODEC_INVALID_PARAM ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { int * const update_info <S2SV_ModStart> ( args , int * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( update_info ) { if ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; * update_info = frame_worker_data -> pbi -> refresh_frame_flags ; return VPX_CODEC_OK ; } else { return VPX_CODEC_ERROR ; } } return VPX_CODEC_INVALID_PARAM ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vp9_ref_frame_t * data = <S2SV_ModStart> ( args , vp9_ref_frame_t * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( data ) { YV12_BUFFER_CONFIG * fb ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; fb = get_ref_frame ( & frame_worker_data -> pbi -> common , data -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image ( & data -> img , fb
<S2SV_ModStart> <S2SV_null> static vpx_codec_err_t ctrl_set_dbg_options ( vpx_codec_alg_priv_t * ctx , va_list args ) { ( void ) ctx ; ( void ) args ; return VPX_CODEC_INCAPABLE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { ctx -> invert_tile_order =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t <S2SV_ModStart> } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args ) { vpx_ref_frame_t * const data <S2SV_ModStart> ( args , vpx_ref_frame_t * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> , & sd ) ; return vp9_set_reference_dec ( & frame_worker_data <S2SV_ModEnd> -> pbi -> common , ( VP9_REFFRAME ) frame
<S2SV_ModStart> , void * user_priv , int64_t deadline ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ( void ) deadline <S2SV_ModEnd> ; if ( ! ctx -> si . h <S2SV_ModStart> ( ! ctx -> si . h ) { int is_intra_only = 0 ; const vpx_codec_err_t res = decoder_peek_si_internal <S2SV_ModEnd> ( * data , data_sz , & ctx -> <S2SV_ModStart> * data , data_sz , & ctx -> si , & is_intra_only , ctx -> decrypt_cb , ctx -> decrypt_state <S2SV_ModStart> if ( res != VPX_CODEC_OK ) return res ; if ( ! ctx -> si . is_kf && ! is_intra_only ) return VPX_CODEC_ERROR ; } if ( ! ctx -> frame_parallel_decode ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data -> data = * data ; frame_worker_data -> data_size = data_sz ; frame_worker_data -> user_priv = user_priv ; frame_worker_data -> received_frame = 1 ; frame_worker_data -> pbi -> decrypt_cb = ctx -> decrypt_cb ; frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ; worker -> had_error = 0 ; winterface -> execute ( worker ) ; * data = frame_worker_data -> data_end ; if ( worker -> had_error ) return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ; check_resync ( ctx , frame_worker_data -> pbi ) ; } else { VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) vp9_frameworker_copy_context ( & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ; frame_worker_data -> pbi -> ready_for_new_data = 0 ; if ( frame_worker_data -> scratch_buffer_size < data_sz ) { frame_worker_data -> scratch_buffer = ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ; if ( frame_worker_data -> scratch_buffer == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> scratch_buffer_size = data_sz ; } frame_worker_data -> data_size = data_sz ; memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ; frame_worker_data -> frame_decoded = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame = 1 ; frame_worker_data -> data = frame_worker_data -> scratch_buffer ; frame_worker_data -> user_priv = user_priv ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) ctx -> last_submit_worker_id = ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ; ctx -> next_submit_worker_id = ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ; -- ctx -> available_threads ; worker -> had_error = 0 ; winterface -> launch ( worker ) ; } <S2SV_ModEnd> return VPX_CODEC_OK ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> uint8_t * data_start = data ; const uint8_t * const data_end = data + data_sz ; vpx_codec_err_t res ; uint32_t frame_sizes [ 8 ] ; int frame_count ; if ( data == NULL && data_sz == 0 ) { ctx -> flushed = 1 ; return VPX_CODEC_OK ; } ctx -> flushed = 0 ; if ( ctx -> frame_workers == NULL ) { const vpx_codec_err_t res = init_decoder ( ctx ) ; if ( res != VPX_CODEC_OK ) return res ; } res = vp9_parse_superframe_index ( data , data_sz , frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( res != VPX_CODEC_OK ) return res ; if ( ctx -> frame_parallel_decode ) { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; return VPX_CODEC_CORRUPT_FRAME ; } if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; } } else { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; vpx_codec_err_t res ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; return VPX_CODEC_CORRUPT_FRAME ; } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { while ( data_start < data_end ) { const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; while ( data_start < data_end ) { const uint8_t marker = read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ; if ( marker ) break ; ++ data_start ; } } } } <S2SV_ModEnd> return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx ) { if ( ctx -> frame_workers != NULL ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_worker_interface ( ) -> end ( worker ) ; vp9_remove_common ( & frame_worker_data -> pbi -> common ) ; # if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ; # endif vp9_decoder_remove ( frame_worker_data -> pbi ) ; vpx_free ( frame_worker_data -> scratch_buffer ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ; pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ; # endif vpx_free ( frame_worker_data ) ; } # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif } if ( ctx -> buffer_pool ) { vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ; vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ; } vpx_free ( ctx -> frame_workers ) ; vpx_free ( ctx -> buffer_pool ) ; <S2SV_ModEnd> vpx_free ( ctx ) ; return VPX_CODEC_OK ; }
<S2SV_ModStart> * img = NULL ; if ( ctx -> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) { return NULL ; } if ( ctx -> num_cache_frames > 0 ) { release_last_output_frame ( ctx ) ; ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ; if ( ctx -> need_resync ) return NULL ; img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ; ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ; -- ctx -> num_cache_frames ; return img ; } if ( * iter == NULL && ctx -> frame_workers != NULL ) { do { YV12_BUFFER_CONFIG sd ; vp9_ppflags_t flags = { 0 , 0 , 0 } ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ; if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ; if ( winterface -> sync ( worker ) ) { if ( frame_worker_data -> received_frame == 1 ) { ++ ctx -> available_threads ; frame_worker_data -> received_frame = 0 ; check_resync ( ctx , frame_worker_data -> pbi ) ; } if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) { VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; release_last_output_frame ( ctx ) ; ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ; if ( ctx -> need_resync ) return NULL ; yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ; ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; img = & ctx -> img ; return img ; } } else { frame_worker_data -> received_frame = 0 ; ++ ctx -> available_threads ; ctx -> need_resync = 1 ; if ( ctx -> flushed != 1 ) return NULL ; } } while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ; } return NULL <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { ( void ) data ; <S2SV_ModStart> ( ! ctx -> priv ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR <S2SV_ModEnd> ; ctx -> priv = ( vpx_codec_priv_t * ) <S2SV_ModStart> ; ctx -> priv = ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> ; ctx -> priv -> init_flags = ctx -> <S2SV_ModStart> -> priv -> init_flags = ctx -> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ; <S2SV_ModStart> if ( ctx -> config . dec ) { priv <S2SV_ModEnd> -> cfg = * ctx -> config . dec <S2SV_ModStart> dec ; ctx -> config . dec = & priv <S2SV_ModEnd> -> cfg ; } } return VPX_CODEC_OK ; }
<S2SV_ModStart> unsigned int data_sz , vpx_codec_stream_info_t * si ) { return decoder_peek_si_internal ( data , data_sz , si , NULL , NULL , NULL ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return VPX_CODEC_INVALID_PARAM ; } else if ( ctx -> frame_workers <S2SV_ModEnd> == NULL ) { ctx -> get_ext_fb_cb = cb_get
<S2SV_ModStart> static void init_buffer_callbacks ( vpx_codec_alg_priv_t * ctx ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ; BufferPool * const pool = cm -> buffer_pool ; cm -> new_fb_idx = INVALID_IDX ; cm -> byte_alignment = ctx -> byte_alignment ; cm -> skip_loop_filter = ctx -> skip_loop_filter <S2SV_ModEnd> ; if ( ctx -> get_ext_fb_cb != NULL && <S2SV_ModStart> NULL && ctx -> release_ext_fb_cb != NULL ) { pool -> get_fb_cb = ctx -> get_ext_fb_cb ; pool -> release_fb_cb = ctx -> release_ext_fb_cb ; pool <S2SV_ModEnd> -> cb_priv = ctx -> ext_priv ; } else <S2SV_ModStart> cb_priv = ctx -> ext_priv ; } else { pool -> get_fb_cb = vp9_get_frame_buffer ; pool <S2SV_ModEnd> -> release_fb_cb = vp9_release_frame_buffer ; if ( vp9_alloc_internal_frame_buffers ( <S2SV_ModStart> release_fb_cb = vp9_release_frame_buffer ; if ( vp9_alloc_internal_frame_buffers ( & pool <S2SV_ModEnd> -> int_frame_buffers ) ) vpx_internal_error ( & cm -> <S2SV_ModStart> cm -> error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>internal<S2SV_blank>frame<S2SV_blank>buffers" ) ; pool -> cb_priv = & pool -> int_frame_buffers ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static vpx_codec_err_t init_decoder ( vpx_codec_alg_priv_t * ctx ) { int i ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ctx -> last_show_frame = - 1 ; ctx -> next_submit_worker_id = 0 ; ctx -> last_submit_worker_id = 0 ; ctx -> next_output_worker_id = 0 ; ctx -> frame_cache_read = 0 ; ctx -> frame_cache_write = 0 ; ctx -> num_cache_frames = 0 ; ctx -> need_resync = 1 ; ctx -> num_frame_workers = ( ctx -> frame_parallel_decode == 1 ) ? ctx -> cfg . threads : 1 ; if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) ctx -> num_frame_workers = MAX_DECODE_THREADS ; ctx -> available_threads = ctx -> num_frame_workers ; ctx -> flushed = 0 ; ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( ctx -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex" ) ; return VPX_CODEC_MEM_ERROR ; } # endif ctx -> frame_workers = ( VPxWorker * ) vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ; if ( ctx -> frame_workers == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers" ) ; return VPX_CODEC_MEM_ERROR ; } for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * frame_worker_data = NULL ; winterface -> init ( worker ) ; worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ; if ( worker -> data1 == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data -> pbi = vp9_decoder_create ( ctx -> buffer_pool ) ; if ( frame_worker_data -> pbi == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> pbi -> frame_worker_owner = worker ; frame_worker_data -> worker_id = i ; frame_worker_data -> scratch_buffer = NULL ; frame_worker_data -> scratch_buffer_size = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame = 0 ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex" ) ; return VPX_CODEC_MEM_ERROR ; } if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond" ) ; return VPX_CODEC_MEM_ERROR ; } # endif frame_worker_data -> pbi -> max_threads = ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ; frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ; frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ; frame_worker_data -> pbi -> common . frame_parallel_decode = ctx -> frame_parallel_decode ; worker -> hook = ( VPxWorkerHook ) frame_worker_hook ; if ( ! winterface -> reset ( worker ) ) { set_error_detail ( ctx , "Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; return VPX_CODEC_MEM_ERROR ; } } <S2SV_ModEnd> if ( ! ctx -> postproc_cfg_set && ( ctx <S2SV_ModStart> -> postproc_cfg ) ; init_buffer_callbacks ( ctx ) ; return VPX_CODEC_OK ;
<S2SV_ModStart> vp9_ppflags_t * flags ) { flags -> post_proc_flag = <S2SV_ModEnd> ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level <S2SV_ModStart> -> noise_level = ctx -> postproc_cfg . noise_level ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> error ) { if ( error -> error_code ) set_error_detail ( ctx , <S2SV_ModEnd> error -> has_detail ? error -> detail : NULL <S2SV_ModStart> error -> has_detail ? error -> detail : NULL )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static const SvcInternal_t <S2SV_ModEnd> * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_ModStart> == NULL ) return NULL ; return ( const SvcInternal_t <S2SV_ModEnd> * ) svc_ctx -> internal ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static SvcInternal_t <S2SV_ModEnd> * get_svc_internal ( SvcContext * svc_ctx ) { if <S2SV_ModStart> if ( svc_ctx -> internal == NULL ) { SvcInternal_t * const si = ( SvcInternal_t <S2SV_ModEnd> * ) malloc ( sizeof ( * si ) <S2SV_ModStart> svc_ctx -> internal = si ; } return ( SvcInternal_t <S2SV_ModEnd> * ) svc_ctx -> internal ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; char * option_value ; char * input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> ; if ( options == NULL ) return VPX_CODEC_OK <S2SV_ModStart> VPX_CODEC_INVALID_PARAM ; break ; } if ( strcmp ( "spatial-layers" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( "temporal-layers" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( "scale-factors" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> ) ; if ( res != VPX_CODEC_OK ) break <S2SV_ModStart> ) break ; } else if ( strcmp ( "max-quantizers" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( "min-quantizers" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( "auto-alt-refs" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( "bitrates" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( "multi-frame-contexts" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> ; } else { svc_log ( svc_ctx , SVC_LOG_ERROR <S2SV_ModStart> input_ptr ) ; } free ( input_string ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could" "enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }
<S2SV_ModStart> <S2SV_null> static int svc_log ( SvcContext * svc_ctx , SVC_LOG_LEVEL <S2SV_ModEnd> level , const char * fmt , ... ) <S2SV_ModStart> ; int retval = 0 ; va_list ap ; SvcInternal_t <S2SV_ModEnd> * const si = get_svc_internal ( svc_ctx ) ;
<S2SV_ModStart> static void svc_log_reset ( SvcContext * svc_ctx ) { SvcInternal_t * const si = ( SvcInternal_t <S2SV_ModEnd> * ) svc_ctx -> internal ; si -> message_buffer
<S2SV_ModStart> vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { int number_of_frames <S2SV_ModEnd> ; int i , j ; uint32_t bytes_total = <S2SV_ModStart> double mse [ COMPONENTS ] ; double y_scale ; SvcInternal_t <S2SV_ModEnd> * const si = get_svc_internal ( svc_ctx ) ; <S2SV_ModStart> ) return NULL ; svc_log_reset ( svc_ctx ) ; number_of_frames = si -> psnr_pkt_received ; if ( number_of_frames <S2SV_ModEnd> <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_ModStart> svc_log ( svc_ctx , SVC_LOG_INFO , "\\n" ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 <S2SV_ModEnd> ; for ( j = 0 ; j < <S2SV_ModStart> ( j = 0 ; j < COMPONENTS ; <S2SV_ModEnd> ++ j ) { si -> psnr_sum [ i <S2SV_ModStart> j ] = 0 ; } } si -> psnr_pkt_received <S2SV_ModEnd> = 0 ; svc_log ( svc_ctx , SVC_LOG_INFO ,
<S2SV_ModStart> ; vpx_codec_iter_t iter ; const vpx_codec_cx_pkt_t * cx_pkt ; SvcInternal_t <S2SV_ModEnd> * const si = get_svc_internal ( svc_ctx ) ; <S2SV_ModStart> si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } svc_log_reset ( svc_ctx ) ; res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , 0 <S2SV_ModEnd> , deadline ) ; if ( res != VPX_CODEC_OK <S2SV_ModStart> ) { switch ( cx_pkt -> kind ) { # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_PSNR : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx , SVC_LOG_DEBUG , "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>" "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . psnr [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>" "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . sse [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 3 ] ) ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . psnr [ j ] ; si -> sse_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . sse [ j ] ; } } ++ si -> psnr_pkt_received ; break ; } case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) si -> bytes_sum [ i ] += cx_pkt -> data . layer_sizes [ i ] ; break ; } # endif # endif default : { break ; } } } return VPX_CODEC_OK ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vpx_svc_get_message ( const SvcContext * svc_ctx ) { const SvcInternal_t <S2SV_ModEnd> * const si = get_const_svc_internal ( svc_ctx ) ;
<S2SV_ModStart> vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * enc_cfg ) { vpx_codec_err_t res ; int i ; SvcInternal_t <S2SV_ModEnd> * const si = get_svc_internal ( svc_ctx ) ; <S2SV_ModStart> svc_ctx -> spatial_layers ) ; return VPX_CODEC_INVALID_PARAM ; } if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } res = parse_options ( svc_ctx , si -> options <S2SV_ModEnd> ) ; if ( res != VPX_CODEC_OK ) return <S2SV_ModStart> if ( res != VPX_CODEC_OK ) return res ; if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "spatial<S2SV_blank>layers<S2SV_blank>*<S2SV_blank>temporal<S2SV_blank>layers<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>" "allowed<S2SV_blank>layers<S2SV_blank>of<S2SV_blank>%d\\n" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ; if ( res != VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "svc_enc_init<S2SV_blank>error\\n" ) ; return res ; } vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ; vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params ) ; return VPX_CODEC_OK <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * svc_ctx , const char * options ) { SvcInternal_t <S2SV_ModEnd> * const si = get_svc_internal ( svc_ctx ) ;
<S2SV_ModStart> ctrl_id ) ; res = entry -> fn ( ( vpx_codec_alg_priv_t * ) ctx -> priv <S2SV_ModEnd> , ap ) ; va_end ( ap ) ;
<S2SV_ModStart> -> priv ) res = VPX_CODEC_ERROR ; else { ctx -> iface -> destroy ( ( vpx_codec_alg_priv_t * ) ctx -> priv <S2SV_ModEnd> ) ; ctx -> iface = NULL ; ctx
<S2SV_ModStart> ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const <S2SV_ModStart> = VPX_CODEC_ABI_MISMATCH ; else if ( ( flags & <S2SV_ModEnd> VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & <S2SV_ModStart> -> config . dec = cfg ; res = <S2SV_ModEnd> ctx -> iface -> init ( ctx , NULL <S2SV_ModStart> -> err_detail : NULL ; vpx_codec_destroy ( ctx ) <S2SV_ModEnd> ; } } return SAVE_STATUS ( ctx , res
<S2SV_ModStart> ! ctx || ( ! data && data_sz ) || ( data && ! data_sz ) <S2SV_ModStart> = ctx -> iface -> dec . decode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , data , data_sz , user_priv , deadline )
<S2SV_ModStart> = ctx -> iface -> dec . get_frame ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter ) ; return img ; } <S2SV_null>
<S2SV_ModStart> = ctx -> iface -> dec . get_si ( get_alg_priv ( ctx ) <S2SV_ModEnd> , si ) ; } return SAVE_STATUS ( ctx
<S2SV_ModStart> usage ) { vpx_codec_err_t res ; vpx_codec_enc_cfg_map_t * map ; int i <S2SV_ModStart> ; else { res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { map = iface -> enc . cfg_maps + i ; <S2SV_ModEnd> if ( map -> usage == ( int )
<S2SV_ModStart> = ctx -> iface -> enc . cfg_set ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cfg ) ; return SAVE_STATUS ( ctx ,
<S2SV_ModStart> = VPX_CODEC_INCAPABLE ; else if ( ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & <S2SV_ModStart> ) ; i -- ; } } if ( <S2SV_ModEnd> res ) break ; ctx ++ ; cfg ++
<S2SV_ModStart> ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const <S2SV_ModStart> = VPX_CODEC_INCAPABLE ; else if ( ( flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & <S2SV_ModStart> : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_ModEnd> } return SAVE_STATUS ( ctx , res ) ;
<S2SV_ModStart> = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img , pts , duration , flags , <S2SV_ModStart> = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img , pts , duration , flags ,
<S2SV_ModStart> = ctx -> iface -> enc . get_cx_data ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter ) ; } if ( pkt &&
<S2SV_ModStart> = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; } return buf ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = ctx -> iface -> enc . get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; } return img ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , s , xcs , ycs , bps ; unsigned int stride_in_bytes ; <S2SV_ModStart> case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; <S2SV_ModStart> case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : <S2SV_ModStart> switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 <S2SV_ModEnd> : ycs = 1 ; break ; default : <S2SV_ModStart> 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s <S2SV_ModStart> = img_data ; if ( ! img_data ) { const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ; if ( alloc_size != ( size_t ) alloc_size ) goto fail ; img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 <S2SV_ModEnd> ; img -> w = w ; img -> <S2SV_ModStart> ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes <S2SV_ModEnd> ; img -> stride [ VPX_PLANE_U ] = img <S2SV_ModStart> ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes <S2SV_ModEnd> >> xcs ; if ( ! vpx_img_set_rect ( img
<S2SV_ModStart> -> stride [ VPX_PLANE_PACKED ] ; } else { const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> -> planes [ VPX_PLANE_ALPHA ] = data + x * bytes_per_sample <S2SV_ModStart> -> planes [ VPX_PLANE_Y ] = data + x * bytes_per_sample <S2SV_ModStart> data + ( x >> img -> x_chroma_shift ) * bytes_per_sample <S2SV_ModStart> data + ( x >> img -> x_chroma_shift ) * bytes_per_sample <S2SV_ModStart> data + ( x >> img -> x_chroma_shift ) * bytes_per_sample <S2SV_ModStart> data + ( x >> img -> x_chroma_shift ) * bytes_per_sample
<S2SV_ModStart> num * size ) ; if ( x ) memset <S2SV_ModEnd> ( x , 0 , num * size )
<S2SV_ModStart> ) memblk ) [ - 1 ] ) ; free ( addr ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> void * addr , * x = NULL ; addr = malloc <S2SV_ModEnd> ( size + align - 1 + ADDRESS_STORAGE_SIZE ) <S2SV_ModStart> size + align - 1 + ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( addr ) { x = align_addr (
<S2SV_ModStart> - 1 ] ) ; memblk = NULL ; new_addr = realloc <S2SV_ModEnd> ( addr , size + align + ADDRESS_STORAGE_SIZE ) <S2SV_ModStart> addr , size + align + ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( new_addr ) { addr = new_addr ;
<S2SV_ModStart> } mask = arm_cpu_env_mask ( ) ; # if <S2SV_ModEnd> HAVE_MEDIA flags |= HAS_MEDIA ; # endif # if <S2SV_ModStart> flags |= HAS_MEDIA ; # endif # if HAVE_NEON || HAVE_NEON_ASM
<S2SV_ModStart> void ) dest_pitch ; ( void ) src_pitch ; memcpy <S2SV_ModEnd> ( dest , source , dest_width ) ; }
<S2SV_ModStart> dest_pitch , dest_width ) ; if ( interpolation ) memcpy <S2SV_ModEnd> ( temp_area , temp_area + source_band_height * dest_pitch , <S2SV_ModStart> , hratio , dest_width ) ; } else { memcpy <S2SV_ModEnd> ( temp_area + i * dest_pitch , temp_area + <S2SV_ModStart> , dest_pitch , vratio , dest_band_height ) ; } memcpy <S2SV_ModEnd> ( temp_area , temp_area + source_band_height * dest_pitch ,
<S2SV_ModStart> { vpx_free ( ybf -> buffer_alloc ) ; } memset <S2SV_ModEnd> ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG )
<S2SV_ModStart> ; ybf -> y_stride = y_stride ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
<S2SV_ModStart> ; i < height ; ++ i ) { memset <S2SV_ModEnd> ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left <S2SV_ModStart> , src_ptr1 [ 0 ] , extend_left ) ; memset <S2SV_ModEnd> ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right <S2SV_ModStart> ; i < extend_top ; ++ i ) { memcpy <S2SV_ModEnd> ( dst_ptr1 , src_ptr1 , linesize ) ; dst_ptr1 <S2SV_ModStart> ; i < extend_bottom ; ++ i ) { memcpy <S2SV_ModEnd> ( dst_ptr2 , src_ptr2 , linesize ) ; dst_ptr2
<S2SV_ModStart> y_height == dst_ybc -> y_height ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <S2SV_ModStart> < src_ybc -> y_height ; ++ row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , src , src_ybc -> y_width ) <S2SV_ModStart> < src_ybc -> uv_height ; ++ row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , src , src_ybc -> uv_width ) <S2SV_ModStart> < src_ybc -> uv_height ; ++ row ) { memcpy_short_addr <S2SV_ModEnd> ( dst , src , src_ybc -> uv_width ) <S2SV_ModStart> -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;
<S2SV_ModStart> <S2SV_null> void vp8_yv12_extend_frame_borders_c ( YV12_BUFFER_CONFIG * ybf ) { const int uv_border = ybf -> border / 2 ; assert ( ybf -> border % 2 == 0 ) ; <S2SV_ModStart> y_width - ybf -> y_crop_width >= 0 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { extend_plane_high ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane_high ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; extend_plane_high ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; return ; } # endif <S2SV_ModStart> ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> ) ; extend_plane ( ybf -> v_buffer , ybf <S2SV_ModStart> ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ) ; if ( ! vpx_codec_peek_stream_info ( decoder -> codec_interface <S2SV_ModEnd> ( ) , buf + 4 , 32 -
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> die ( "Unrecognized<S2SV_blank>pattern<S2SV_blank>%%%c\\n" , p [ 1 ] ) ; break
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> ) ; if ( ! ext_fb_list -> ext_fb [
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ; int do_md5 = 0 , progress = 0 , frame_parallel = 0 <S2SV_ModStart> 1 ; int arg_skip = 0 ; int ec_enabled = 0 ; int keep_going <S2SV_ModStart> ; int single_file ; int use_y4m = 1 ; int opt_yv12 = 0 ; int opt_i420 = 0 ; vpx_codec_dec_cfg_t cfg = { 0 , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif <S2SV_ModEnd> # if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = { 0 } <S2SV_ModStart> = 0 ; vpx_image_t * scaled_img = NULL ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif int frame_avail , got_data , flush_decoder = 0 <S2SV_ModEnd> ; int num_external_frame_buffers = 0 ; struct ExternalFrameBufferList ext_fb_list <S2SV_ModStart> = 0 ; struct ExternalFrameBufferList ext_fb_list = { 0 , NULL <S2SV_ModStart> [ 16 ] ; struct VpxDecInputContext input = { NULL , NULL } ; struct VpxInputContext vpx_input_ctx ; # if CONFIG_WEBM_IO struct WebmInputContext webm_ctx ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) ; input . webm_ctx = & webm_ctx ; # endif input . vpx_input_ctx = & vpx_input_ctx <S2SV_ModEnd> ; exec_name = argv_ [ 0 ] ; argv <S2SV_ModStart> { use_y4m = 0 ; flipuv = 1 ; opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif <S2SV_ModStart> { use_y4m = 0 ; flipuv = 0 ; opt_i420 = 1 ; <S2SV_ModStart> else if ( arg_match ( & arg , & rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , & <S2SV_ModStart> . threads = arg_parse_uint ( & arg ) ; # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER <S2SV_ModStart> else if ( arg_match ( & arg , & frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , & <S2SV_ModStart> ) num_external_frame_buffers = arg_parse_uint ( & arg ) ; else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif <S2SV_ModStart> [ 0 ] ; if ( ! fn ) { free ( argv ) ; usage_exit ( ) ; } <S2SV_ModEnd> infile = strcmp ( fn , "-" ) ? <S2SV_ModStart> stdin ) ; if ( ! infile ) { fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file<S2SV_blank>\'%s\'" <S2SV_ModEnd> , strcmp ( fn , "-" ) ? fn <S2SV_ModStart> fn , "-" ) ? fn : "stdin" ) <S2SV_ModEnd> ; } # if CONFIG_OS_SUPPORT if ( ! outfile_pattern <S2SV_ModStart> ! single_file ) { fprintf ( stderr , "YUV4MPEG2<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>output<S2SV_blank>patterns," "<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12<S2SV_blank>or<S2SV_blank>--rawvideo.\\n" <S2SV_ModEnd> ) ; return EXIT_FAILURE ; } # if CONFIG_WEBM_IO <S2SV_ModStart> ) | ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) <S2SV_ModStart> if ( vpx_codec_dec_init ( & decoder , interface -> codec_interface <S2SV_ModEnd> ( ) , & cfg , dec_flags ) ) <S2SV_ModStart> * img ; struct vpx_usec_timer timer ; int corrupted = 0 <S2SV_ModStart> detail ) warn ( "Additional<S2SV_blank>information:<S2SV_blank>%s" , detail ) ; if ( ! keep_going ) <S2SV_ModStart> dx_time += vpx_usec_timer_elapsed ( & timer ) ; } else { flush_decoder = 1 ; } } else { flush_decoder = 1 ; } vpx_usec_timer_start ( & timer ) ; if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( "Failed<S2SV_blank>to<S2SV_blank>flush<S2SV_blank>decoder:<S2SV_blank>%s" , vpx_codec_error ( & decoder ) ) ; } } <S2SV_ModEnd> got_data = 0 ; if ( ( img = <S2SV_ModStart> ) vpx_usec_timer_elapsed ( & timer ) ; if ( ! frame_parallel && <S2SV_ModStart> "Failed<S2SV_blank>VP8_GET_FRAME_CORRUPTED:<S2SV_blank>%s" , vpx_codec_error ( & decoder ) ) ; if ( ! keep_going ) <S2SV_ModStart> ; } } scaled_img = vpx_img_alloc ( NULL , img -> fmt , display_width , display_height , 16 ) ; scaled_img -> bit_depth = img -> bit_depth <S2SV_ModEnd> ; } if ( img -> d_w != scaled_img <S2SV_ModStart> img -> d_h != scaled_img -> d_h ) { # if CONFIG_LIBYUV libyuv_scale <S2SV_ModEnd> ( img , scaled_img , kFilterBox ) ; img <S2SV_ModStart> scaled_img , kFilterBox ) ; img = scaled_img ; # else fprintf ( stderr , "Failed<S2SV_blank><S2SV_blank>to<S2SV_blank>scale<S2SV_blank>output<S2SV_blank>frame:<S2SV_blank>%s.\\n" "Scaling<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>" "To<S2SV_blank>enable<S2SV_blank>scaling,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif <S2SV_ModEnd> if ( single_file ) { if ( use_y4m ) <S2SV_ModStart> } ; size_t len = 0 ; if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>y4m<S2SV_blank>output<S2SV_blank>for<S2SV_blank>440<S2SV_blank>sampling.\\n" ) ; goto fail ; } if ( <S2SV_ModStart> , & vpx_input_ctx . framerate , img -> fmt , img -> bit_depth <S2SV_ModStart> fputs ( buf , outfile ) ; } } else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>i420<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>yv12<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; goto fail ; } } } } <S2SV_ModStart> ; fclose ( outfile ) ; } } } <S2SV_ModEnd> } if ( summary || progress ) { show_progress <S2SV_ModStart> if ( scaled_img ) vpx_img_free ( scaled_img ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif
<S2SV_ModStart> ) ; if ( ! file ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\'%s\'" <S2SV_ModEnd> , name ) ; return file ; } }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void <S2SV_ModStart> , decoder -> name , vpx_codec_iface_name ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) ) ; } exit ( EXIT_FAILURE
<S2SV_ModStart> * file ) { int i , y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <S2SV_ModStart> ; ++ y ) { fwrite ( buf , bytes_per_sample <S2SV_ModEnd> , w , file ) ; buf += stride
<S2SV_ModStart> write_webm ) { write_webm_file_footer ( & stream -> ebml ) <S2SV_ModEnd> ; } # endif if ( ! stream ->
<S2SV_ModStart> img1 , const vpx_image_t * const img2 ) { uint32_t l_w = img1 -> d_w ; <S2SV_ModEnd> uint32_t c_w = ( img1 -> d_w + img1 <S2SV_ModStart> img1 -> d_h == img2 -> d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <S2SV_ModStart> i * img2 -> stride [ VPX_PLANE_Y ] , l_w <S2SV_ModEnd> ) == 0 ) ; for ( i =
<S2SV_ModStart> . num / global -> framerate . num ; # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> && ( img -> d_w != cfg -> g_w <S2SV_ModStart> != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) { stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> , cfg -> g_w , cfg -> g_h , <S2SV_ModStart> kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , stream -> index ) ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ) { static size_t fsize = 0 ; static int64_t <S2SV_ModEnd> ivf_header_pos = 0 ; switch ( pkt -> kind <S2SV_ModStart> if ( stream -> config . write_webm ) { <S2SV_ModEnd> write_webm_block ( & stream -> ebml , cfg , <S2SV_ModStart> . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { const int64_t <S2SV_ModEnd> currpos = ftello ( stream -> file ) ; <S2SV_ModStart> -> data . raw . sz ; break ; # if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ; stream -> nbytes += pkt -> data . raw . sz ; break ; # endif
<S2SV_ModStart> |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> & stream -> encoder , global -> codec -> codec_interface <S2SV_ModEnd> ( ) , & stream -> config . cfg <S2SV_ModStart> vpx_codec_dec_init ( & stream -> decoder , decoder -> codec_interface <S2SV_ModEnd> ( ) , NULL , 0 ) ; }
<S2SV_ModStart> sizeof ( * stream ) ) ; if ( stream == NULL ) { fatal ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream." ) ; } <S2SV_ModEnd> if ( prev ) { memcpy ( stream , <S2SV_ModStart> ; res = vpx_codec_enc_config_default ( global -> codec -> codec_interface <S2SV_ModEnd> ( ) , & stream -> config . cfg <S2SV_ModStart> . g_h = 0 ; stream -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; stream -> ebml . last_pts_ns = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL <S2SV_ModEnd> ; # endif stream -> ebml . debug =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ; rewind ( input -> file ) ; } input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; <S2SV_ModStart> = input -> y4m . pic_h ; input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> = input -> y4m . fps_d ; input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; } else fatal ( "Unsupported<S2SV_blank>Y4M<S2SV_blank>stream." ) ; }
<S2SV_ModStart> struct stream_state * stream , struct VpxEncoderConfig * global , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> config . stereo_fmt , global -> codec -> fourcc , pixel_aspect_ratio
<S2SV_ModStart> , * * argj ; struct arg arg ; const int num_encoder = get_vpx_encoder_count ( ) ; if ( num_encoder < 1 ) die ( "Error:<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>encoder<S2SV_blank>available\\n" ) ; <S2SV_ModStart> ) ) ; global -> codec = get_vpx_encoder_by_index ( num_encoder - 1 ) ; global -> passes = 0 ; global -> color_type = I420 <S2SV_ModEnd> ; global -> deadline = VPX_DL_GOOD_QUALITY ; for ( <S2SV_ModStart> , & use_yv12 , argi ) ) global -> color_type = YV12 ; else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ; else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ; else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ; else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440 <S2SV_ModEnd> ; else if ( arg_match ( & arg , <S2SV_ModStart> ) ) global -> disable_warning_prompt = 1 ; else <S2SV_ModEnd> argj ++ ; } if ( global -> pass <S2SV_ModStart> -> passes == 0 ) { # if CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL )
<S2SV_ModStart> stream -> config ; int eos_mark_found = 0 ; # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , "vp10" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map <S2SV_ModStart> eos_mark_found = 1 ; continue ; } if ( <S2SV_ModEnd> arg_match ( & arg , & outputfile , argi <S2SV_ModStart> { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( "Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled." ) ; # endif <S2SV_ModStart> . g_h = arg_parse_uint ( & arg ) ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; # endif <S2SV_ModStart> else if ( arg_match ( & arg , & resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> { config -> cfg . kf_mode = VPX_KF_DISABLED ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || strcmp ( global -> codec -> name , "vp10" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> config -> arg_ctrl_cnt ; j ++ ) if ( ctrl_args_map != NULL && <S2SV_ModStart> i ] ) break ; assert ( j < ( int ) ARG_CTRL_CNT_MAX ) ; if ( ctrl_args_map != NULL && j < ( int ) <S2SV_ModEnd> ARG_CTRL_CNT_MAX ) { config -> arg_ctrls [ j ] <S2SV_ModStart> ( ! match ) argj ++ ; } } # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || strcmp ( global -> codec -> name , "vp10" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store" ) ; } # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store" ) ; } # endif <S2SV_ModStart> : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; if ( pass ) { <S2SV_ModStart> = stats_get ( & stream -> stats ) ; # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif }
<S2SV_ModStart> <S2SV_null> static void show_psnr ( struct stream_state * stream , double peak <S2SV_ModStart> sse_to_psnr ( ( double ) stream -> psnr_samples_total , peak <S2SV_ModEnd> , ( double ) stream -> psnr_sse_total ) ;
<S2SV_ModStart> , "Codec:<S2SV_blank>%s\\n" , vpx_codec_iface_name ( global -> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , "Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n" , input -> filename , file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> ) ; } if ( stream -> next || <S2SV_ModStart> ) ; SHOW ( g_h ) ; SHOW ( g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> ) ; SHOW ( rc_resize_allowed ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height ) ; SHOW (
<S2SV_ModStart> & ref_dec ) ; } else { struct vp9_ref_frame ref_enc , ref_dec ; ref_enc . idx = 0 ; ref_dec . idx = 0 ; <S2SV_ModEnd> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , <S2SV_ModStart> ( & stream -> encoder , VP9_GET_REFERENCE , & ref_enc ) ; enc_img = ref_enc <S2SV_ModEnd> . img ; vpx_codec_control ( & stream -> decoder <S2SV_ModStart> ( & stream -> decoder , VP9_GET_REFERENCE , & ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <S2SV_ModEnd> } ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>encoder<S2SV_blank>reference<S2SV_blank>frame" <S2SV_ModStart> [ 4 ] , v [ 4 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <S2SV_ModStart> dec_img , y , u , v ) ; } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void usage_exit ( void ) { int i ; const int num_encoder = get_vpx_encoder_count ( ) ; <S2SV_ModEnd> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\n" , exec_name ) ; <S2SV_ModStart> , "\\nVP9<S2SV_blank>Specific<S2SV_blank>Options:\\n" ) ; arg_show_usage ( stderr , vp9_args ) ; # endif # if CONFIG_VP10_ENCODER fprintf ( stderr , "\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n" ) ; arg_show_usage ( stderr , vp10_args <S2SV_ModStart> ; for ( i = 0 ; i < num_encoder <S2SV_ModEnd> ; ++ i ) { const VpxInterface * const <S2SV_ModStart> * const encoder = get_vpx_encoder_by_index ( i ) ; const char * defstr = ( i == ( num_encoder - 1 ) ) ? "(default)" : "" ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n" <S2SV_ModEnd> , encoder -> name , vpx_codec_iface_name ( encoder -> <S2SV_ModStart> , encoder -> name , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) , defstr ) ; } fprintf ( stderr , "\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ; fprintf ( stderr , "Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n" ) ; <S2SV_ModEnd> exit ( EXIT_FAILURE ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> global ) { const struct stream_state * streami ; ( void ) global ; <S2SV_ModStart> ; if ( stream -> config . cfg . g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) { fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ; } for ( streami = stream ; streami ; streami = streami -> next ) { if ( ! streami -> config . out_fn ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)" , streami -> index ) ; if ( streami != stream ) { const char * a = stream -> config . out_fn ; const char * b = streami -> config . out_fn ; if ( ! strcmp ( a , b ) && strcmp ( a , "/dev/null" ) && strcmp ( a , ":nul" ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } <S2SV_ModEnd> if ( streami != stream ) { const char <S2SV_ModStart> const char * a = stream -> config . stats_fn ; const char * b = streami -> config . stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } # if CONFIG_FP_MB_STATS <S2SV_ModEnd> if ( streami != stream ) { const char <S2SV_ModStart> const char * a = stream -> config . fpmb_stats_fn ; const char * b = streami -> config . fpmb_stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } # endif <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> fopen ( fpf , "rb" ) ; if ( stats -> file == NULL ) fatal ( "First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!" ) ; if (
<S2SV_ModStart> , const struct VpxRational * framerate , vpx_img_fmt_t fmt , unsigned int bit_depth ) { const char * color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> color = fmt == VPX_IMG_FMT_444A ? "C444alpha\\n" : fmt <S2SV_ModStart> : fmt == VPX_IMG_FMT_I422 ? "C422\\n" : "C420jpeg\\n" ; break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p9<S2SV_blank>XYSCSS=444P9\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p9<S2SV_blank>XYSCSS=422P9\\n" : "C420p9<S2SV_blank>XYSCSS=420P9\\n" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p10<S2SV_blank>XYSCSS=444P10\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p10<S2SV_blank>XYSCSS=422P10\\n" : "C420p10<S2SV_blank>XYSCSS=420P10\\n" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p12<S2SV_blank>XYSCSS=444P12\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p12<S2SV_blank>XYSCSS=422P12\\n" : "C420p12<S2SV_blank>XYSCSS=420P12\\n" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p14<S2SV_blank>XYSCSS=444P14\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p14<S2SV_blank>XYSCSS=422P14\\n" : "C420p14<S2SV_blank>XYSCSS=420P14\\n" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p16<S2SV_blank>XYSCSS=444P16\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p16<S2SV_blank>XYSCSS=422P16\\n" : "C420p16<S2SV_blank>XYSCSS=420P16\\n" ; break ; default : color = NULL ; assert ( 0 ) ; }
<S2SV_ModStart> , unsigned char * _aux ) { int c_sz ; ( void ) _aux
<S2SV_ModStart> * _dst , unsigned char * _aux ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
<S2SV_ModStart> int only_420 ) { char buffer [ 80 ] = { 0 } <S2SV_ModStart> } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ; _y4m -> bps = 12 ; _y4m -> bit_depth = 8 <S2SV_ModEnd> ; if ( strcmp ( _y4m -> chroma_type , <S2SV_ModStart> else if ( strcmp ( _y4m -> chroma_type , "420p10" <S2SV_ModEnd> ) == 0 ) { _y4m -> src_c_dec_h = <S2SV_ModStart> ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; <S2SV_ModEnd> _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz <S2SV_ModStart> -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) <S2SV_ModEnd> ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = <S2SV_ModStart> ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "420p12" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "420mpeg2" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , "420paldv" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ; _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ; } else if ( strcmp ( _y4m -> chroma_type , "422jpeg" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422jpeg_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , "422" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I422 ; _y4m -> bps = 16 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , "422p10" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "422p12" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "411" ) == 0 ) { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_411_420jpeg ; } else if ( strcmp ( _y4m -> chroma_type , "444" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_I444 ; _y4m -> bps = 24 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , "444p10" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "444p12" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "444alpha" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , "mono" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , "Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n" , _y4m -> chroma_type ) ; return - 1 ; } <S2SV_ModEnd> _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m <S2SV_ModStart> - 1 ) / _y4m -> dst_c_dec_v ) ; if ( _y4m -> bit_depth == 8 ) <S2SV_ModStart> * ) malloc ( _y4m -> dst_buf_sz ) ; else _y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ; if ( _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz <S2SV_ModEnd> ) ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( pbi -> decoding_thread_count > num_token_partitions - 1 ) { pbi -> decoding_thread_count = num_token_partitions - 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; } <S2SV_ModEnd> # endif } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = 0 ; i < pbi -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_post ( & pbi -> h_event_start_decoding [ <S2SV_ModStart> = 0 ; i < pbi -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_destroy ( & pbi -> h_event_start_decoding [ <S2SV_ModStart> de_thread_data ) ; pbi -> de_thread_data = NULL ; vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;
<S2SV_ModStart> pbi , int mb_rows ) { int i ; <S2SV_ModEnd> vpx_free ( pbi -> mt_current_mb_col ) ; pbi -> <S2SV_ModStart> ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_yabove_row [ i ] ) ; pbi -> mt_yabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_yabove_row ) ; pbi -> mt_yabove_row = NULL ; } if ( pbi -> mt_uabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_uabove_row [ i ] ) ; pbi -> mt_uabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_uabove_row ) ; pbi -> mt_uabove_row = NULL ; } if ( pbi -> mt_vabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_vabove_row [ i ] ) ; pbi -> mt_vabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_vabove_row ) ; pbi -> mt_vabove_row = NULL ; } if ( pbi -> mt_yleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_yleft_col [ i ] ) ; pbi -> mt_yleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_yleft_col ) ; pbi -> mt_yleft_col = NULL ; } if ( pbi -> mt_uleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_uleft_col [ i ] ) ; pbi -> mt_uleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_uleft_col ) ; pbi -> mt_uleft_col = NULL ; } if ( pbi -> mt_vleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) { vpx_free ( pbi -> mt_vleft_col [ i ] ) ; pbi -> mt_vleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_vleft_col ) ; pbi -> mt_vleft_col = NULL ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> mi_cols ; } return 0 ; fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;
<S2SV_ModStart> x_b , x_c , x_d , x_e , x_f <S2SV_ModEnd> ; WORD32 n0 , j0 ; WORD32 * x2 <S2SV_ModStart> x0 ++ ; x_7 = * x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) ; y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) ; y1 [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) ; y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) ; y3 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0 += ( WORD32 ) npoints >>
<S2SV_ModStart> WORD32 l1 , l2 , h2 , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 <S2SV_ModStart> , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 <S2SV_ModStart> x_l2_0 = x [ l2 ] ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) x_l1_0 ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) x_l1_0 ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) x_l2_0 ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) x_l2_0 ; x [ 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 = x [ 1 ] ; <S2SV_ModStart> x [ l2 + 1 ] ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) x_l1_1 ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) x_l1_1 ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) x_l2_1 ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) x_l2_1 ; x [ 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) xh21_0 ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) xl21_0 ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) xl21_0 ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) xl20_0 ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11 = ixheaacd_mult64 ( xt2_0 , co30
<S2SV_ModStart> ; i1 = * qmf_imag ++ ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i1 , r1 ) ; timag = ( <S2SV_ModStart> filter_states_rev [ j ] = timag ; treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i2 , r2 ) ; timag = (
<S2SV_ModStart> u [ k ] ) ; } if ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft != NULL ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) <S2SV_ModEnd> ) ( u_in , u_out , anal_size * 2
<S2SV_ModStart> -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModEnd> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; break ; case 8 <S2SV_ModStart> -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModEnd> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; break ; case 12 <S2SV_ModStart> -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModEnd> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; break ; case 16 <S2SV_ModStart> -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModEnd> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; break ; case 20 <S2SV_ModStart> -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModEnd> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; } ptr_hbe_txposer -> synth_wind_coeff <S2SV_ModStart> patch , MAX_STRETCH ) ; break ; } } <S2SV_ModEnd> if ( ptr_hbe_txposer -> k_start < 0 ) { <S2SV_ModStart> < 0 ) { return - 1 ; } }
<S2SV_ModStart> ) < 0 ) return ; } else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
<S2SV_ModStart> != NULL ) uri -> port = port & USHRT_MAX <S2SV_ModEnd> ; * str = cur ; return ( 0
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> < 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256" ) ;
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> else { pWTIntFrame -> numSamples = numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( "b/26366256" ) ; pWTIntFrame -> numSamples = 0 ; }
<S2SV_ModStart> EAS_U32 value ) { if ( * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( "b/34031018,<S2SV_blank>stackPtr(%d)" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , "34031018" ) ; return EAS_ERROR_FILE_FORMAT ; } <S2SV_ModEnd> * pStackPtr = * pStackPtr + 1 ; pStack
<S2SV_ModStart> , ptblPos , wvplPos , wvplSize ) ; } if ( dls . pDLS ) { <S2SV_ModStart> 0 ) ; dls . artCount = 1 ; }
<S2SV_ModStart> default : break ; } } if ( dataSize < 0 || dataSize
<S2SV_ModStart> j = 0 ; j < book -> dim && i < n
<S2SV_ModStart> j = 0 ; j < book -> dim && i < n <S2SV_ModStart> j = 0 ; j < book -> dim && i < n
<S2SV_ModStart> ( oggpack_eop ( opb ) ) goto errout ; int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; }
<S2SV_ModStart> map_trigger * trigger ; struct map_zone * zone ; size_t tilemap_size ; <S2SV_ModStart> s_map -> layers [ layer ] . height ; tilemap_size = <S2SV_ModEnd> x_size * y_size * sizeof ( struct map_tile ) <S2SV_ModStart> x_size * y_size * sizeof ( struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
<S2SV_ModStart> ) ; if ( extra_length > available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> { memcpy ( cp , qp -> d_memory , original_length <S2SV_ModEnd> ) ; qp -> d_read = cp + (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.64<S2SV_blank>2014/07/24<S2SV_blank>19:35:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> - 2 * sizeof ( uint32_t ) ) ; if ( q < p ) { DPRINTF ( ( "Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n" , q , p ) ) ; goto out ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.190<S2SV_blank>2014/06/03<S2SV_blank>19:01:34<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.61<S2SV_blank>2014/06/04<S2SV_blank>17:23:19<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const char * ) p ) + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ( size_t ) ( e - b ) <= ss <S2SV_ModEnd> * sst -> sst_len ) return 0 ; DPRINTF <S2SV_ModStart> ( size_t ) ( e - b ) , ss * sst -> sst_len , ss <S2SV_ModEnd> , sst -> sst_len ) ) ; errno =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.60<S2SV_blank>2014/05/21<S2SV_blank>13:04:38<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> j ; cdf_secid_t maxsector = ( cdf_secid_t ) ( ( sat -> sat_len * size ) / sizeof ( maxsector ) <S2SV_ModEnd> ) ; DPRINTF ( ( "Chain:" ) ) ; <S2SV_ModStart> size_t ) - 1 ; } if ( sid >= maxsector ) { DPRINTF ( ( "Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n" <S2SV_ModEnd> , sid , maxsector ) ) ; errno =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.171<S2SV_blank>2014/01/08<S2SV_blank>22:02:06<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>apprentice.c,v<S2SV_blank>1.210<S2SV_blank>2014/05/14<S2SV_blank>23:15:42<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.196<S2SV_blank>2014/11/07<S2SV_blank>15:24:14<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>funcs.c,v<S2SV_blank>1.81<S2SV_blank>2015/05/28<S2SV_blank>19:26:59<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { len = ( ms -> c . len = 20 + level <S2SV_ModEnd> ) * sizeof ( * ms -> c .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.55<S2SV_blank>2014/02/27<S2SV_blank>23:26:17<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ss == len ) ; if ( pos + len <S2SV_ModStart> ( ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , pos + len
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>readcdf.c,v<S2SV_blank>1.40<S2SV_blank>2014/03/06<S2SV_blank>15:23:33<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const cdf_property_info_t * info , size_t count , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { size_t i ; cdf_timestamp_t tp ; struct <S2SV_ModStart> len ; if ( ! NOTMIME ( ms ) && root_storage ) str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime ) ; for ( i = 0
<S2SV_ModStart> * h , const cdf_stream_t * sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t si ; cdf_property_info_t * info ; <S2SV_ModStart> 1 ) return - 2 ; break ; } if ( root_storage ) { str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) ; if ( str ) if <S2SV_ModStart> ) == - 1 ) return - 2 ; } <S2SV_ModStart> = cdf_file_property_info ( ms , info , count , root_storage <S2SV_ModEnd> ) ; free ( info ) ; return m
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>funcs.c,v<S2SV_blank>1.73<S2SV_blank>2014/09/10<S2SV_blank>18:41:51<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.197<S2SV_blank>2014/11/11<S2SV_blank>17:48:23<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.188<S2SV_blank>2014/05/14<S2SV_blank>23:15:42<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.62<S2SV_blank>2014/06/04<S2SV_blank>17:26:07<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> sh . sh_properties ; i ++ ) { size_t tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail <S2SV_ModEnd> ) ; q = ( const uint8_t * )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.56<S2SV_blank>2014/05/05<S2SV_blank>16:11:21<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * info , size_t * count ) { size_t <S2SV_ModEnd> maxcount ; const cdf_summary_info_header_t * si = CAST ( <S2SV_ModStart> ssi -> si_class ) ; ssi -> si_count = CDF_TOLE4 <S2SV_ModEnd> ( si -> si_count ) ; * count = <S2SV_ModStart> maxcount = 0 ; * info = NULL ; <S2SV_ModEnd> if ( cdf_read_property_info ( sst , h , CDF_TOLE4 <S2SV_ModStart> count , & maxcount ) == - 1 ) return - 1 ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>apprentice.c,v<S2SV_blank>1.227<S2SV_blank>2014/11/28<S2SV_blank>02:46:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = FILE_ELF_SHNUM_MAX ; ms -> elf_phnum_max = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>file.c,v<S2SV_blank>1.159<S2SV_blank>2014/11/28<S2SV_blank>02:46:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>magic.c,v<S2SV_blank>1.90<S2SV_blank>2014/12/04<S2SV_blank>15:56:46<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.59<S2SV_blank>2014/05/14<S2SV_blank>23:22:48<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( "CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n" ) ) ; goto out ; } <S2SV_ModStart> for ( j = 0 ; j < nelements && i < sh . sh_properties
<S2SV_ModStart> FlatpakProxyClient * client , Buffer * buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer , buffer -> data , buffer -> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> client ) ; g_clear_object ( & client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
<S2SV_ModStart> , & client -> bus_side ) ; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash ,
<S2SV_ModStart> + buffer -> size , extra_data ) ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( "Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; side_closed ( side ) ; break ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void AddSubPST ( SplineChar * sc , struct lookup_subtable <S2SV_ModStart> -> possub ; sc -> possub = pst ; } Sp <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> enum fchooserret CMapFilter ( GGadget * g , GDirEntry <S2SV_ModStart> filename ) ; } return ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVAllSelected ( FontView * fv ) { int <S2SV_ModStart> = true ; } return ( any ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVAnyCharSelected ( FontView * fv ) { int <S2SV_ModStart> ) ; } } return ( val ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontViewBase * FVAny ( void ) { return ( <S2SV_ModStart> ) { return ( FontViewBase * ) fv_list ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVChangeChar ( FontView * fv , int i ) <S2SV_ModStart> i ) ; FVShowInfo ( fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVChangeDisplayFont ( FontView * fv , BDFFont * <S2SV_ModStart> mbh + fv -> infoh ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVChar ( FontView * fv , GEvent * event <S2SV_ModStart> ) FVChangeChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> GFont * FVCheckFont ( FontView * fv , int <S2SV_ModStart> ( fv -> fontset [ type ] ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVCopyInnards ( FontView * fv , GRect * <S2SV_ModStart> fvorig -> colcnt ) / fv -> colcnt ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVCreateInnards ( FontView * fv , GRect * <S2SV_ModStart> 1 ; FVChangeDisplayFont ( fv , bdf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVDelay ( FontView * fv , void ( * <S2SV_ModStart> 0 , ( void * ) func ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVDoTransform ( FontView * fv ) { enum <S2SV_ModStart> FVTransFunc , getorigin , flags , cvt_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVDrawInfo ( FontView * fv , GWindow pixmap , <S2SV_ModStart> ( pixmap , & old ) ; return ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVEncodingMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map -> enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVExpose ( FontView * fv , GWindow pixmap <S2SV_ModStart> ) ; GDrawSetDither ( NULL , true ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVExtraEncSlots ( FontView * fv , int encmax <S2SV_ModStart> -> rowltot , fv -> rowcnt ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> SplineChar * FVFindACharInDisplay ( FontView * fv ) { <S2SV_ModStart> sc ) ; } return ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVForceEncodingMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map -> enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> lineChar <S2SV_ModEnd> * FVMakeChar ( FontView * fv , int enc <S2SV_ModStart> ) ; } else return ( base_sc ) ; } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddEncodingName ( GWindow UNUSED ( gw ) , <S2SV_ModStart> "Invalid<S2SV_blank>Encoding" ) ) ; free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddExtrema ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddUnencoded ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , cnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAnchorPairs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoCounter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoCounter ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoHintSubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoHintSubs ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoHint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoHint ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoInstr ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoInstr ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVAutoWidth2 ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutotrace ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GDrawSetCursor ( fv -> v , ct ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBDFInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBaseHoriz ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , false ) ; SFBaseSort ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBaseVert ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , true ) ; SFBaseSort ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBitmaps ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( mi -> mid == MID_AvailBitmaps ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBlendToNew ( GWindow gw , struct gmenuitem * <S2SV_ModStart> MMChangeBlend ( mm , fv , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildAccent ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildComposite ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildDuplicate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } # i <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCIDFontInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . active_layer , - 1 , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCanonicalContours ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCanonicalStart ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCenter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , mi -> mid == MID_Center ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeChar ( GWindow gw , struct gmenuitem * <S2SV_ModStart> _FVMenuChangeChar ( fv , mi -> mid ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeGlyph ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_generic ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeLayer ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mi -> mid ; FV_LayerChanged ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeMMBlend ( GWindow gw , struct gmenuitem * <S2SV_ModStart> MMChangeBlend ( mm , fv , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeSupplement ( GWindow gw , struct gmenuitem * <S2SV_ModStart> = supple ; FontViewSetTitle ( fv ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeXHeight ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ChangeXHeightDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCharInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map , pos ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCleanup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GDrawGetUserData ( gw ) , - 1 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearBackground ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClearBackground ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearHints ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClearHints ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearInstrs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClearInstrs ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearSpecialData ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClearSpecialData ( ( FontViewBase * ) fv ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClear ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClear ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClose ( GWindow gw , struct gmenuitem * <S2SV_ModStart> container ) ; else _FVMenuClose ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCluster ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompact ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) FVScrollToChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompareFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FontCompareDlg ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompareL2L ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCompareLayerToLayer ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCondense ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; CondenseExtendDlg ( fv , NULL ) ; } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuContextualHelp ( GWindow UNUSED ( base ) , <S2SV_ModStart> e ) ) { help ( "fontview.html" ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuConvert2CID ( GWindow gw , struct gmenuitem * <S2SV_ModStart> SFRestoreNearTop ( fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuConvertByCMap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , NULL ) ; free ( cmapfilename ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyFgBg ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVCopyFgtoBg ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyFrom ( GWindow UNUSED ( gw ) , <S2SV_ModStart> == MID_DisplayedFont ) ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyL2L ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCopyLayerToLayer ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyLookupData ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_lookups ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_reference ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_CopyLBearing ? ut_lbearing : ut_rbearing ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopy ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_fullcopy ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCorrectDir ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVCorrectDir ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCorrectRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCorrectReferences ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCreateMM ( GWindow UNUSED ( gw ) , <S2SV_ModStart> e ) ) { MMWizard ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCut ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClear ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDefineGroups ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; DefineGroups ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDeltas ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; DeltaSuggestionDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDeselectAll ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVDeselectAll ( fv ) ; } en <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDetachAndRemoveGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVDetachAndRemoveGlyphs ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDetachGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVDetachGlyphs ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDisplayByGroups ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; DisplayGroups ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDisplaySubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDontAutoHint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVDontAutoHint ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEditInstrs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , index ) ; SCEditInstructions ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEditTable ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , 'v' , 't' , '<S2SV_blank>' ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEmbolden ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; EmboldenDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuExecute ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ScriptDlg ( fv , NULL ) ; } # e <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuExit ( GWindow UNUSED ( base ) , <S2SV_ModStart> e ) ) { _MenuExit ( NULL ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFindProblems ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FindProblems ( fv , NULL , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFindRpl ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; SVCreate ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFlattenByCMap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf ) ; free ( cmapname ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFlatten ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) return ; SFFlatten ( & cidmaster ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFontInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> is_modal ) return ; FontMenuFontInfo ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuForceEncode ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FontViewReformatOne ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerateFamily ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_macfamily ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerateTTC ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_ttc ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphLabel ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , false ) ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsBoth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsSplines ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsWhite ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGotoChar ( GWindow gw , struct gmenuitem * <S2SV_ModStart> pos ) ; FVShowInfo ( fv ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuHistograms ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_VStemHist ? hist_vstem : hist_blues ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuImport ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) fv , bdf ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInsertBlank ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInsertFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , new ) ; CIDMasterAsDes ( new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInterpFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVInterpolateFonts ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInvertSelection ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVInvertSelection ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuItalic ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ItalicDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuJoin ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVJoin ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuJustify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> b . cidmaster ; JustifyDlg ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKPCloseup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKernByClasses ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKernPairs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . sf , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLigatures ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . sf , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLoadEncoding ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( e ) ) { LoadEncodingFile ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLoadNamelist ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( old ) ; fclose ( new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMATHInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMMInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; MMWizard ( mm ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMMValid ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; MMValid ( mm , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMagnify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> show ) ; } free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMakeFromFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . map ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMakeNamelist ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , file ) ; fclose ( file ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMassRename ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVMassGlyphRename ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMergeFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVMergeFonts ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMergeKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . map ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuNLTransform ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; NonLinearDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuNameGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewReformatAll ( fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOblique ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ObliqueDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenBitmap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) BitmapViewCreatePick ( i , fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenMetrics ( GWindow gw , struct gmenuitem * <S2SV_ModStart> show ? NULL : fv -> show ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenOutline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( sc , fv , i ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpen ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuOpen ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOutline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOverlap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_Intersection ? over_intersect : over_findinter ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPOV ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) fv , & pov_data ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPasteAfter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b , 2 , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPasteInto ( GWindow gw , struct gmenuitem * <S2SV_ModStart> * ) fv , true , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPaste ( GWindow gw , struct gmenuitem * <S2SV_ModStart> * ) fv , false , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPrint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> PrintFFDlg ( fv , NULL , NULL ) ; } # i <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRedo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRedo ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuReencode ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) FVScrollToChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveEncoding ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( e ) ) { RemoveEncoding ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveFontFromCID ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf ) ; SplineFontFree ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVRemoveKerns ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveUndoes ( GWindow gw , struct gmenuitem * <S2SV_ModStart> selected , fv -> b . map ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveUnused ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRemoveUnused ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveVKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVRemoveVKerns ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRenameByNamelist ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuReplaceWithRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; FVReplaceOutlineWithReference ( fv , .001 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevertBackup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVRevertBackup ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevertGlyph ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRevertGlyph ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevert ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVRevert ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRmInstrTables ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( fv -> b . sf ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRound2Hundredths ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , 100.0 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRound2Int ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , 1.0 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSameGlyphAs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSaveAs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuSaveAs ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSave ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuSave ( fv ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectAll ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVSelectAll ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectAutohintable ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByName ( GWindow _gw , struct gmenuitem * <S2SV_ModStart> 0 ; } } GDrawDestroyWindow ( gw ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByPST ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVSelectByPST ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByScript ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( fv , SelMergeType ( e ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectChanged ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectColor ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , col , SelMergeType ( e ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectHintingNeeded ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectWorthOutputting ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetColor ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; } FVSetColor ( fv , col ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetExtremumBound ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; } } free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_SetBearings ? wt_bearings : wt_vwidth ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShadow ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowAtt ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowBitmap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata ; FV_ChangeDisplayBitmap ( fv , bdf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowDependentRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; SCRefBy ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowDependentSubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; SCSubBy ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowMetrics ( GWindow fvgw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowSubFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata ; FVShowSubFont ( fv , new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSimplifyMore ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSimplify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSize ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ] -> display_size = - dspsize ; } } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSmallCaps ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_smallcaps ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuStroke ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVStroke ( fv ) ; } # <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSubSup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_subsuper ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuTransform ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVDoTransform ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUndoFontLevel ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; SFUndoRemoveAndFree ( sf , undo ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUndo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVUndo ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUnlinkRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVUnlinkRef ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuVKernByClasses ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuVKernFromHKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVVKernFromHKern ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuValidate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , ff_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuWSize ( GWindow gw , struct gmenuitem * <S2SV_ModStart> default_fv_row_count = v ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuWireframe ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMouse ( FontView * fv , GEvent * <S2SV_ModStart> et_mouseup ) SVAttachFV ( fv , 2 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVRefreshChar ( FontView * fv , int gid ) <S2SV_ModStart> fv , enc , true ) ; } } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVRegenChar ( FontView * fv , SplineChar * sc <S2SV_ModStart> FVRegenChar ( fv , dlist -> sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVResize ( FontView * fv , GEvent * <S2SV_ModStart> -> colcnt ; SavePrefs ( true ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVScrollToChar ( FontView * fv , int i ) <S2SV_ModStart> v , NULL , false ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVScrollToGID ( FontView * fv , int gid <S2SV_ModStart> . map -> backmap [ gid ] ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVScroll ( GGadget * g , GEvent * <S2SV_ModStart> cbh ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVSelCount ( FontView * fv ) { int <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVSelectByName ( FontView * fv , char * <S2SV_ModStart> sel_index = 1 ; return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSelectByScript ( FontView * fv , int merge <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSelectColor ( FontView * fv , uint32 col <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSetColor ( FontView * fv , uint32 col <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVSetUIToMatch ( FontView * destfv , FontView * srcfv <S2SV_ModStart> new ) ; BDFFontFree ( old ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic void FVShowInfo ( FontView * fv ) ; v <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVShowSubFont ( FontView * fv , SplineFont * <S2SV_ModStart> fv -> v , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSimplify ( FontView * fv , int type <S2SV_ModStart> ( FontViewBase * ) fv , smpl ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVTimer ( FontView * fv , GEvent * <S2SV_ModStart> userdata ) ; func ( fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVTitleUpdate ( FontViewBase * fv ) { FontViewSetTitle ( <S2SV_ModStart> FontViewSetTitle ( ( FontView * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVWindowMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> = ErrorWindowExists ( ) ; break ; } } } GM <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_BiggerGlyphCache ( FontView * fv , int gidcnt <S2SV_ModStart> gidcnt , fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ChangeDisplayBitmap ( FontView * fv , BDFFont * <S2SV_ModStart> b . sf -> display_size = 1 ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ChangeGID ( FontView * fv , int gid <S2SV_ModStart> . map -> backmap [ gid ] ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_LayerChanged ( FontView * fv ) { extern <S2SV_ModStart> filled -> pixelsize ; BDFFontFree ( old ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ReattachCVs ( SplineFont * old , SplineFont * <S2SV_ModStart> } } GDrawProcessPendingEvents ( NULL ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ShowFilled ( FontView * fv ) { fv <S2SV_ModStart> ; fv -> b . active_bitmap = NULL ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FontIsActive ( SplineFont * sf ) { FontView <S2SV_ModStart> ( true ) ; return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> ntView <S2SV_ModEnd> * FontNew ( void ) { return ( FontView_Create <S2SV_ModStart> ( SplineFontNew ( ) , false ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> SplineFont * FontOfFilename ( const char * filename ) <S2SV_ModStart> sf ) ; } return ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id FontViewFinishNonStatic ( ) { FontViewFinish ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewFinish ( ) { if ( ! fontview_ready <S2SV_ModStart> ( mblist ) ; mbFreeGetText ( fvpopupmenu ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewInit ( void ) { if ( fontview_ready <S2SV_ModStart> fvpopupmenu ) ; atexit ( & FontViewFinishNonStatic ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewOpenKids ( FontView * fv ) { int <S2SV_ModStart> while ( k < sf -> subfontcnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FontViewRemove ( FontView * fv ) { if ( <S2SV_ModStart> } FontViewFree ( & fv -> b ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewSetTitle ( FontView * fv ) { unichar_t <S2SV_ModStart> ( title ) ; free ( ititle ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewSetTitles ( SplineFont * sf ) { FontView <S2SV_ModStart> . nextsame ) ) FontViewSetTitle ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FontViewWinInfo ( FontView * fv , int * <S2SV_ModStart> fv -> rowoff * fv -> colcnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontView * FontView_Append ( FontView * fv ) { <S2SV_ModStart> ) fv ; } return ( fv ) ; } Fo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_Close ( FontView * fv ) { if <S2SV_ModStart> gw ) ; else FontViewRemove ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontView * FontView_Create ( SplineFont * sf , int <S2SV_ModStart> fv ) ; } return ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_Free ( FontView * fv ) { int <S2SV_ModStart> ) ; # endif free ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_ReformatAll ( SplineFont * sf ) { BDFFont <S2SV_ModStart> -> gw , NULL , false ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_ReformatOne ( FontView * fv ) { FontView <S2SV_ModStart> GDrawSetCursor ( fv -> v , ct_pointer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int GS_Cancel ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int GS_OK ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> ar <S2SV_ModEnd> * GetPostScriptFontName ( char * dir , int mult <S2SV_ModStart> ( ret ) ; return ( temp ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int IsBackupName ( char * filename ) { if <S2SV_ModStart> filename ) - 1 ] == '~' ) ; } in <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> KFFontViewInits ( struct kf_dlg * kf , GGadget * <S2SV_ModStart> ( drawable , NULL , & gsize ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuAbout ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> ( e ) ) { ShowAboutScreen ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuExit ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> ; else DelayEvent ( _MenuExit , NULL ) ; } ch <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuHelp ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> e ) ) { help ( "overview.html" ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuIndex ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> e ) ) { help ( "IndexFS.html" ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuLicense ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> e ) ) { help ( "license.html" ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuNew ( GWindow UNUSED ( gw ) , struct <S2SV_ModStart> ( e ) ) { FontNew ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuPrefs ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> ( e ) ) { DoPrefs ( ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuSaveAll ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> ! _FVMenuSave ( fv ) ) return ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MenuXRes ( GWindow UNUSED ( base ) , struct <S2SV_ModStart> ( e ) ) { DoXRes ( ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> MergeKernInfo ( SplineFont * sf , EncMap * map <S2SV_ModStart> ( ret ) ; free ( temp ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> SCPreparePopup ( GWindow gw , SplineChar * sc , <S2SV_ModStart> , msg ) ; free ( msg ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int SFAnyChanged ( SplineFont * sf ) { if <S2SV_ModStart> } else return ( sf -> changed ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int SS_Cancel ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int SS_OK ( GGadget * g , GEvent * <S2SV_ModStart> = 2 ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int SS_ScriptChanged ( GGadget * g , GEvent * <S2SV_ModStart> buf ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int SaveAs_FormatChange ( GGadget * g , GEvent * <S2SV_ModStart> true ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> enum merge_type SelMergeType ( GEvent * e ) { <S2SV_ModStart> ksm_control ) ? mt_restrict : 0 ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> char * SubMatch ( char * pattern , char <S2SV_ModStart> ++ pattern ; } return ( name ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int WildMatch ( char * pattern , char * <S2SV_ModStart> ( true ) ; return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> _FVCloseWindows ( FontView * fv ) { int i <S2SV_ModStart> . sf ) ; SVDetachFV ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void _FVMenuChangeChar ( FontView * fv , int mid <S2SV_ModStart> enccount ) FVChangeChar ( fv , pos ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int _FVMenuClose ( FontView * fv ) { int <S2SV_ModStart> -> fv != & fv -> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ; <S2SV_ModStart> -> gw ) ; return ( true ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> t <S2SV_ModEnd> _FVMenuGenerate ( FontView * fv , int family ) <S2SV_ModStart> : fv -> b . normal ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> _FVMenuOpen ( FontView * fv ) { char * <S2SV_ModStart> DefaultDir ) { free ( DefaultDir ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> t <S2SV_ModEnd> _FVMenuSaveAs ( FontView * fv ) { char * <S2SV_ModStart> filename ) ; } return ( ok ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> t <S2SV_ModEnd> _FVMenuSave ( FontView * fv ) { int ret <S2SV_ModStart> true ; } } return ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> enum fchooserret _FVSaveAsFilterFunc ( GGadget * g , struct <S2SV_ModStart> -> isdir ) return fc_show ; return fc_hide ; } in <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void _MenuExit ( void * UNUSED ( junk ) <S2SV_ModStart> ( NULL ) ; exit ( 0 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> _MenuWarnings ( GWindow UNUSED ( gw ) , struct <S2SV_ModStart> ( e ) ) { ShowErrorWindow ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontView * __FontViewCreate ( SplineFont * sf ) { <S2SV_ModStart> pid_webfontserver = 0 ; return ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void aplistbuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . sf , FVMenuAnchorPairs ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void balistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ti . disabled = ! anybuildable ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void cblistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> -> anchor == NULL ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void cdlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> = cidmaster == NULL ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void cflistcheck ( GWindow UNUSED ( gw ) , <S2SV_ModStart> . checked = copyttfinstr ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void * ddgencharlist ( void * _fv , int32 <S2SV_ModStart> len = cnt ; return ( data ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void delistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> [ gid ] ) ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void do_Adobe_Pua ( unichar_t * buf , int sob <S2SV_ModStart> ; } buf [ j ] = 0 ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void edlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf -> undoes ) ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ellistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf -> onlybitmaps ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void enlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . cidmaster != NULL ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void fllistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> -> onlybitmaps || in_modal ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int fv_e_h ( GWindow gw , GEvent * event <S2SV_ModStart> ; break ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int getorigin ( void * UNUSED ( d ) <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gllistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> glyphlabel == mi -> mid ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gs_activateMe ( struct fvcontainer * UNUSED ( fvc <S2SV_ModStart> , FontViewBase * UNUSED ( fvb ) ) { } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gs_charEvent ( struct fvcontainer * fvc , void <S2SV_ModStart> FVChar ( gs -> fv , event ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gs_doClose ( struct fvcontainer * fvc ) { <S2SV_ModStart> ) fvc ; gs -> done = true ; } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gs_doResize ( struct fvcontainer * fvc , FontViewBase <S2SV_ModStart> ( gs -> gw , CID_TopBox ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int gs_e_h ( GWindow gw , GEvent * event <S2SV_ModStart> ; break ; } return ( true ) ; } ch <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void gs_sizeSet ( struct gsd * gs , GWindow <S2SV_ModStart> fv -> v , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int gs_sub_e_h ( GWindow pixmap , GEvent * event <S2SV_ModStart> ; break ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void htlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> anychars == - 1 ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void infolistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> anychars == - 1 ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void lylistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sub ) ; mi -> sub = sub ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int md_e_h ( GWindow gw , GEvent * e <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void mmlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> || mm -> apple ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void mtlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf -> hasvmetrics ; break ; } } } # i <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void noop ( void * UNUSED ( _fv ) <S2SV_ModStart> ( void * UNUSED ( _fv ) ) { } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void sllistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GDrawGetUserData ( gw ) ; fv = fv ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int ss_e_h ( GWindow gw , GEvent * event <S2SV_ModStart> ; break ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void trlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf -> onlybitmaps ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void utf82u_annot_strncat ( unichar_t * to , const char <S2SV_ModStart> = ch ; } * to = 0 ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int v_e_h ( GWindow gw , GEvent * event <S2SV_ModStart> ; break ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void validlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf -> multilayer ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void vwlistcheck ( GWindow gw , struct gmenuitem * <S2SV_ModStart> || sf -> multilayer ; break ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> unichar_t * AskSetting ( struct macsettingname * temp , <S2SV_ModStart> ) ; return ( sd . ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ChangeSetting ( GGadget * list , int index <S2SV_ModStart> list , index , ustr , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void CheckObsoletePrefs ( void ) { if ( alwaysgenapple <S2SV_ModStart> != 0 ) old_sfnt_flags = old_ttf_flags | old_otf_flags ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int DefaultEncoding ( void ) { const char * <S2SV_ModStart> ( e_iso8859_1 ) ; return ( enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void DefaultXUID ( void ) { int r1 , <S2SV_ModStart> ) ; xuid = copy ( buffer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FileChooserPrefsChanged ( void * pointless ) { SavePrefs <S2SV_ModStart> * pointless ) { SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> GListAddStr ( GGadget * list , unichar_t * str <S2SV_ModStart> GGadgetSetList ( list , replace , false ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> GListReplaceStr ( GGadget * list , int index , <S2SV_ModStart> GGadgetSetList ( list , replace , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void GetFileChooserPrefs ( void ) { unichar_t * * <S2SV_ModStart> gfc_bookmarks ) ; gfc_bookmarks = NULL ; } } } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ParseMacMapping ( char * pt , struct macsettingname <S2SV_ModStart> ( end [ 3 ] & 0xff ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ParseNewMacFeature ( FILE * p , char * <S2SV_ModStart> MacFeatListFree ( user_mac_feature_map ) ; user_mac_feature_map = default_mac_feature_map ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_DefaultMapping ( GGadget * g , GEvent * <S2SV_ModStart> ti ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_DelMapping ( GGadget * g , GEvent * <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_EditMapping ( GGadget * g , GEvent * <S2SV_ModStart> flist ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> GTextInfo * Pref_MappingList ( int use_user ) { struct <S2SV_ModStart> buf ) ; } return ( ti ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_MappingSel ( GGadget * g , GEvent * <S2SV_ModStart> flist ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_NewMapping ( GGadget * g , GEvent * <S2SV_ModStart> NULL ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsInit ( void ) { static int done <S2SV_ModStart> ( visible_prefs_list [ i ] . tab_name ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int PrefsUI_GetPrefs ( char * name , Val * <S2SV_ModStart> ) ; } } return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_LoadPrefs_FromFile ( char * filename ) { FILE <S2SV_ModStart> ; } } fclose ( p ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_LoadPrefs ( void ) { char * prefs <S2SV_ModStart> ProcessFileChooserPrefs ( ) ; GDrawEnableCairo ( prefs_usecairo ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_SavePrefs ( int not_if_script ) { char * <S2SV_ModStart> , default_mac_feature_map ) ; fclose ( p ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_SetDefaults ( void ) { DefaultXUID ( ) <S2SV_ModStart> ( ) ; local_encoding = DefaultEncoding ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int PrefsUI_SetPrefs ( char * name , Val * <S2SV_ModStart> ) ; } } return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> char * PrefsUI_getFontForgeShareDir ( void ) { return getShareDir <S2SV_ModStart> ( void ) { return getShareDir ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_BrowseFile ( GGadget * g , GEvent * <S2SV_ModStart> ret ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_Cancel ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> Prefs_LoadDefaultPreferences ( void ) { char filename [ PATH_MAX <S2SV_ModStart> , sharedir ) ; PrefsUI_LoadPrefs_FromFile ( filename ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_Ok ( GGadget * g , GEvent * <S2SV_ModStart> ; } } } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_ScriptBrowse ( GGadget * g , GEvent * <S2SV_ModStart> ret ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ProcessFileChooserPrefs ( void ) { unichar_t * * <S2SV_ModStart> ; } GFileChooserSetPrefsChangedCallback ( NULL , FileChooserPrefsChanged ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int e_h ( GWindow gw , GEvent * event <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int encmatch ( const char * enc , int <S2SV_ModStart> e_iso8859_1 ) ; } return ( e_unknown ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> char * getPfaEditPrefs ( void ) { static char <S2SV_ModStart> = copy ( buffer ) ; return prefs ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int set_e_h ( GWindow gw , GEvent * event <S2SV_ModStart> ) ; } } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> ) ; } } fclose ( file ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> 24 ) ) ; if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
<S2SV_ModStart> new_header ; size_t new_raw_len ; uint8_t * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> # if defined ( CHECK_MEMORY_USAGE ) static u32 numBytes <S2SV_ModStart> static u32 numBytes = 0 ; numBytes += size * num <S2SV_ModStart> ) ) ; # endif return malloc ( size * num
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u8 * ) H264SwDecMalloc ( sizeof ( u8 ) , <S2SV_ModEnd> strmLen ) ; if ( byteStrm == NULL )
<S2SV_ModStart> decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) , 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( "can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes" , size , num ) ; android_errorWriteLog ( 0x534e4554 , "27855419" ) ; return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size , 1
<S2SV_ModStart> ( maxFrameNum ) ; ASSERT ( dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( "b/28533562" ) ; android_errorWriteLog ( 0x534e4554 , "28533562" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
<S2SV_ModStart> pStorage -> sps [ pStorage -> activeSpsId ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { pStorage -> picSizeInMbs = <S2SV_ModEnd> pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps <S2SV_ModStart> -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; }
<S2SV_ModStart> DownmixLib_Create ( const effect_uuid_t * uuid , int32_t sessionId __unused , int32_t ioId __unused <S2SV_ModEnd> , effect_handle_t * pHandle ) { int ret ;
<S2SV_ModStart> case EFFECT_CMD_INIT : if ( pReplyData == NULL || replySize == NULL || <S2SV_ModStart> || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize <S2SV_ModStart> ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize <S2SV_ModStart> int32_t ) ) ) || pReplyData == NULL || replySize == NULL || <S2SV_ModStart> case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || <S2SV_ModStart> ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || replySize
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int Downmix_Reset ( downmix_object_t * pDownmixer __unused , bool init __unused <S2SV_ModEnd> ) { return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cmd = ( effect_param_t * ) pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , "63662938" ) ; return - EINVAL ; }
<S2SV_ModStart> const char * perm = "add" ; if ( multiuser_get_app_id ( uid ) <S2SV_ModEnd> >= AID_APP ) { return 0 ; } return
<S2SV_ModStart> ) { const char * perm = "add" ; if ( uid >= AID_APP ) { return 0 ; }
<S2SV_ModStart> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len <S2SV_ModEnd> ) ; return r ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> + len - ( nlen + 1 ) ; memcpy ( m , name , nlen + 1 <S2SV_ModEnd> ) ; for ( p = path ; p
<S2SV_ModStart> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> static void record_recent_object ( struct object * obj , const char * name <S2SV_ModEnd> , void * data ) { sha1_array_append ( &
<S2SV_ModStart> static void show_object ( struct object * obj , const char * name , void * data ) { <S2SV_ModEnd> add_preferred_base_object ( name ) ; add_object_entry ( obj -> <S2SV_ModStart> 0 ) ; obj -> flags |= OBJECT_ADDED ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void finish_object ( struct object * obj <S2SV_ModEnd> , const char * name , void * cb_data
<S2SV_ModStart> static void show_object ( struct object * obj , const char * name <S2SV_ModEnd> , void * cb_data ) { struct rev_list_info * <S2SV_ModStart> * info = cb_data ; finish_object ( obj , name <S2SV_ModEnd> , cb_data ) ; if ( info -> flags <S2SV_ModStart> ) return ; show_object_with_name ( stdout , obj , name <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> object * obj = & blob -> object ; size_t pathlen ; <S2SV_ModStart> ) return ; obj -> flags |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; show ( obj , path -> buf , cb_data ) ; strbuf_setlen ( path , pathlen ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } obj -> flags |= SEEN ; strbuf_addstr ( base , name ) ; show ( obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if ( base -> len ) strbuf_addch
<S2SV_ModStart> -> flags |= SEEN ; show_object ( obj , <S2SV_ModEnd> name , data ) ; continue ; } if <S2SV_ModStart> ( struct blob * ) obj , show_object , & base <S2SV_ModEnd> , path , data ) ; continue ; }
<S2SV_ModStart> static void show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap *
<S2SV_ModStart> static void show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap * <S2SV_ModStart> hash ) ; if ( bitmap_pos < 0 ) <S2SV_ModEnd> bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_ModStart> bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_ModEnd> bitmap_set ( base , bitmap_pos ) ; } <S2SV_null>
<S2SV_ModStart> static void test_show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap_test_data *
<S2SV_ModStart> mark_object ( & c -> object , NULL , <S2SV_ModEnd> data ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void mark_object ( struct object * obj <S2SV_ModEnd> , const char * name , void * data
<S2SV_ModStart> FILE * out , struct object * obj , const char * name ) { const <S2SV_ModEnd> char * p ; fprintf ( out , "%s<S2SV_blank>" <S2SV_ModStart> ) ; fputc ( '\\n' , out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.46<S2SV_blank>2011/09/16<S2SV_blank>21:23:59<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; o += l >> 2 ; if ( q + o >= e ) goto out ;
<S2SV_ModStart> const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SEC_SIZE ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModEnd> == len ) ; return cdf_read ( info , <S2SV_ModStart> ; return cdf_read ( info , ( off_t ) pos <S2SV_ModEnd> , ( ( char * ) buf ) +
<S2SV_ModStart> const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( "bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModEnd> ( void ) memcpy ( ( ( char * <S2SV_ModStart> const char * ) sst -> sst_tab ) + pos <S2SV_ModEnd> , len ) ; return len ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.49<S2SV_blank>2012/02/20<S2SV_blank>20:04:37<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) <S2SV_ModEnd> ) ; if ( q > e ) { <S2SV_ModStart> i ] . pi_type , q - p , offs <S2SV_ModEnd> ) ) ; if ( inp [ i ]
<S2SV_ModStart> h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( <S2SV_ModStart> ss == len ) ; if ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> sst_len ) { DPRINTF ( ( <S2SV_ModStart> ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> sst_len ) ) ; return -
<S2SV_ModStart> , cdf_stream_t * scn ) { size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) , i , j ; scn
<S2SV_ModStart> ) inf_gnutls_set_error ( & error , ret ) ; } if ( error == NULL ) <S2SV_ModEnd> if ( verify & GNUTLS_CERT_INVALID ) inf_gnutls_certificate_verification_set_error ( & <S2SV_ModStart> ) inf_gnutls_certificate_verification_set_error ( & error , verify ) ; <S2SV_ModEnd> } table = NULL ; if ( error ==
<S2SV_ModStart> uint32_t size ) { if ( ms ) { uint32_t nestsize = ( uint32_t <S2SV_ModEnd> ) ms -> nest_size [ ms -> nest_level ]
<S2SV_ModStart> ) - 1 ) ; the_url [ sizeof ( the_url <S2SV_ModEnd> ) - 1 ] = 0 ; } gf_dm_sess_del
<S2SV_ModStart> for ( i = 0 ; i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { if ( ! unicode_type && ( <S2SV_ModStart> 1 ] & 0xc0 ) != 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> szLine [ i ] &= 0xbf ; } else break ; } else <S2SV_ModStart> i ] & 0xe0 ) == 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if ( ( szLine [ i ] <S2SV_ModStart> i ] & 0xf0 ) == 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if ( ( szLine [ i ] <S2SV_ModStart> i ] & 0xf8 ) == 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { i += 1 ; continue ; <S2SV_ModStart> { i += 1 ; continue ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j ] = 0 ; strcpy (
<S2SV_ModStart> = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof ( cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } <S2SV_ModStart> strcpy ( cat_enum . szPath , "." ) ; if ( strlen ( fileName ) >= sizeof ( cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , fileName ) ; } else { if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModEnd> , sep + 1 ) ; sep [ 0 <S2SV_ModStart> strchr ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 <S2SV_ModEnd> , sep + 1 ) ; sep [ 0 <S2SV_ModStart> , "" ) ; if ( sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n" , sep ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szOpt <S2SV_ModEnd> , sep ) ; sep [ 0 ] =
<S2SV_ModStart> . to_url , 1 , no_mime_check ) ) { strncpy ( the_url , evt -> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf ( stderr , "Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url )
<S2SV_ModStart> gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } <S2SV_ModEnd> ext = strrchr ( the_url , '.' ) ; <S2SV_ModStart> ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> gf_dm_sess_del ( sess ) ; } } playlist = <S2SV_ModStart> , "StartupFile" ) ; if ( str ) { strncpy ( the_url , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; gf_term_connect ( term , str ) ; startup_file
<S2SV_ModStart> { const size_t sepIdx = sep - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> { const size_t sepIdx = sep2 - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> ) ; szKey [ sepIdx ] = 0 ; if ( strlen ( sep2 + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 ) <S2SV_ModEnd> ; } if ( ! stricmp ( szKey ,
<S2SV_ModStart> = GF_FALSE ; char * ext , szName [ 1024 <S2SV_ModEnd> ] , szExt [ 20 ] ; const char <S2SV_ModStart> = ( FFDemux * ) plug -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt )
<S2SV_ModStart> unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> to_read ) ; i = 0 ; while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) <S2SV_ModEnd> ) { i ++ ; } if ( i
<S2SV_ModStart> GF_DataInformationBox * ) s ) -> dref ) { GF_Box * dref ; <S2SV_ModStart> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> s ) -> dref = ( GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; } return GF_OK ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , bx , ax , ctx -> rounds , dec_tables . T <S2SV_ModEnd> ) ; # elif defined ( USE_ARM_ASM ) return <S2SV_ModStart> , bx , ax , ctx -> rounds , dec_tables . T <S2SV_ModEnd> ) ; # else return do_decrypt_fn ( ctx ,
<S2SV_ModStart> , bx , ax , ctx -> rounds , enc_tables . T <S2SV_ModEnd> ) ; # elif defined ( USE_ARM_ASM ) return <S2SV_ModStart> , bx , ax , ctx -> rounds , enc_tables . T <S2SV_ModEnd> ) ; # else return do_encrypt_fn ( ctx ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void prefetch_dec ( void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static void prefetch_enc ( void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; prefetch_table ( ( const void * ) & enc_tables , sizeof ( enc_tables <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline <S2SV_ModStart> size_t i ; for ( i = 0 ; len - i >= 8 * 32 <S2SV_ModEnd> ; i += 8 * 32 ) { ( <S2SV_ModStart> [ i + 7 * 32 ] ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
<S2SV_ModStart> * buffer , int len ) { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( h2o_http2_conn_t * conn ) { conn -> <S2SV_ModStart> { } else { close_connection_now ( conn ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; return ; } update_idle_timeout ( conn ) ; if ( parse_input ( conn ) != 0 ) return <S2SV_ModEnd> ; if ( h2o_timeout_is_linked ( & conn -> _write
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> parse_input ( h2o_http2_conn_t * conn ) { size_t http2_max_concurrent_requests_per_connection <S2SV_ModStart> : ( h2o_iovec_t ) { } ) ; } return close_connection ( conn ) <S2SV_ModEnd> ; } h2o_buffer_consume ( & conn -> sock -> <S2SV_ModStart> ( conn -> sock , on_read ) ; return 0 <S2SV_ModStart> ) ) h2o_socket_read_stop ( conn -> sock ) ; return 0 ;
<S2SV_ModStart> if ( cpkt . cptype == MT_CPTYPE_PASSSALT ) { if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( "Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } memcpy ( pass_salt , cpkt . data , 16 <S2SV_ModEnd> ) ; send_auth ( username , password ) ;
<S2SV_ModStart> unsigned char md5sum [ 17 ] ; int plen , act_pass_len <S2SV_ModStart> , sizeof ( md5data ) ) ; # endif act_pass_len = strnlen ( password , 82 ) ; md5data [ 0 ] = 0 ; memcpy ( md5data + 1 , password , act_pass_len ) ; memcpy ( md5data + 1 + act_pass_len <S2SV_ModEnd> , pass_salt , 16 ) ; md5_init ( & <S2SV_ModStart> state , ( const md5_byte_t * ) md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ; md5_finish ( & state , ( md5_byte_t
<S2SV_ModStart> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD && cpkt . length == 17 <S2SV_ModStart> } else { syslog ( LOG_WARNING , _ ( "(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%d" <S2SV_ModEnd> ) , curconn -> seskey , cpkt . cptype <S2SV_ModStart> ) , curconn -> seskey , cpkt . cptype , cpkt . length
<S2SV_ModStart> struct mt_credentials * user ; char * slavename ; int act_pass_len ; <S2SV_ModStart> user -> password ) ) ; } # endif act_pass_len = strlen ( user -> password ) ; act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; md5data [ 0 ] = 0 ; memcpy <S2SV_ModEnd> ( md5data + 1 , user -> password , <S2SV_ModStart> ( md5data + 1 , user -> password , act_pass_len ) ; memcpy ( md5data + 1 + act_pass_len <S2SV_ModEnd> , curconn -> pass_salt , 16 ) ; md5_init <S2SV_ModStart> state , ( const md5_byte_t * ) md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ; md5_finish ( & state , ( md5_byte_t
<S2SV_ModStart> MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; if ( act_size > MT_PACKET_LEN - packet -> size <S2SV_ModEnd> ) { fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"
<S2SV_ModStart> data , unsigned short length ) { if ( length > MT_PACKET_LEN - packet -> size <S2SV_ModEnd> ) { fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"
<S2SV_ModStart> ; unsigned short len = data_len ; if ( data_len > MT_PACKET_LEN - 4 - packet -> size <S2SV_ModEnd> ) { fprintf ( stderr , _ ( "mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"
<S2SV_ModStart> sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
<S2SV_ModStart> == NULL || * replySize < ( int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize -
<S2SV_ModStart> ; param2 = * param_tmp ; if ( param2 < 0 || param2 <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32438598" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ) ; param2 = * param_tmp ; if ( param2 < 0 || <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32436341" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ) ; param2 = * param_tmp ; if ( param2 < 0 || <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32247948" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; }
<S2SV_ModStart> vol_listener_context_t * ) handle ; int status = - EINVAL <S2SV_ModEnd> ; bool recompute_flag = false ; int active_stream_count = <S2SV_ModStart> recompute_flag = false ; int active_stream_count = 0 ; uint32_t session_id ; uint32_t stream_type ; effect_uuid_t uuid ; <S2SV_ModStart> ALOGV ( "%s<S2SV_blank>context<S2SV_blank>%p" , __func__ , handle ) ; if ( recv_contex == NULL ) { return status ; } pthread_mutex_lock ( & vol_listner_init_lock ) ; session_id = recv_contex -> session_id ; stream_type = recv_contex -> stream_type ; uuid = recv_contex -> desc -> uuid <S2SV_ModEnd> ; list_for_each_safe ( node , temp_node_next , & vol_effect_list <S2SV_ModStart> ( context -> desc -> uuid ) , & uuid <S2SV_ModEnd> , sizeof ( effect_uuid_t ) ) == 0 ) <S2SV_ModStart> == 0 ) && ( context -> session_id == session_id ) && ( context -> stream_type == <S2SV_ModEnd> stream_type ) ) { ALOGV ( "---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---" ) ; <S2SV_ModStart> ) { ALOGV ( "---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---" ) ; list_remove ( node <S2SV_ModEnd> ) ; PRINT_STREAM_TYPE ( context -> stream_type ) ; <S2SV_ModStart> != 0 ) { ALOGE ( "something<S2SV_blank>wrong<S2SV_blank>...<S2SV_blank><<<---<S2SV_blank>Found<S2SV_blank>NOTHING<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>...<S2SV_blank>????<S2SV_blank>--->>>>>" ) ; pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ;
<S2SV_ModStart> , r -> e_text , r -> server_princ , r -> client_princ ? & r -> client_princ -> name : NULL , r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL , NULL , reply ) ; if
<S2SV_ModStart> ; krb5_keyblock sessionkey ; krb5_kvno kvno ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , rsp , spn , client , cp , tgt_realm ,
<S2SV_ModStart> * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> context , server -> entry . principal ) , tgt_realm <S2SV_ModEnd> ) ; if ( ret ) goto out ;
<S2SV_ModStart> if ( l_header_read == 0 ) { if ( 3 == <S2SV_ModStart> , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count <S2SV_ModEnd> ) { * o_column_idx = ( unsigned int *
<S2SV_ModStart> if ( l_header_read == 0 ) { if ( 3 == <S2SV_ModStart> , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count <S2SV_ModEnd> ) { * o_column_idx = ( unsigned int *
<S2SV_ModStart> <S2SV_null> smb_sdrc_t smb2_flush ( smb_request_t * sr ) { <S2SV_ModEnd> uint16_t StructSize ; uint16_t reserved1 ; uint32_t reserved2 ; <S2SV_ModStart> status ) ; return ( SDRC_SUCCESS ) ; } smb_ofile_flush ( sr , sr -> fid_ofile <S2SV_ModEnd> ) ; ( void ) smb_mbc_encodef ( & sr
<S2SV_ModStart> ERRbadfid ) ; return ( SDRC_ERROR ) ; } smb_ofile_flush <S2SV_ModEnd> ( sr , sr -> fid_ofile ) ; } <S2SV_ModStart> { mutex_enter ( & file -> f_mutex ) ; smb_ofile_flush <S2SV_ModEnd> ( sr , file ) ; mutex_exit ( &
<S2SV_ModStart> = strchr ( ptr + 1 , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit ( & sdvp -> sdev_contents ) ;
<S2SV_ModStart> dt -> af = AF_INET6 ; } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ; Huff_transmit ( & huff , ch , seq , size << 3
<S2SV_ModStart> ch , byte * fin , int * offset , int maxoffset <S2SV_ModStart> node && node -> symbol == INTERNAL_NODE ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
<S2SV_ModStart> ch , byte * fout , int * offset , int maxoffset <S2SV_ModStart> -> loc [ ch ] , NULL , fout , maxoffset
<S2SV_ModStart> * huff , int ch , byte * fout , int maxoffset <S2SV_ModStart> ) { Huff_transmit ( huff , NYT , fout , maxoffset <S2SV_ModStart> -> loc [ ch ] , NULL , fout , maxoffset
<S2SV_ModStart> node , node_t * child , byte * fout , int maxoffset <S2SV_ModStart> send ( node -> parent , node , fout , maxoffset ) ; } if ( child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; } <S2SV_ModEnd> if ( node -> right == child ) {
<S2SV_ModStart> ; qboolean sgn ; int i , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> ; } if ( msg -> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> 7 ) { nbits = bits & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> data , & msg -> bit , msg -> cursize << 3 <S2SV_ModStart> get << ( i + nbits ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }
<S2SV_ModStart> ; oldsize += bits ; if ( msg -> overflowed ) { <S2SV_ModEnd> return ; } if ( bits == 0 || <S2SV_ModStart> if ( msg -> oob ) { if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> int nbits ; nbits = bits & 7 ; if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> data , & msg -> bit , msg -> maxsize << 3 <S2SV_ModStart> ; value = ( value >> 8 ) ; if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; }
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> int len ; tm = localtime ( & t ) ; if ( tm == NULL ) return g_strdup ( "???"
<S2SV_ModStart> , NICK_REC * nick ) { NICK_REC * list , * newlist <S2SV_ModStart> NULL ) return ; if ( list == nick ) { newlist = nick -> next ; } else { newlist = list ; <S2SV_ModEnd> while ( list -> next != nick ) list <S2SV_ModStart> list -> next = nick -> next ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }
<S2SV_ModStart> , ( SIGNAL_FUNC ) read_settings ) ; signal_remove ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
<S2SV_ModStart> ( "setup<S2SV_blank>changed" , ( SIGNAL_FUNC ) read_settings ) ; signal_add ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;
<S2SV_ModStart> ) ; g_free_not_null ( ircconn -> alternate_nick ) ; g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ;
<S2SV_ModStart> = src -> sasl_mechanism ; rec -> sasl_username = g_strdup ( src -> sasl_username ) ; rec -> sasl_password = g_strdup ( src -> sasl_password ) <S2SV_ModEnd> ; * dest = ( SERVER_CONNECT_REC * ) rec
<S2SV_ModStart> ircnet -> sasl_password ) { conn -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; } else g_warning ( "The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty" ) ; }
<S2SV_ModStart> ) ; VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> load ) || vips_image_pio_input ( load -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_ModStart> vips_foreign_load_iscompat ( load -> real , out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load -> out , load -> out
<S2SV_ModStart> ) ; if ( tls_cnx == NULL ) { flush_cmd ( ) ;
<S2SV_ModStart> ssize_t readnb ; signed char seen_r = 0 ; <S2SV_ModEnd> if ( scanned > ( size_t ) 0U )
<S2SV_ModStart> ( msg_type ) -> raw_struct_size ) return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else
<S2SV_ModStart> , struct in6_addr * addr , uint32_t * ifindex , int * hoplimit <S2SV_ModStart> { struct sockaddr_in6 sin6 ; unsigned char cbuf [ 2 * <S2SV_ModStart> cmsghdr ) ) { if ( cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ; switch ( cmsghdr -> cmsg_type ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct <S2SV_ModStart> ; * ifindex = pktinfo -> ipi6_ifindex ; } break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; }
<S2SV_ModStart> - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."
<S2SV_ModStart> & msg -> addrto , & msg -> ifindex , & msg -> hoplimit <S2SV_ModStart> ; goto free_msg ; } dbg ( ndp , "rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d" <S2SV_ModEnd> , str_in6_addr ( & msg -> addrto ) , <S2SV_ModStart> & msg -> addrto ) , msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , "ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> if ( len < sizeof ( * msg ->
<S2SV_ModStart> = 0 ; tok -> err = json_tokener_success ; if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; }
<S2SV_ModStart> i -- ) { if ( x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) ) return i ; } return 0
<S2SV_ModStart> i ++ ) { if ( x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) ) return i ; } return 0
<S2SV_ModStart> iw_set_error ( rctx -> ctx , "Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type" ) ; goto done ; <S2SV_ModStart> { iw_set_error ( rctx -> ctx , "Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images" ) ; goto done
<S2SV_ModStart> & rctx -> rbuf [ 6 ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>image<S2SV_blank>dimensions" ) ; goto done ; }
<S2SV_ModStart> ; if ( ! PPEEK_IS ( ')' ) ) { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> PINC ; name_end = name = p ; gnum
<S2SV_ModStart> 3 ; j = ntohs ( j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n" ) ; return - 1 ; }
<S2SV_ModStart> if ( * * value == \'"\' ) { char * p = end = * value + 1 ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'"\' ) break ; } p ++ ; end ++ ; } if ( * end != \'"\' <S2SV_ModEnd> ) { DBG ( READ , ul_debug ( "unbalanced<S2SV_blank>quotes<S2SV_blank>at:<S2SV_blank>%s" <S2SV_ModStart> ) ++ ; * end = '\\0' ; end = ++ p <S2SV_ModEnd> ; } else { end = skip_over_word ( *
<S2SV_ModStart> ( p , struct blkid_struct_tag , bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( tag -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( tag -> bit_val , file <S2SV_ModEnd> ) ; } fprintf ( file , ">%s</device>\\n" ,
<S2SV_ModStart> stdout ) ; safe_print ( value , valsz , "<S2SV_blank>\\\\\\"\'$`<>" <S2SV_ModEnd> ) ; fputs ( "\\n" , stdout ) ; <S2SV_ModStart> stdout ) ; safe_print ( value , valsz , "\\"\\\\" <S2SV_ModEnd> ) ; fputs ( "\\"" , stdout ) ;
<S2SV_ModStart> <S2SV_null> int xmkstemp ( char * * tmpname , const char * dir , const char * prefix ) { char * localtmp ; const <S2SV_ModEnd> char * tmpenv ; mode_t old_mode ; int fd <S2SV_ModStart> ; mode_t old_mode ; int fd , rc ; tmpenv = dir ? dir : getenv ( "TMPDIR" ) ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> rc = asprintf ( & localtmp , "%s/%s.XXXXXX" , <S2SV_ModStart> asprintf ( & localtmp , "%s/%s.XXXXXX" , tmpenv , prefix <S2SV_ModEnd> ) ; if ( rc < 0 ) return
<S2SV_ModStart> gecos ; if ( setpwnam ( ctl -> pw , ".chfn"
<S2SV_ModStart> <S2SV_null> <S2SV_null> int setpwnam ( struct passwd * pwd , const char * prefix <S2SV_ModStart> = NULL ; char * tmpname = NULL ; pw_init ( ) ; if ( ( fp = xfmkstemp ( & tmpname , "/etc" , prefix <S2SV_ModEnd> ) ) == NULL ) return - 1 ;
<S2SV_ModStart> * fd ; char * tmpname = NULL ; <S2SV_ModEnd> if ( ( fd = xfmkstemp ( & tmpname <S2SV_ModStart> ( ( fd = xfmkstemp ( & tmpname , "/etc" , ".vipw" <S2SV_ModEnd> ) ) == NULL ) { ulckpwdf ( )
<S2SV_ModStart> } else status = WEXITSTATUS ( status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> } else status = 1 ; if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> ( PAM_SUCCESS ) ; if ( caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ( stderr , _ ( "<S2SV_blank>...killed.\\n" ) ) ; }
<S2SV_ModStart> e || e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> e || e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> ci -> pattern_enc != ci -> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else { cpat = ( UChar *
<S2SV_ModStart> r < 0 ) return r ; } } if ( * state != CCS_START )
<S2SV_ModStart> group_head ) { int r , len , group <S2SV_ModEnd> ; Node * qn ; Node * * tp <S2SV_ModStart> ; Node * qn ; Node * * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> == ( enum TokenSyms ) term ) goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;
<S2SV_ModStart> ; case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 ) ; if ( * p <S2SV_ModStart> s ) goto fail ; p ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT ; break ; case OP_EXACT1_IC :
<S2SV_ModStart> UChar * q = p + reg -> dmin ; if ( q >= end ) return 0
<S2SV_ModStart> : if ( * type == CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> pprev : str ) , * low ) ; }
<S2SV_ModStart> case BAG_IF_ELSE : { int cond_len , then_len , else_len , <S2SV_ModStart> 0 ; jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH <S2SV_ModStart> } if ( IS_NOT_NULL ( Else ) ) { else_len = compile_length_tree ( Else , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModEnd> ; r = add_op ( reg , OP_JUMP ) <S2SV_ModStart> COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r = <S2SV_ModEnd> compile_tree ( Else , reg , env ) ;
<S2SV_ModStart> ) return tlen ; len += tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Else ) ) { <S2SV_ModEnd> tlen = compile_length_tree ( Else , reg ) ;
<S2SV_ModStart> , enc ) ; if ( num < 0 || num >= 256
<S2SV_ModStart> , enc ) ; if ( num < 0 || num >= 256
<S2SV_ModStart> ( pid_t pid , char * val ) { int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> ; int i = 0 ; int foundit = <S2SV_ModStart> return NULL ; for ( ; ; ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; }
<S2SV_ModStart> 5 ; int remainder = bits & 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
<S2SV_ModStart> , "excluded_channels():<S2SV_blank>additional_excluded_chns" ) ) ) == 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
<S2SV_ModStart> length ) ; gfc . gfi = 0 ; last_name = 0 ;
<S2SV_ModStart> * p = line ; while ( isspace ( ( unsigned char )
<S2SV_ModStart> "currentfile<S2SV_blank>eexec" , 17 ) == 0 && isspace ( ( unsigned char ) <S2SV_ModStart> ; for ( line += 18 ; isspace ( ( unsigned char ) <S2SV_ModStart> for ( ; line < last && isspace ( ( unsigned char ) <S2SV_ModStart> ( last >= line + 4 && isxdigit ( ( unsigned char ) line [ 0 ] ) && isxdigit ( ( unsigned char ) line [ 1 ] ) && isxdigit ( ( unsigned char ) line [ 2 ] ) && isxdigit ( ( unsigned char ) <S2SV_ModEnd> line [ 3 ] ) ) blocktyp = PFA_HEX
<S2SV_ModStart> ; s ++ ) { if ( isspace ( ( unsigned char )
<S2SV_ModStart> { for ( s += 9 ; isspace ( ( unsigned char ) <S2SV_ModStart> ; while ( * t && ! isspace ( ( unsigned char )
<S2SV_ModStart> ; if ( body_size > job_data_size_limit ) { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG ) ; } if ( end_buf [
<S2SV_ModStart> ; krb5_error_code err = 0 ; krb5_key_data * key_data = NULL ; if ( n_key_data < <S2SV_ModEnd> 0 ) return NULL ; key_data = k5calloc ( <S2SV_ModStart> key_data ) , & err ) ; if ( key_data <S2SV_ModEnd> == NULL ) goto cleanup ; memcpy ( key_data <S2SV_ModStart> NULL ) { for ( i = 0 ; ret [ i ] != NULL ; i ++ <S2SV_ModEnd> ) free ( ret [ i ] ) ;
<S2SV_ModStart> entry -> n_key_data , mkvno ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod ( & mods , "krbprincipalkey" , <S2SV_ModStart> , "krbprincipalkey" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( ! ( entry -> mask & KADM5_PRINCIPAL
<S2SV_ModStart> i ] , "=" , & arg_val ) ; arg = ( arg != NULL ) ? arg : "" ;
<S2SV_ModStart> = 0 ; krb5_octet response ; krb5_data null_server ; krb5_data d ; <S2SV_ModStart> inbuf ) ) ) return ( retval ) ; d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> ) ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = <S2SV_ModStart> ) return ( retval ) ; if ( appl_version != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> ) { problem = KRB5_SENDAUTH_BADAPPLVERS ; response = 2
<S2SV_ModStart> goto cleanup ; } cleanup : if ( retval == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ; if ( retval
<S2SV_ModStart> realms == NULL || realms [ 0 ] == NULL || * realms [ 0 ] ==
<S2SV_ModStart> ( ptr - bufstart ) ) if ( REMAIN == 0 || REMAIN
<S2SV_ModStart> & min_stat , & gr . gr_token ) ; <S2SV_ModEnd> ret_freegc ( AUTH_FAILED ) ; } * no_dispatch = <S2SV_ModStart> gss_release_buffer ( & min_stat , & gd -> checksum <S2SV_ModEnd> ) ; if ( ! call_stat ) ret_freegc (
<S2SV_ModStart> -> ctx = GSS_C_NO_CONTEXT ; goto errout ; } gr -> gr_ctx . value = "xxxx" ; gr -> gr_ctx . length = 4 <S2SV_ModEnd> ; gr -> gr_win = sizeof ( gd ->
<S2SV_ModStart> , 0 , sizeof ( no_server ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
<S2SV_ModStart> , & use_master , NULL ) ; if ( ! code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP <S2SV_ModEnd> ) { * canon_user = userid . user ;
<S2SV_ModStart> realm = krb5_princ_realm ( kctx , princ ) ; success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , "kadmin" ) && ! data_eq_string ( * c2 , "history" ) ; <S2SV_ModEnd> fail_princ : if ( ! success ) { krb5_klog_syslog
<S2SV_ModStart> = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ctx -> terminated ||
<S2SV_ModStart> = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ctx -> terminated ||
<S2SV_ModStart> minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> ; kgctx . k5_context = NULL ; kgctx . established = 1 ; kgctx .
<S2SV_ModStart> ) ; } if ( check_anon ( kdc_active_realm , client . princ <S2SV_ModEnd> , request -> server ) != 0 ) {
<S2SV_ModStart> ( ptr - bufstart ) ) if ( REMAIN == 0 || REMAIN
<S2SV_ModStart> now ; kadm5_policy_ent_rec pol ; int ret , last_pwd , n_new_keys <S2SV_ModStart> fail_auth_count = 0 ; if ( keyblocks ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; ret = decrypt_key_data ( handle -> context , n_new_keys <S2SV_ModEnd> , kdb -> key_data , keyblocks , n_keys )
<S2SV_ModStart> , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL <S2SV_ModEnd> ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart> ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK <S2SV_ModEnd> ; ret = kdb_get_entry ( handle , entry ->
<S2SV_ModStart> krb5_clear_error_message ( handle -> context ) ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> ; if ( mask & KADM5_TL_DATA ) { tl_data_orig
<S2SV_ModStart> kret ; kdc_realm_t * newrealm ; kret = 0 ; if ( sprinc == NULL ) return NULL
<S2SV_ModStart> char * password = * passptr ; if ( password == NULL ||
<S2SV_ModStart> "Request<S2SV_blank>was<S2SV_blank>truncated" , sizeof ( strresult ) ) ; goto bailout <S2SV_ModEnd> ; } ptr = req -> data ; plen <S2SV_ModStart> "Request<S2SV_blank>length<S2SV_blank>was<S2SV_blank>inconsistent" , sizeof ( strresult ) ) ; goto bailout <S2SV_ModEnd> ; } vno = ( * ptr ++ & <S2SV_ModStart> strresult ) , "Request<S2SV_blank>contained<S2SV_blank>unknown<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>number<S2SV_blank>%d" , vno ) ; goto bailout <S2SV_ModEnd> ; } ap_req . length = ( * ptr <S2SV_ModStart> "Request<S2SV_blank>was<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>AP-REQ" , sizeof ( strresult ) ) ; goto bailout <S2SV_ModEnd> ; } ap_req . data = ptr ; ptr
<S2SV_ModStart> ( ld , result ) ; if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; goto cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ; <S2SV_ModEnd> cleanup : ldap_msgfree ( result ) ; if (
<S2SV_ModStart> choice == choice_pa_pk_as_rep_dhInfo ) ) { if ( rep != NULL && rep <S2SV_ModStart> dh_Info . kdfID ) { secret . data = ( char * )
<S2SV_ModStart> j ++ ; last = i + 1 ; if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 <S2SV_ModEnd> ] . key_data_kvno ; } } ret [ num_versions
<S2SV_ModStart> mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
<S2SV_ModStart> = NULL , * principal_dn = NULL ; char <S2SV_ModEnd> * strval [ 10 ] = { NULL } <S2SV_ModStart> = NULL ; krb5_boolean create_standalone = FALSE ; krb5_boolean <S2SV_ModEnd> establish_links = FALSE ; char * standalone_principal_dn = NULL <S2SV_ModStart> if ( xargs . dn_from_kbd == TRUE ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , ntrees ) ; if ( st ) <S2SV_ModEnd> goto cleanup ; } if ( xargs . linkdn
<S2SV_ModStart> && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
<S2SV_ModStart> krb5_data d , plaintext ; char * config ; <S2SV_ModEnd> armor_key = cb -> fast_armor ( context , rock <S2SV_ModStart> arg = arg ; rs -> respond = respond ; rs -> enc_tkt_reply = enc_tkt_reply
<S2SV_ModStart> ) { ( * respond ) ( arg , EINVAL <S2SV_ModEnd> , NULL , NULL , NULL ) ; return <S2SV_ModStart> ) { ( * respond ) ( arg , EINVAL <S2SV_ModEnd> , NULL , NULL , NULL ) ; return
<S2SV_ModStart> ) { * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> ( header -> buffer . length < token_wrapper_len + 22 <S2SV_ModEnd> ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN
<S2SV_ModStart> = ENOMEM ; } if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( ! retval && ( component = va_arg
<S2SV_ModStart> * tokflag ) { OM_uint32 tmpmin ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context ( & tmpmin , & sc ->
<S2SV_ModStart> pkid_len ) ; if ( is == NULL ) return retval <S2SV_ModEnd> ; status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) <S2SV_ModStart> valid_kdcPkId = 1 ; } retval = 0 ; <S2SV_ModEnd> X509_NAME_free ( is -> issuer ) ; ASN1_INTEGER_free (
<S2SV_ModStart> upn_sans = NULL ; size_t i , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) ) ; if ( md == <S2SV_ModStart> if ( md == NULL ) goto cleanup ; ret = rfc2253_name ( X509_get_subject_name ( cert ) , & md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name ( X509_get_issuer_name ( cert ) , & md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx
<S2SV_ModStart> 1 ; egress : if ( errcode != 0 && state -> status == NULL ) state -> status = "UNKNOWN_REASON" <S2SV_ModEnd> ; au_state -> status = state -> status ;
<S2SV_ModStart> enc_part . ciphertext . data ) ; cleanup : if ( status == NULL ) status = "UNKNOWN_REASON" <S2SV_ModEnd> ; if ( reply_key ) krb5_free_keyblock ( kdc_context ,
<S2SV_ModStart> , & for_user ) ; if ( code ) { * status = "DECODE_PA_FOR_USER" ; return code ; } <S2SV_ModEnd> code = verify_for_user_checksum ( kdc_context , tgs_session , for_user
<S2SV_ModStart> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { * status = "INVALID_S4U2PROXY_OPTIONS" ; <S2SV_ModStart> , server -> princ , server_princ ) ) { * status = "EVIDENCE_TICKET_MISMATCH" ;
<S2SV_ModStart> req_data , s4u_x509_user ) ; if ( code ) { * status = "DECODE_PA_S4U_X509_USER" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey
<S2SV_ModStart> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { int len ; char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ; if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { if ( ( len = sys -> read ( fh , & buf [ 0 ] , 9 ) ) < 2 ) return MSPACK_ERR_READ ; for ( i = 0 ; i < len ; i ++ ) if ( ! ( * fn ++ = buf [ i ] ) ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( i + 1 - len ) , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; fn -- ; } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; if ( ( len = sys -> read ( fh , & buf [ 0 ] , 4 ) ) < 2 ) return MSPACK_ERR_READ ; for ( i = 0 ; i < len ; i ++ ) if ( ! ( * fn ++ = buf [ i ] ) ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT <S2SV_ModEnd> ; if ( sys -> seek ( fh , <S2SV_ModStart> ; if ( sys -> seek ( fh , ( off_t ) ( i + 1 - len ) , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModEnd> ; } * fn = '\\0' ; } if
<S2SV_ModStart> case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ; if ( bits_left == 0 ) ENSURE_BITS ( 16 ) <S2SV_ModEnd> ; bits_left = 0 ; bit_buffer = 0 ;
<S2SV_ModStart> [ 1 ] == ':' ) { if ( name_len == 40 && memcmp ( name , content_name , 40 ) == 0 ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == 0 ) { chm -> sec1 . <S2SV_ModStart> ) == 0 ) { chm -> sec1 . control = fi ; } else if ( name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == 0 ) { chm -> sec1 . <S2SV_ModStart> ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == 0 ) { chm -> sec1 . <S2SV_ModStart> ) == 0 ) { chm -> sec1 . rtable = fi ; <S2SV_ModEnd> } fi -> next = chm -> sysfiles ;
<S2SV_ModStart> chm -> index_root != 0xFFFFFFFF && chm -> index_root >= <S2SV_ModEnd> chm -> num_chunks ) { D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" <S2SV_ModStart> ( end - p ) ) goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;
<S2SV_ModStart> ; unsigned char * buf ; if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks ) return NULL ; if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> char * create_output_name ( char * fname ) { char * out , * p ; if ( ( out = malloc ( strlen ( fname ) + 1 ) ) ) { while ( * fname == '/' || * fname == '\\\\' ) fname ++ ; strcpy ( out , ( * fname ) ? fname : "x" ) ; for ( p = out ; * p ; p ++ ) { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' ) ) { p [ 0 ] = p [ 1 ] = 'x' ; } } } return out <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( end - p ) ) goto chunk_end ; <S2SV_ModEnd> name = p ; p += name_len ; READ_ENCINT <S2SV_ModStart> READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
<S2SV_ModStart> . Ppmd7_Construct ( & rar -> ppmd7_context ) ; if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; }
<S2SV_ModStart> a = ( struct archive_write * ) _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , "archive_write_data" ) ; if ( s > max_write ) s = max_write
<S2SV_ModStart> * p ; size_t l ; int r ; size_t <S2SV_ModEnd> ffmax , parent_len ; static const struct archive_rb_tree_ops rb_ops <S2SV_ModStart> , idr , isoent -> children . cnt , ( int ) <S2SV_ModStart> noff , weight ; size_t lt ; if ( <S2SV_ModEnd> ( l = np -> file -> basename_utf16 . <S2SV_ModStart> id_len = ( int ) l ; if ( <S2SV_ModEnd> np -> file -> basename_utf16 . length > ffmax <S2SV_ModStart> -> file -> basename . length ; if ( parent_len > 240 || np -> mb_len > 240 || <S2SV_ModStart> ; return ( ARCHIVE_FATAL ) ; } if ( <S2SV_ModEnd> l == ffmax ) noff = ext_off - 6 <S2SV_ModStart> noff = ext_off - 6 ; else if ( <S2SV_ModEnd> l == ffmax - 2 ) noff = ext_off <S2SV_ModStart> noff = ext_off - 4 ; else if ( <S2SV_ModEnd> l == ffmax - 4 ) noff = ext_off
<S2SV_ModStart> iso9660 -> joliet ) ; skipsize = LOGICAL_BLOCK_SIZE * ( int64_t ) <S2SV_ModStart> iso9660 -> joliet ) ; skipsize = LOGICAL_BLOCK_SIZE * ( int64_t )
<S2SV_ModStart> filename_size ++ ] = '\\0' ; filename [ filename_size <S2SV_ModEnd> ] = '\\0' ; if ( rar -> sconv_utf16be
<S2SV_ModStart> -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
<S2SV_ModStart> # endif if ( * src == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Path<S2SV_blank>is<S2SV_blank>absolute" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ; ; ) { if ( src
<S2SV_ModStart> st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; assert ( 0 == unlink ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( "Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here." ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ;
<S2SV_ModStart> { int number_bidders , i , bid , best_bid , n <S2SV_ModStart> ; ssize_t avail ; int r ; for ( n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> ) { number_bidders = sizeof ( a -> bidders <S2SV_ModStart> ) ; return ( ARCHIVE_FATAL ) ; } } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding" ) ; return ( ARCHIVE_FATAL ) ;
<S2SV_ModStart> ; switch ( type ) { case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> return ( - 1 ) ; break ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> return ( - 1 ) ; break ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL ) return ( - 1 ) ; <S2SV_ModStart> - 1 ) ; allAreDefined = * p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
<S2SV_ModStart> -> compsize -= extdsize - 2 ; if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> ARCHIVE_ERRNO_FILE_FORMAT , "Missing<S2SV_blank>number" ) ; return ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Too<S2SV_blank>many<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> unsigned long ) mtree_atol ( & p ) ; <S2SV_ModEnd> } if ( argc < 2 ) { archive_set_error
<S2SV_ModStart> zip -> stream ) ; # endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {
<S2SV_ModStart> ( rsrc -> compression ) { case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , ( intmax_t ) rsrc -> compressed_size ) ; return ( ARCHIVE_WARN ) ; } <S2SV_ModStart> ( rsrc -> compression ) { case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;
<S2SV_ModStart> ( i > ( sizeof ( outbuff ) - 128 <S2SV_ModEnd> ) ) { outbuff [ i ] = '\\0'
<S2SV_ModStart> . numUnpackStreams ) return ( - 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
<S2SV_ModStart> = len ; len = get_line_size ( * b + len , * avail - len <S2SV_ModEnd> , nl ) ; if ( len >= 0
<S2SV_ModStart> ( archive_entry_filetype ( entry ) == AE_IFLNK ) { if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , "Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte" ) ; return ( ARCHIVE_FATAL ) ; }
<S2SV_ModStart> uint32_t prefix , int length ) { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , "Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n" ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> probe_packet -> buf [ i ] ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue ; if ( temp_buffer == VOP_START_CODE ) <S2SV_ModStart> VISUAL_OBJECT_START_CODE ) VISO ++ ; else if ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> < 0x120 ) VO ++ ; else if ( temp_buffer >= 0x120 &&
<S2SV_ModStart> ; uint32_t vsize ; uint16_t asize ; uint16_t auxsize ; int ret <S2SV_ModStart> = & nsv -> ahead [ NSV_ST_VIDEO ] ; if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret <S2SV_ModEnd> ; pkt -> stream_index = st [ NSV_ST_VIDEO ] <S2SV_ModStart> bps , channels , samplerate ) ; } } if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret <S2SV_ModEnd> ; pkt -> stream_index = st [ NSV_ST_AUDIO ]
<S2SV_ModStart> ; if ( * ip_as_string == '[' ) { size_t <S2SV_ModEnd> len ; if ( ! ( cp = strchr <S2SV_ModStart> ) { return - 1 ; } len = <S2SV_ModEnd> ( cp - ( ip_as_string + 1 ) ) <S2SV_ModStart> + 1 ) ) ; if ( len > <S2SV_ModEnd> sizeof ( buf ) - 1 ) { return
<S2SV_ModStart> for ( ; ; ) { u8 label_len ; <S2SV_ModEnd> GET8 ( label_len ) ; if ( ! label_len <S2SV_ModStart> + label_len >= end ) return - 1 ; if ( j + label_len > length ) return - 1 ;
<S2SV_ModStart> const size_t base_len = strlen ( base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name [ base_len - 1 ] == <S2SV_ModStart> 1 ] == '.' ? 0 : 1 ; <S2SV_ModEnd> for ( dom = state -> head ; dom
<S2SV_ModStart> 0 ; int bitmap_caret = 0 ; int i <S2SV_ModEnd> = 0 ; uint8_t encoded_pixels ; if ( overflow2 <S2SV_ModStart> encoded_pixels = ( ( decompression_buffer [ buffer_caret ] & ! TGA_RLE_FLAG <S2SV_ModEnd> ) + 1 ) ; buffer_caret ++ ; if <S2SV_ModStart> + 1 ) ; buffer_caret ++ ; if ( ( bitmap_caret + ( encoded_pixels * pixel_block_size ) ) >= image_block_size <S2SV_ModEnd> ) { gdFree ( decompression_buffer ) ; gdFree ( <S2SV_ModStart> ; i < encoded_pixels ; i ++ ) { memcpy ( tga -> bitmap + bitmap_caret , decompression_buffer + buffer_caret , pixel_block_size ) ; bitmap_caret += pixel_block_size ; } buffer_caret += pixel_block_size ; } else { encoded_pixels = decompression_buffer [ buffer_caret ] + 1 ; buffer_caret ++ ; if ( ( bitmap_caret + ( encoded_pixels * pixel_block_size ) ) >= image_block_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } memcpy ( tga -> bitmap + bitmap_caret , decompression_buffer + buffer_caret , encoded_pixels * pixel_block_size ) ; bitmap_caret += ( encoded_pixels * pixel_block_size ) ; buffer_caret += ( encoded_pixels * pixel_block_size ) ; <S2SV_ModEnd> } } gdFree ( decompression_buffer ) ; gdFree (
<S2SV_ModStart> width , tga -> height ) ; # endif if ( ! ( ( tga -> bits == TGA_BPP_24 && tga -> alphabits == 0 ) || ( tga -> bits == TGA_BPP_32 && tga -> alphabits == 8 ) ) ) { gd_error_ex ( GD_WARNING , "gd-tga:<S2SV_blank>%u<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>alpha<S2SV_blank>bits<S2SV_blank>not<S2SV_blank>supported\\n" , tga -> bits , tga -> alphabits ) ; return - 1 <S2SV_ModEnd> ; } tga -> ident = NULL ; if
<S2SV_ModStart> 127 ) + 1 ) ; buffer_caret ++ ; if ( encoded_pixels != 0 ) { if ( ! ( ( buffer_caret + ( encoded_pixels * pixel_block_size ) ) < image_block_size ) ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } <S2SV_ModStart> decompression_buffer [ buffer_caret + j ] ; } } } <S2SV_ModStart> [ buffer_caret ] + 1 ; buffer_caret ++ ; if ( encoded_pixels != 0 ) { if ( ! ( ( buffer_caret + ( encoded_pixels * pixel_block_size ) ) < image_block_size ) ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } <S2SV_ModStart> ; } buffer_caret += pixel_block_size ; } } } }
<S2SV_ModStart> ; } if ( src != tmp_im ) { gdImageDestroy <S2SV_ModEnd> ( tmp_im ) ; } return dst ; }
<S2SV_ModStart> ) ctx ; dp = dctx -> dp ; if ( dp -> pos < 0 || dp -> pos >= dp -> realSize ) { return 0 ; } <S2SV_ModStart> return 0 ; } rlen = remain ; } if ( dp -> pos + rlen > dp -> realSize ) { rlen = dp -> realSize - dp -> pos ; }
<S2SV_ModStart> * format , ... ) { char buf [ 1024 <S2SV_ModEnd> ] ; int len ; va_list args ; va_start
<S2SV_ModStart> ) ; double dTotalWeight = 0.0 ; int iSrc <S2SV_ModEnd> ; if ( iRight - iLeft + 1 > <S2SV_ModStart> ; } else { iRight -- ; } } res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . <S2SV_ModEnd> Weights [ iSrc - iLeft ] = scale_f_d *
<S2SV_ModStart> = len ; } else { if ( remain <= <S2SV_ModEnd> 0 ) { return 0 ; } rlen =
<S2SV_ModStart> while ( bitmap_caret < image_block_size ) { if ( buffer_caret + pixel_block_size > rle_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int main ( ) { check_file ( "heap_overflow_1.tga" ) ; check_file ( "heap_overflow_2.tga" <S2SV_ModEnd> ) ; return gdNumFailures ( ) ; } <S2SV_null>
<S2SV_ModStart> int u = 0 ; LineContribType * res ; size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u = 0 ; u < line_length ; u ++ ) <S2SV_ModEnd> { res -> ContribRow [ u ] . Weights <S2SV_ModStart> . Weights = ( double * ) gdMalloc ( weights_size ) ; if ( <S2SV_ModEnd> res -> ContribRow [ u ] . Weights == <S2SV_ModStart> Weights == NULL ) { unsigned int i ; for ( i = 0 ; i < <S2SV_ModEnd> u ; i ++ ) { gdFree ( res
<S2SV_ModStart> + ( encoded_pixels * pixel_block_size ) ) > image_block_size || buffer_caret + pixel_block_size > rle_size <S2SV_ModStart> + ( encoded_pixels * pixel_block_size ) ) > image_block_size || buffer_caret + ( encoded_pixels * pixel_block_size ) > rle_size
<S2SV_ModStart> = NULL ; pkt -> type = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; line += 3 ; len -= 3 ; if ( ! ( ptr = memchr ( line , '<S2SV_blank>' , len <S2SV_ModEnd> ) ) ) goto out_err ; len = ptr <S2SV_ModStart> pkt -> ref [ len ] = '\\0' ; if ( len < 1 ) goto out_err ; line = ptr + 1 ; len -= 1 ; if ( ! ( ptr = memchr ( line , '\\n' , len <S2SV_ModEnd> ) ) ) goto out_err ; len = ptr
<S2SV_ModStart> PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ACK" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "NAK" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , "ERR<S2SV_blank>" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ok" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ng" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "unpack" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line <S2SV_ModEnd> + len ; return ret ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> line_end - line ) ; line = line_end ; <S2SV_ModEnd> error = add_push_report_pkt ( push , pkt ) ;
<S2SV_ModStart> ( buf , line_end ) ; error = 0 <S2SV_ModEnd> ; switch ( pkt -> type ) { case
<S2SV_ModStart> ; if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) <S2SV_ModEnd> ; if ( cmd & 0x10 ) len =
<S2SV_ModStart> < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ACK" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "NAK" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , "ERR<S2SV_blank>" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ok" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ng" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "unpack" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line <S2SV_ModEnd> + len ; return ret ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> line_end - line ) ; line = line_end ; <S2SV_ModEnd> error = add_push_report_pkt ( push , pkt ) ;
<S2SV_ModStart> ( buf , line_end ) ; error = 0 <S2SV_ModEnd> ; switch ( pkt -> type ) { case
<S2SV_ModStart> size_t off = 0 , len = 0 ; # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ; if ( cmd & 0x04 ) ADD_DELTA ( off , 16UL ) ; if ( cmd & 0x08 ) ADD_DELTA ( off , <S2SV_ModEnd> 24UL ) ; if ( cmd & 0x10 ) <S2SV_ModStart> 24UL ) ; if ( cmd & 0x10 ) ADD_DELTA ( len , 0UL ) ; if ( cmd & 0x20 ) ADD_DELTA ( len , 8UL ) ; if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> ; if ( ! len ) len = 0x10000 <S2SV_ModStart> if ( ! len ) len = 0x10000 ; # undef ADD_DELTA
<S2SV_ModStart> ) ) { git_cert * cert ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> < 0 ) return error ; giterr_clear ( ) <S2SV_ModEnd> ; error = t -> owner -> certificate_check_cb (
<S2SV_ModStart> ) ) { git_cert * cert ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> 0 ) return error ; giterr_clear ( ) ; error = t -> owner -> certificate_check_cb ( cert , is_valid <S2SV_ModEnd> , t -> connection_data . host , t ->
<S2SV_ModStart> { size_t off = 0 , len = 0 , end <S2SV_ModStart> len = 0x10000 ; # undef ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <S2SV_ModEnd> || res_sz < len ) goto fail ; memcpy
<S2SV_ModStart> ; addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr . sin_port = htons ( port
<S2SV_ModStart> ; saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr . sin_port = htons ( port
<S2SV_ModStart> case BPLIST_DATA : if ( * object + size < * object || * object + size <S2SV_ModStart> , size ) ; case BPLIST_STRING : if ( * object + size < * object || <S2SV_ModStart> } if ( * object + size * 2 < * object || * object + size * 2 <S2SV_ModStart> case BPLIST_ARRAY : if ( * object + size < * object || * object + size <S2SV_ModStart> case BPLIST_DICT : if ( * object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" <S2SV_ModEnd> , __func__ ) ; return NULL ; } return
<S2SV_ModStart> ) * ( size + 1 ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
<S2SV_ModStart> ; addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr . sin_port = htons ( port
<S2SV_ModStart> ; saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr . sin_port = htons ( port
<S2SV_ModStart> ; for ( k = passIC + 2 ; ( ( <S2SV_ModStart> + 2 + passInstructions [ passIC + 1 ] ) && ( kk < input -> length ) )
<S2SV_ModStart> name , size_t namelen ) { char * copy ; if ( name != NULL && namelen == 0 ) namelen = strlen ( name )
<S2SV_ModStart> -> md ) ; } reset_globals ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> md ) ; } reset_globals ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> md ) ; } reset_globals ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } reset_cur_state ( ) ; reset_globals ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } { struct ikev2_ke * ke ; <S2SV_ModEnd> char fromname [ ADDRTOT_BUF ] ; addrtot ( & <S2SV_ModStart> sender , 0 , fromname , ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( "Received<S2SV_blank>Notify(%d):<S2SV_blank>%s" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u" , fromname , md -> sender_port , ke <S2SV_ModStart> -> sender_port , ke -> isak_group ) ; return STF_FAIL +
<S2SV_ModStart> ; unsigned long outlen , loid [ 16 ] , reallen <S2SV_ModStart> out ) ; goto bail_2 ; } if ( ( err = der_length_sequence ( siginfo , 2 , & reallen ) ) != CRYPT_OK ) { XFREE ( out ) ; goto bail_2 ; } if ( ( reallen == outlen ) &&
<S2SV_ModStart> ; _exit ( 127 ) ; } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
<S2SV_ModStart> size ) { void * buf ; buf = g_malloc0 <S2SV_ModEnd> ( size ) ; if ( object ) {
<S2SV_ModStart> += 16 ; if ( ! ( buf = g_try_malloc0 <S2SV_ModEnd> ( size ) ) ) { # ifdef DEBUG
<S2SV_ModStart> ( ) ; virCheckDomainReturn ( dom , - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error
<S2SV_ModStart> if ( user_sid_size != 0 ) { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( <S2SV_ModStart> ; } if ( strings_size != 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> ; } if ( data_size != 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> libcnotify_printf ( "%s:<S2SV_blank>data:\\n" , function ) ; libcnotify_print_data ( <S2SV_ModEnd> & ( record_data [ record_data_offset ] ) , ( <S2SV_ModStart> record_data_offset ] ) , ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value." , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size ,
<S2SV_ModStart> key -> ptr , alias_len ) ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> } } if ( qs >= 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> ( s + j , s + qs , ( size_t ) qslen ) ; qs = j ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length ( b , j ) ;
<S2SV_ModStart> , ptmp , flags , __LINE__ , CONST_STR_LEN ( "%2f?" ) , CONST_STR_LEN ( "/?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f?" ) , CONST_STR_LEN ( "//?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
<S2SV_ModStart> if ( url_len < 1 ) return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }
<S2SV_ModStart> ( res_val , 2 ) ) ; if ( n2size < 1 <S2SV_ModEnd> ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ;
<S2SV_ModStart> ; } if ( field_identifier == SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < 0 ) { __post_internal_error ( & <S2SV_ModStart> ) ; } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) <S2SV_ModEnd> value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error ( & descriptor
<S2SV_ModStart> ; } if ( field_identifier == SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < 0 ) { __post_internal_error ( & <S2SV_ModStart> ) ; } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) <S2SV_ModEnd> value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error ( & descriptor
<S2SV_ModStart> ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_ModEnd> return 0 ; } } else { if (
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> ] == '/' ) { strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 <S2SV_ModEnd> ) ; } else { char szPath [ ODBC_FILENAME_MAX
<S2SV_ModStart> * oldname , char * * newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex = - 1 , ofd = - 1 , ret <S2SV_ModEnd> ; bool grab_newname = false ; ofd = lxc_preserve_ns <S2SV_ModStart> ) ; if ( ofd < 0 ) { usernic_error ( "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , getpid ( ) ) ; return fret <S2SV_ModEnd> ; } fd = lxc_preserve_ns ( pid , "net" <S2SV_ModStart> ) ; if ( fd < 0 ) { usernic_error ( "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>" "user<S2SV_blank>IDs:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setns ( fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( fd ) ; fd = - 1 <S2SV_ModStart> ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>" "the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } if ( <S2SV_ModStart> grab_newname = true ; * newnamep = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; if ( ! ifindex ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( "Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n" , ret , oldname , * newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } if ( grab_newname ) { char ifname <S2SV_ModStart> ( grab_newname ) { char ifname [ IFNAMSIZ ] ; char <S2SV_ModEnd> * namep = ifname ; if ( ! if_indextoname <S2SV_ModStart> ! if_indextoname ( ifindex , namep ) ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } * newnamep = strdup ( namep ) <S2SV_ModStart> ) ; if ( ! * newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = setns ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>" "of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( ofd ) ; return fret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> bufsz , "%s/sys/fs/cgroup" , root ) ; r = safe_mount <S2SV_ModEnd> ( "cgroup_root" , path , "tmpfs" , MS_NOSUID | <S2SV_ModStart> MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , "size=10240k,mode=755" , root
<S2SV_ModStart> ; } fclose ( pathfile ) ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> NULL ) != 0 ) { SYSERROR ( "Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"
<S2SV_ModStart> } fclose ( pathfile ) ; } ret = safe_mount ( path , destpath , "none" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ; if ( ret < 0 ) SYSERROR
<S2SV_ModStart> } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/sys/net" , "%r/proc/tty" <S2SV_ModEnd> , NULL , MS_BIND , NULL } , { <S2SV_ModStart> , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/tty" <S2SV_ModEnd> , "%r/proc/sys/net" , NULL , MS_MOVE , NULL } <S2SV_ModStart> [ i ] . flags ) ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno = errno ; if ( r
<S2SV_ModStart> "Proceeding<S2SV_blank>without<S2SV_blank>autodev<S2SV_blank>setup" ) ; return 0 ; } if ( safe_mount <S2SV_ModEnd> ( "none" , path , "tmpfs" , 0 , <S2SV_ModStart> "none" , path , "tmpfs" , 0 , "size=100000,mode=755" , rootfs -> path ? rootfs -> mount : NULL
<S2SV_ModStart> mountflags , const char * data , int optional , const char * rootfs <S2SV_ModStart> HAVE_STATVFS struct statvfs sb ; # endif if ( safe_mount <S2SV_ModEnd> ( fsname , target , fstype , mountflags & <S2SV_ModStart> , fstype , mountflags & ~ MS_REMOUNT , data , rootfs <S2SV_ModStart> , fstype , mountflags | MS_REMOUNT , data ) < 0
<S2SV_ModStart> 1 ; } return mount_entry_on_generic ( mntent , path , rootfs -> mount
<S2SV_ModStart> struct mntent * mntent , const char * path , const char * rootfs <S2SV_ModStart> mntent -> mnt_type , mntflags , mntdata , optional , rootfs
<S2SV_ModStart> 1 ; } return mount_entry_on_generic ( mntent , path , rootfs
<S2SV_ModStart> { return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL
<S2SV_ModStart> ) ; return - 1 ; } if ( safe_mount ( console -> name , path , "none" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , console ->
<S2SV_ModStart> "no<S2SV_blank>console" ) ; return 0 ; } if ( safe_mount ( console -> name , lxcpath , "none" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , console -> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , "%s/console" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( <S2SV_ModEnd> "lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } ret
<S2SV_ModStart> data ; int ipc_socket = payload -> ipc_socket ; int procfd = payload -> procfd ; <S2SV_ModStart> ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ; <S2SV_ModEnd> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 <S2SV_ModStart> -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) <S2SV_ModEnd> < 0 ) { rexit ( - 1 ) <S2SV_ModStart> { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd" ) ; } } } close ( procfd ) ;
<S2SV_ModStart> * new_cwd ; int ipc_sockets [ 2 ] ; int procfd ; <S2SV_ModStart> ) ; rexit ( - 1 ) ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> . exec_function = exec_function , . exec_payload = exec_payload , . procfd = procfd
<S2SV_ModStart> ; char * rundir ; len = strlen ( "/lxc/lock/" <S2SV_ModEnd> ) + strlen ( n ) + strlen ( <S2SV_ModStart> } ret = snprintf ( dest , len , "%s/lxc/lock/%s" <S2SV_ModEnd> , rundir , p ) ; if ( ret <S2SV_ModStart> ) ; if ( ret < 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , "%s/lxc/lock/%s/.%s" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> ) ; if ( ret < 0 || ret <S2SV_ModStart> >= len ) { free ( dest ) ; <S2SV_ModEnd> return NULL ; } return dest ; } <S2SV_null>
<S2SV_ModStart> data ; int ipc_socket = payload -> ipc_socket ; <S2SV_ModEnd> lxc_attach_options_t * options = payload -> options ; struct <S2SV_ModStart> int expected ; long flags ; int fd ; int lsm_labelfd ; <S2SV_ModStart> if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> != sizeof ( status ) ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>" "that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> if ( ( init_ctx -> container && init_ctx -> <S2SV_ModStart> ) { SYSERROR ( "PR_SET_NO_NEW_PRIVS<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set.<S2SV_blank>" "Process<S2SV_blank>can<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>gainable<S2SV_blank>" "privileges." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ; } INFO ( "PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>" "gainable<S2SV_blank>privileges." ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> && init_ctx -> lsm_label ) { int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> ? 1 : 0 ; if ( lsm_set_label_at ( lsm_labelfd <S2SV_ModEnd> , on_exec , init_ctx -> lsm_label ) < 0 <S2SV_ModStart> , init_ctx -> lsm_label ) < 0 ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> } if ( init_ctx -> container && init_ctx -> <S2SV_ModStart> 0 ) ) { ERROR ( "Loading<S2SV_blank>seccomp<S2SV_blank>policy" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> lxc_proc_put_context_info ( init_ctx ) ; if ( options -> <S2SV_ModStart> < 0 ) SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd" ) ; } <S2SV_ModEnd> rexit ( payload -> exec_function ( payload -> exec_payload
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec , char * lsm_label ) { <S2SV_ModStart> int on_exec , char * lsm_label ) { int fret = - 1 <S2SV_ModEnd> ; const char * name ; char * command <S2SV_ModStart> strcmp ( name , "nop" ) == 0 ) return 0 <S2SV_ModEnd> ; if ( strcmp ( name , "none" ) <S2SV_ModStart> strcmp ( name , "none" ) == 0 ) return 0 <S2SV_ModEnd> ; if ( strcmp ( name , "AppArmor" ) <S2SV_ModStart> == 0 ) on_exec = 0 ; if ( strcmp ( name , "AppArmor" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( "changeprofile<S2SV_blank>" ) + 1 ) ; if ( ! command ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; goto out ; } size = sprintf ( command , "changeprofile<S2SV_blank>%s" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; goto out ; } if ( write ( lsm_labelfd , command , size + 1 ) < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s." , command ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , command ) ; } else if ( strcmp ( name , "SELinux" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label" ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , lsm_label ) ; } else { ERROR ( "Unable<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>label<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>LSM:<S2SV_blank>%s" , name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free ( command ) ; if ( <S2SV_ModStart> out : free ( command ) ; if ( lsm_labelfd != - 1 ) close ( lsm_labelfd ) ; return fret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_ModEnd> signed long personality ; if ( ! options ) <S2SV_ModStart> - 1 ; } if ( pid ) { int procfd = - 1 ; <S2SV_ModStart> lxcpath , pid ) ) goto cleanup_error ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc." ) ; goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) <S2SV_ModEnd> ) ; if ( ret <= 0 ) { <S2SV_ModStart> ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } <S2SV_ModEnd> if ( options -> stdin_fd == 0 ) { <S2SV_ModStart> { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>" "from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" <S2SV_ModEnd> ) ; goto cleanup_error ; } status = 2 <S2SV_ModStart> if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>" "initialization<S2SV_blank>(2):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModEnd> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) <S2SV_ModStart> attached_process = attached_pid ; return 0 ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> ( ) ) options -> namespaces |= CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = lxc_attach_to_ns ( init_pid , options -> namespaces <S2SV_ModStart> exec_function = exec_function , . exec_payload = exec_payload , <S2SV_ModEnd> } ; pid = lxc_clone ( attach_child_main , &
<S2SV_ModStart> ) r = do_write_pids ( fc -> pid , fc -> uid ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool do_write_pids ( pid_t tpid , uid_t tuid , <S2SV_ModStart> if ( v == '0' ) { if ( ! may_move_pid ( tpid , tuid , cred . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , "%d" , ( int ) cred . pid ) <S2SV_ModEnd> < 0 ) fail = true ; } }
<S2SV_ModStart> * cg , char * * nextcg ) { bool answer = false ; char * c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp ; if ( ! c2 ) return false <S2SV_ModEnd> ; prune_init_slice ( c2 ) ; linecmp = * <S2SV_ModStart> ) != 0 ) { if ( nextcg ) { <S2SV_ModStart> nextcg = get_next_cgroup_dir ( linecmp , cg ) ; } goto out ; } answer = true ; out : free ( c2 <S2SV_ModEnd> ) ; return answer ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> path1 , path2 ) ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> path1 , * cgdir = NULL , * controller , * next = NULL <S2SV_ModStart> ; else path1 = cgdir ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT ; goto out ; } if ( ! <S2SV_ModStart> ) ; out : free ( cgdir ) ; free ( next ) ;
<S2SV_ModStart> } free_key ( k ) ; if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> cgroup = "/" ; } } if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( fc , controller , cgroup , <S2SV_ModStart> controller , cgroup , NULL , O_RDONLY ) ) <S2SV_ModEnd> return - EACCES ; } dir_info = malloc (
<S2SV_ModStart> NULL , * cgdir = NULL , * controller , * next = NULL <S2SV_ModStart> ret = - EINVAL ; goto out ; } <S2SV_ModEnd> if ( ! caller_is_in_ancestor ( fc -> pid , <S2SV_ModStart> ( fc -> pid , controller , cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , <S2SV_ModStart> 0 ; out : free ( cgdir ) ; free ( next ) ;
<S2SV_ModStart> { if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> if ( state -> ptr == tmp ) { goto softfail <S2SV_ModEnd> ; } case 'A' : case 'B' : case <S2SV_ModStart> end , tmp , 1 ) ) ) { goto softfail <S2SV_ModEnd> ; } state -> ptr += mb - 1 <S2SV_ModStart> state -> ptr != state -> end ) ; softfail : state -> offset = 0 ;
<S2SV_ModStart> TSRMLS_DC ) { size_t maxlen = 3 * len + 8
<S2SV_ModStart> ! timestring || ! timefield ) return MS_FALSE ; if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , "Invalid<S2SV_blank>time<S2SV_blank>filter." , "msPostGISLayerSetTimeFilter()" ) ; return MS_FALSE ; }
<S2SV_ModStart> tmpyend ; jpc_dec_cp_t * cp ; jpc_tsfb_band_t bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ; jpc_pchg_t * pchg ; int pchgno ;
<S2SV_ModStart> n ) { long v ; int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> v = 0 ; while ( -- n >=
<S2SV_ModStart> n , long v ) { int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( ! ( v & ( ~ JAS_ONES
<S2SV_ModStart> { fprintf ( out , "expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n" , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i <S2SV_ModStart> qcd -> compparms . stepsizes [ i ] ) ) , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i <S2SV_ModStart> -> compparms . stepsizes [ i ] ) ) )
<S2SV_ModStart> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcwidthexpn + pi -> picomp <S2SV_ModStart> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcheightexpn + pi -> picomp <S2SV_ModStart> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcwidthexpn + pi -> picomp <S2SV_ModStart> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcheightexpn + pi -> picomp
<S2SV_ModStart> bool warn ; uint_fast32_t mask ; if ( roishift < 0 ) { jas_eprintf ( "warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>" "(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> else { mag <<= bgshift ; mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps ) - 1 ; if ( mag
<S2SV_ModStart> ) { return ( tsfb -> numlvls > 0 && jas_seq2d_size ( a )
<S2SV_ModStart> ; numcolors = 1 << hdr -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> actualnumcolors = hdr -> maplength / 3 ; for
<S2SV_ModStart> data [ 3 ] ; cmap = 0 ; assert ( jas_image_numcmpts ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i ] = jas_matrix_create ( 1 , <S2SV_ModStart> jas_matrix_create ( 1 , jas_image_width ( image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = RAS_ROWSIZE ( hdr ) - ( <S2SV_ModStart> jas_stream_getc ( in ) ) == EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } return - 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * data [ 3 ] ; int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < numcmpts ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i ] = jas_matrix_create ( jas_image_height ( <S2SV_ModStart> ( image ) , jas_image_width ( image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = RAS_ROWSIZE ( hdr ) ; pad <S2SV_ModStart> 1 , data [ i ] ) ) { goto error <S2SV_ModEnd> ; } } z = 0 ; nz = <S2SV_ModStart> ( out , c ) == EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } return - 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , int bufsize ) { unsigned char * buf <S2SV_ModEnd> ; assert ( bufsize >= 0 ) ; if <S2SV_ModStart> bufsize , sizeof ( unsigned char ) ) ) && bufsize
<S2SV_ModStart> register int n ; register int m ; int hstartrow <S2SV_ModEnd> ; if ( bufsize > QMFB_SPLITBUFSIZE ) { if <S2SV_ModStart> } } if ( numrows >= 2 ) { hstartrow <S2SV_ModEnd> = ( numrows + 1 - parity ) >> <S2SV_ModStart> parity ) >> 1 ; m = numrows - hstartrow <S2SV_ModEnd> ; n = m ; dstptr = buf ; <S2SV_ModStart> << 1 ; } dstptr = & a [ hstartrow <S2SV_ModEnd> * stride ] ; srcptr = buf ; n
<S2SV_ModStart> ; register int i ; int m ; int hstartrow <S2SV_ModEnd> ; if ( bufsize > QMFB_SPLITBUFSIZE ) { if <S2SV_ModStart> QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE <S2SV_ModEnd> , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_ModStart> } } if ( numrows >= 2 ) { hstartrow <S2SV_ModEnd> = ( numrows + 1 - parity ) >> <S2SV_ModStart> parity ) >> 1 ; m = numrows - hstartrow <S2SV_ModEnd> ; n = m ; dstptr = buf ; <S2SV_ModStart> << 1 ; } dstptr = & a [ hstartrow <S2SV_ModEnd> * stride ] ; srcptr = buf ; n
<S2SV_ModStart> QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof ( jpc_fix_t ) ) ) ) {
<S2SV_ModStart> ) { jas_matrix_t * matrix ; int i ; if ( numrows < 0 || numcols < 0 ) { return 0 ; }
<S2SV_ModStart> * cmptparm ; uint_fast16_t numcmpts ; long n ; image = 0 ; info = 0 ; <S2SV_ModStart> hdr ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , <S2SV_ModStart> ) ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; goto error ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>" "mincolors<S2SV_blank>%ld\\n" , JAS_CAST ( long , info -> len ) , JAS_CAST ( long , info -> width ) , JAS_CAST ( long , info -> height ) , JAS_CAST ( long , info -> numplanes ) , JAS_CAST ( long , info -> depth ) , JAS_CAST ( long , info -> enctype ) , JAS_CAST ( long , info -> siz ) , JAS_CAST ( long , info -> hres ) , JAS_CAST ( long , info -> vres ) , JAS_CAST ( long , info -> numcolors ) , JAS_CAST ( long , info -> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; goto error ; } <S2SV_ModEnd> if ( ! bmp_issupported ( & hdr , info <S2SV_ModStart> info ) ) { jas_eprintf ( "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; goto error <S2SV_ModEnd> ; } if ( ( n = hdr . <S2SV_ModStart> < 0 ) { jas_eprintf ( "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; goto error <S2SV_ModEnd> ; } if ( n > 0 ) { <S2SV_ModStart> ( bmp_gobble ( in , n ) ) { goto error <S2SV_ModEnd> ; } } numcmpts = bmp_numcmpts ( info ) <S2SV_ModStart> numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { goto error <S2SV_ModEnd> ; } if ( numcmpts == 3 ) { <S2SV_ModStart> ( in , info , image ) ) { goto error ; } bmp_info_destroy ( info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { jas_image_destroy ( image ) ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 <S2SV_ModEnd> ( 0 , size ) : jas_stream_tmpfile ( )
<S2SV_ModStart> stream , int n ) { int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble" ) ; }
<S2SV_ModStart> ( char * buf , int bufsize ) { char * new_buf ; size_t new_bufsize <S2SV_ModEnd> ; JAS_DBGLOG ( 100 , ( "jas_stream_memopen(%p,<S2SV_blank>%d)\\n" , buf <S2SV_ModStart> , buf , bufsize ) ) ; if ( bufsize < 0 ) { jas_deprecated ( "negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( "Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n" ) ; jas_deprecated ( "A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>" "jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n" ) ; } if ( bufsize <= 0 ) { new_bufsize = 0 ; new_buf = 0 ; } else { new_bufsize = bufsize ; new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> n , int c ) { int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad" ) ; }
<S2SV_ModStart> n ; int c ; char * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read" ) ; }
<S2SV_ModStart> { int n ; const char * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write" ) ; }
<S2SV_ModStart> , char * buf , int cnt ) { ssize_t <S2SV_ModEnd> n ; assert ( cnt >= 0 ) ;
<S2SV_ModStart> <S2SV_null> static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) { unsigned char * buf ; JAS_DBGLOG ( 100 , ( "mem_resize(%p,<S2SV_blank>%zu)\\n" , m , bufsize ) ) ; if ( ! bufsize ) { jas_eprintf ( "mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n" "This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n" ) ; } <S2SV_ModEnd> if ( ! ( buf = jas_realloc2 ( m
<S2SV_ModStart> * m = ( jas_stream_memobj_t * ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG ( 100 , ( "mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\n" ,
<S2SV_ModStart> , char * buf , int cnt ) { size_t <S2SV_ModEnd> n ; int ret ; jas_stream_memobj_t * m = <S2SV_ModStart> * m = ( jas_stream_memobj_t * ) obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; assert ( buf ) ; assert ( <S2SV_ModStart> bufsize_ ; while ( newbufsize < newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { JAS_DBGLOG ( 100 , ( "new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n" ) ) ; return - 1 ; } } JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <S2SV_ModEnd> if ( m -> pos_ > m -> len_
<S2SV_ModStart> int numcmpts ; int verbose ; char * fmtname ; int debug <S2SV_ModStart> ; infile = 0 ; verbose = 0 ; debug = 0 ; <S2SV_ModStart> ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; <S2SV_ModStart> instream , fmtid , 0 ) ) ) { jas_stream_close ( instream ) ;
<S2SV_ModStart> jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; return 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; return 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>" "mincolors<S2SV_blank>%d\\n" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;
<S2SV_ModStart> { return - 1 ; } v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 ) ; if ( -- n <=
<S2SV_ModStart> void * result ; JAS_DBGLOG ( 101 , ( "jas_malloc(%zu)\\n" <S2SV_ModEnd> , size ) ) ; result = malloc (
<S2SV_ModStart> void * result ; JAS_DBGLOG ( 101 , ( "jas_realloc(%x,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , ptr , size ) ) ; result =
<S2SV_ModStart> ) { jas_matrix_t * matrix ; int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> numrows < 0 || numcols < 0 ) { goto error <S2SV_ModEnd> ; } if ( ! ( matrix = jas_malloc <S2SV_ModStart> ( sizeof ( jas_matrix_t ) ) ) ) { goto error <S2SV_ModEnd> ; } matrix -> flags_ = 0 ; matrix <S2SV_ModStart> -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( matrix -> maxrows_ > 0 ) <S2SV_ModStart> sizeof ( jas_seqent_t * ) ) ) ) { goto error <S2SV_ModEnd> ; } } if ( matrix -> datasize_ > <S2SV_ModStart> , sizeof ( jas_seqent_t ) ) ) ) { goto error <S2SV_ModEnd> ; } } for ( i = 0 ; <S2SV_ModStart> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
<S2SV_ModStart> { pirlvl = pi -> picomp -> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) ) ) || ! ( pi <S2SV_ModStart> && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) ) ) || ! ( pi
<S2SV_ModStart> numrlvls ; ++ rlvlno , ++ pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 <S2SV_ModEnd> ) ) ; ystep = picomp -> vsamp * <S2SV_ModStart> ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcheightexpn + picomp -> numrlvls <S2SV_ModStart> && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) ) ) || ! ( pi <S2SV_ModStart> && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) ) ) || ! ( pi
<S2SV_ModStart> numrlvls ; ++ rlvlno , ++ pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls <S2SV_ModEnd> - rlvlno - 1 ) ) ; ystep = <S2SV_ModStart> ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl -> prcheightexpn + picomp -> numrlvls <S2SV_ModStart> && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) ) ) || ! ( pi <S2SV_ModStart> ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) ) ) && ( ( pi <S2SV_ModStart> && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) ) ) || ! ( pi <S2SV_ModStart> ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) ) ) ) { prchind =
<S2SV_ModStart> ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n" ) ; return - 1 ; } if (
<S2SV_ModStart> -> type ) ; box -> info = boxinfo <S2SV_ModEnd> ; box -> len = len ; JAS_DBGLOG ( <S2SV_ModStart> , in , box -> datalen ) ) { <S2SV_ModEnd> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } <S2SV_ModStart> ; goto error ; } jas_stream_rewind ( tmpstream ) ; box -> ops = & boxinfo -> ops
<S2SV_ModStart> * fmtname ; int debug ; size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> ) ; } cmdname = argv [ 0 ] ; max_samples = 64 * JAS_MEBI <S2SV_ModStart> OPT_INFILE : infile = jas_optarg ; break ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> { fprintf ( stderr , "unknown<S2SV_blank>image<S2SV_blank>format\\n" ) ; } snprintf ( optstr , sizeof ( optstr ) , "max_samples=%-zu" , max_samples ) ; <S2SV_ModStart> ( image = jas_image_decode ( instream , fmtid , optstr <S2SV_ModEnd> ) ) ) { jas_stream_close ( instream ) ; <S2SV_ModStart> jas_stream_close ( instream ) ; if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( "format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> height = 0 ; depth = 0 ; } printf ( "%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n" , fmtname <S2SV_ModEnd> , numcmpts , width , height , depth , <S2SV_ModStart> , numcmpts , width , height , depth , JAS_CAST ( long , jas_image_rawsize ( image ) <S2SV_ModEnd> ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts
<S2SV_ModStart> len ) { size_t i ; size_t j ; jas_uchar <S2SV_ModEnd> * dp ; dp = data ; for (
<S2SV_ModStart> jas_stream_t * in , jas_iccsint32_t * val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if ( jas_iccgetuint ( in , 4 <S2SV_ModStart> tmp & 0x80000000 ) ? ( - JAS_CAST ( jas_longlong <S2SV_ModEnd> , ( ( ( ~ tmp ) & 0x7fffffff <S2SV_ModStart> ) + 1 ) ) ) : JAS_CAST ( jas_longlong <S2SV_ModEnd> , tmp ) ; return 0 ; } <S2SV_null>
<S2SV_ModStart> jas_stream_t * in , jas_iccuint16_t * val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if ( jas_iccgetuint ( in , 2
<S2SV_ModStart> jas_stream_t * in , jas_iccuint32_t * val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if ( jas_iccgetuint ( in , 4
<S2SV_ModStart> jas_stream_t * in , jas_iccuint64_t * val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if ( jas_iccgetuint ( in , 8
<S2SV_ModStart> jas_iccgetuint ( jas_stream_t * in , int n , jas_ulonglong <S2SV_ModEnd> * val ) { int i ; int c <S2SV_ModStart> val ) { int i ; int c ; jas_ulonglong <S2SV_ModEnd> v ; v = 0 ; for ( i
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf , int len ) { jas_stream_t *
<S2SV_ModStart> jas_iccputsint ( jas_stream_t * out , int n , jas_longlong val ) { jas_ulonglong <S2SV_ModEnd> tmp ; tmp = ( val < 0 )
<S2SV_ModStart> jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong <S2SV_ModEnd> val ) { int i ; int c ;
<S2SV_ModStart> -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }
<S2SV_ModStart> htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; size_t size ; <S2SV_ModStart> dec -> tileyoff , dec -> tileheight ) ; if ( ! jas_safe_size_mul ( dec -> numhtiles , dec -> numvtiles , & size ) ) { return - 1 ; } dec -> numtiles = size <S2SV_ModEnd> ; JAS_DBGLOG ( 10 , ( "numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n" , dec
<S2SV_ModStart> -> numcomps < 3 ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" <S2SV_ModStart> ( "ICT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" ) ; return - 1 ; }
<S2SV_ModStart> return - 1 ; } break ; } } <S2SV_ModEnd> if ( ! cmpt -> sampperx || ! cmpt <S2SV_ModStart> , cmpt ) ) { goto error ; } jas_tvparser_destroy ( tvp ) ;
<S2SV_ModStart> boxinfo -> ops ; box -> len = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) <S2SV_ModStart> , in , box -> datalen ) ) { box -> ops = & jp2_boxinfo_unk . ops ;
<S2SV_ModStart> jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( "got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n" <S2SV_ModEnd> , box -> info -> name ) ; }
<S2SV_ModStart> * boxinfo ; if ( ! ( box = jp2_box_create0 ( ) ) ) { return 0 ; } <S2SV_ModEnd> box -> type = type ; box -> len
<S2SV_ModStart> = 0 ; if ( ! ( box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( jp2_getuint32 ( in , & len ) <S2SV_ModStart> len = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>" "type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%" PRIuFAST32 "\\n" <S2SV_ModEnd> , \'"\' , boxinfo -> name , \'"\' , <S2SV_ModStart> if ( box -> len == 1 ) { JAS_DBGLOG ( 10 , ( "big<S2SV_blank>length\\n" ) ) ;
<S2SV_ModStart> len - JP2_BOX_HDRLEN ( false ) ) ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ;
<S2SV_ModStart> box -> data . bpcc ; unsigned int i ; bpcc -> bpcs = 0
<S2SV_ModStart> cdef ; jp2_cdefchan_t * chan ; unsigned int channo ; cdef -> ents = 0
<S2SV_ModStart> cmap ; jp2_cmapent_t * ent ; unsigned int i ; cmap -> ents = 0
<S2SV_ModStart> int_fast32_t x ; pclr -> lutdata = 0 ; pclr -> bpc = 0 ;
<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + <S2SV_ModEnd> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl <S2SV_ModStart> > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + <S2SV_ModEnd> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {
<S2SV_ModStart> siz ; unsigned int i ; uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> in , & siz -> numcomps ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( "reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( "tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( "number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( "XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( "YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( "XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( "YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } return - 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = "?" ; unsigned short port = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> "udp6" : "tcp6" ; break ; case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct sockaddr_un * ) sock_addr ) -> <S2SV_ModStart> ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0' ; protoname = "unix" ; break
<S2SV_ModStart> -> rbytes ) ; if ( ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , "get<S2SV_blank>" ) && strcmp ( ptr , "gets<S2SV_blank>" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont = el + 1 ; if ( (
<S2SV_ModStart> enum try_read_result gotdata = READ_NO_DATA_RECEIVED ; int res ; int num_allocs = 0 ; <S2SV_ModStart> c -> rbytes >= c -> rsize ) { if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ;
<S2SV_ModStart> ) ) ; } return ; } it = limited_get ( key , nkey , c <S2SV_ModEnd> ) ; if ( settings . detail_enabled ) {
<S2SV_ModStart> value , "mode" ) == 0 && ntokens >= 4 <S2SV_ModEnd> && settings . lru_maintainer_thread ) { if ( strcmp <S2SV_ModStart> value , "temp_ttl" ) == 0 && ntokens >= 4 <S2SV_ModEnd> && settings . lru_maintainer_thread ) { if ( !
<S2SV_ModStart> '<S2SV_blank>' ) { ++ ptr ; } if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , "get<S2SV_blank>" , 4 ) && strncmp ( ptr , "gets<S2SV_blank>" , 5 ) <S2SV_ModEnd> ) ) { conn_set_state ( c , conn_closing )
<S2SV_ModStart> . port = 11211 ; settings . udpport = 0 <S2SV_ModEnd> ; settings . inter = NULL ; settings .
<S2SV_ModStart> LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
<S2SV_ModStart> endif chunked = 1 ; } } while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> == '\\r' || header_buf [ i ] == '\\n' )
<S2SV_ModStart> * datas = ( struct IGDdatas * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
<S2SV_ModStart> NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser . xmlstart = buffer ; parser .
<S2SV_ModStart> NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser . xmlstart = buffer ; parser .
<S2SV_ModStart> p , buf + n ) ; if ( l > ( unsigned ) ( buf + n - p ) <S2SV_ModEnd> ) { syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)" , l <S2SV_ModStart> p , buf + n ) ; if ( l > ( unsigned ) ( buf + n - p ) <S2SV_ModEnd> ) { syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; <S2SV_ModStart> p , buf + n ) ; if ( l > ( unsigned ) ( buf + n - p ) <S2SV_ModEnd> ) { syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; <S2SV_ModStart> p , buf + n ) ; if ( l > ( unsigned ) ( buf + n - p ) <S2SV_ModEnd> ) { syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ;
<S2SV_ModStart> ) { syslog ( LOG_ERR , "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; * pp = p -> next ;
<S2SV_ModStart> , protocol ) ; return - 3 ; } if ( desc == NULL ) desc = "" ;
<S2SV_ModStart> case 1 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 2 : context -> curY += <S2SV_ModStart> case 2 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 3 : context -> curY += <S2SV_ModStart> case 3 : context -> curY += 4 ; <S2SV_ModEnd> break ; case 4 : context -> curY += <S2SV_ModStart> : context -> curY += 2 ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> case 1 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 2 : context -> curY += <S2SV_ModStart> case 2 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 3 : context -> curY += <S2SV_ModStart> case 3 : context -> curY += 4 ; <S2SV_ModEnd> break ; case 4 : context -> curY += <S2SV_ModStart> : context -> curY += 2 ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> ( u8 ) act_code ; old_code = act_code ; if ( npix > 0 ) <S2SV_ModStart> ; * ( -- stackp ) = casspecial ; if ( npix >= ( stack_top - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= ( stack_top - stackp ) ; stackp
<S2SV_ModStart> ) { int rc ; u64 base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> == NULL ) return HTTP_INTERNAL_SERVER_ERROR ; } else { # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> if ( Fp == NULL ) return HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif
<S2SV_ModStart> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> , sizeof ( cmsUInt16Number ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } if (
<S2SV_ModStart> ) goto Error ; cmsPipelineFree ( Lut ) ; Lut = NULL ; <S2SV_ModStart> = ColorSpaceOut ; } return Result ; Error : if ( Lut != NULL )
<S2SV_ModStart> ; if ( l >= ( len - o - 4
<S2SV_ModStart> BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test59.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ;
<S2SV_ModStart> } sr -> fd_file = fd ; sr -> fd_is_fdt = MK_FALSE ; sr ->
<S2SV_ModStart> if ( sr -> fd_file > 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { mk_vhost_close ( sr ) ; } else { close ( sr -> fd_file ) ; } <S2SV_ModEnd> } if ( sr -> headers . location )
<S2SV_ModStart> = id ; sr -> vhost_fdt_hash = hash ; sr -> fd_is_fdt = MK_TRUE ;
<S2SV_ModStart> * c ) { size_t i ; size_t e ; mrb_value nil <S2SV_ModStart> if ( ! mrb_immediate_p ( v ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) <S2SV_ModStart> , mrb_basic_ptr ( v ) ) ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
<S2SV_ModStart> struct mrb_context * old_c = mrb -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> mrb_value value ; fiber_check_cfunc ( mrb , c ) ; status = c -> status ; if ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED ) { mrb_raise ( mrb , <S2SV_ModStart> , E_FIBER_ERROR , "resuming<S2SV_blank>transferred<S2SV_blank>fiber" ) ; } if ( status == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED ) { mrb_raise ( mrb , <S2SV_ModStart> , E_FIBER_ERROR , "double<S2SV_blank>resume<S2SV_blank>(fib)" ) ; } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED ) { mrb_raise ( mrb , <S2SV_ModStart> ( mrb , E_FIBER_ERROR , "resuming<S2SV_blank>dead<S2SV_blank>fiber" ) ; } old_c <S2SV_ModEnd> -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_ModStart> c -> prev : mrb -> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED ) { mrb_value * b , <S2SV_ModStart> ) { mrb_value * b , * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c -> stack + 1 ; e <S2SV_ModStart> ( mrb , a , len ) ; } <S2SV_ModEnd> if ( vmexec ) { c -> vmexec =
<S2SV_ModStart> TRUE ; mrb_get_args ( mrb , "o" , & orig ) ; fptr_orig = io_get_open_fptr ( mrb , <S2SV_ModStart> = ( struct mrb_io * ) mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE ( copy ) = & mrb_io_type
<S2SV_ModStart> ptmp = tmp ; while ( * s && ( * s != \'\\"\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModEnd> ) * ptmp ++ = * s ++ ; <S2SV_ModStart> ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )
<S2SV_ModStart> "Handling<S2SV_blank>untagged<S2SV_blank>NO\\n" ) ; mutt_error ( "%s" , s + 2 <S2SV_ModEnd> ) ; } return 0 ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> != IMAP_CMD_CONTINUE ) { idata -> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n" )
<S2SV_ModStart> nntp_data = NULL ; char group [ LONG_STRING ] = "" <S2SV_ModStart> return 0 ; if ( sscanf ( line , "%1023s<S2SV_blank>" ANUM "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%8191[^\\n]" <S2SV_ModEnd> , group , & last , & first , <S2SV_ModStart> , & mod , desc ) < 4 ) { mutt_debug ( 4 , "Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n" , line ) ; return 0 ; } <S2SV_ModEnd> nntp_data = nntp_data_find ( nserv , group ) ;
<S2SV_ModStart> strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 <S2SV_ModEnd> ; * pt ++ = '\\\\' ; * pt
<S2SV_ModStart> ( char * out , const char * in , size_t olen <S2SV_ModStart> ) return - 1 ; in += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> ++ ; if ( digit3 != '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> ++ ; if ( digit4 != '=' ) { if ( len == olen ) return len ;
<S2SV_ModStart> } else if ( enc == ENCBASE64 ) { const int olen = 3 * len / 4 + 1 ; char * out = mutt_mem_malloc ( olen <S2SV_ModEnd> ) ; int dlen = mutt_b64_decode ( out , <S2SV_ModStart> ; int dlen = mutt_b64_decode ( out , it , olen
<S2SV_ModStart> ; int len = mutt_b64_decode ( buffer , encoded , sizeof ( buffer )
<S2SV_ModStart> , strlen ( endp ) + 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
<S2SV_ModStart> Buffer err , token ; struct ImapMbox mx ; size_t len = 0 ; <S2SV_ModStart> err . dsize = sizeof ( errstr ) ; len = <S2SV_ModStart> snprintf ( mbox , sizeof ( mbox ) , "%smailboxes<S2SV_blank>" , subscribe ? "" : "un" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> ) ; if ( mutt_parse_rc_line ( mbox , &
<S2SV_ModStart> return 0 ; } return mutt_bcache_del ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> bcached = ( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0 ) ; ctx -> hdrs [
<S2SV_ModStart> -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) <S2SV_ModEnd> ) ; if ( msg -> fp ) return <S2SV_ModStart> -> fp = mutt_bcache_put ( pop_data -> bcache , cache_id ( h -> data ) <S2SV_ModEnd> ) ; if ( ! msg -> fp ) <S2SV_ModStart> ( bcache ) mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) <S2SV_ModEnd> ) ; else { cache -> index = h
<S2SV_ModStart> 0 ) { mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) ; # ifdef USE_HCACHE mutt_hcache_delete ( hc ,
<S2SV_ModStart> 1 , sizeof ( unsigned char ) ) ; if ( fc . messages == NULL ) return - 1 ;
<S2SV_ModStart> ; * pt ++ = \'"\' ; dlen -= 3 <S2SV_ModEnd> ; for ( ; * s && dlen ;
<S2SV_ModStart> , sizeof ( errstr ) , list . name , true
<S2SV_ModStart> ( term ) , pat -> p . str , false <S2SV_ModStart> ( term , sizeof ( term ) , delim , false <S2SV_ModStart> ( term ) , pat -> p . str , false <S2SV_ModStart> ( term ) , pat -> p . str , false <S2SV_ModStart> ( term ) , pat -> p . str , false
<S2SV_ModStart> ) ; imap_quote_string ( dest , dlen , buf , false
<S2SV_ModStart> dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char * pt = dest ; const char
<S2SV_ModStart> s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> "/etc/skel/.zshrc" , & s ) == 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.zshrc" , fname , u , g , <S2SV_ModStart> s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> "/etc/skel/.cshrc" , & s ) == 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.cshrc" , fname , u , g , <S2SV_ModStart> s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> "/etc/skel/.bashrc" , & s ) == 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.bashrc" , fname , u , g ,
<S2SV_ModStart> i ] , "--allow-debuggers" ) == 0 ) { struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( "uname" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , "%d.%d" , & major , & minor ) ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , "Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>" "A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>" "Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n" , major , minor ) ; exit ( 1 ) ; }
<S2SV_ModStart> dest ) ; exit ( 1 ) ; } copy_file_as_user ( src , <S2SV_ModEnd> dest , getuid ( ) , getgid ( ) <S2SV_ModStart> dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink ( src ) ; } <S2SV_null>
<S2SV_ModStart> dest ) ; exit ( 1 ) ; } copy_file_as_user ( src , <S2SV_ModEnd> dest , getuid ( ) , getgid ( ) <S2SV_ModStart> dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink ( src ) ; } <S2SV_null>
<S2SV_ModStart> s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> "/etc/skel/.zshrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.zshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.zshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , "%s/.cshrc" , homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname <S2SV_ModEnd> ) ; exit ( 1 ) ; } if <S2SV_ModStart> ; exit ( 1 ) ; } if ( stat ( "/etc/skel/.cshrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.cshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.cshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , "%s/.bashrc" , homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( stat ( "/etc/skel/.bashrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.bashrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.bashrc" ) ; } free ( fname ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { if ( is_link ( src ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n" , src ) ; exit ( 1 ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { fprintf ( stderr , "Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; return 1 ; } return 0 ;
<S2SV_ModStart> ( src ) ) { fprintf ( stderr , "Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" ) ; return 0 ; } copy_file_as_user ( src , <S2SV_ModEnd> dest , getuid ( ) , getgid ( ) <S2SV_ModStart> dest , getuid ( ) , getgid ( ) , 0600 ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; return 1 ; } return 0 ;
<S2SV_ModStart> dest ) ; exit ( 1 ) ; } copy_file_as_user <S2SV_ModEnd> ( src , dest , getuid ( ) , <S2SV_ModStart> getgid ( ) , S_IRUSR | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink ( src ) ; } <S2SV_null>
<S2SV_ModStart> dest ) ; exit ( 1 ) ; } copy_file_as_user <S2SV_ModEnd> ( src , dest , getuid ( ) , <S2SV_ModStart> getgid ( ) , S_IRUSR | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink ( src ) ; } <S2SV_null>
<S2SV_ModStart> "/etc/skel/.zshrc" , & s ) == 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.zshrc" , fname , u , g <S2SV_ModStart> , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.zshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 ( "touch" , fname ) ; <S2SV_ModStart> ) ; fs_logger2 ( "touch" , fname ) ; <S2SV_ModEnd> } free ( fname ) ; } else if <S2SV_ModStart> "/etc/skel/.cshrc" , & s ) == 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.cshrc" , fname , u , g <S2SV_ModStart> , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.cshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 ( "touch" , fname ) ; <S2SV_ModStart> ) ; fs_logger2 ( "touch" , fname ) ; <S2SV_ModEnd> } free ( fname ) ; } else { <S2SV_ModStart> "/etc/skel/.bashrc" , & s ) == 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.bashrc" , fname , u , g <S2SV_ModStart> , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.bashrc" ) ; } <S2SV_ModEnd> free ( fname ) ; } } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } free ( rp ) ; } copy_file_as_user <S2SV_ModEnd> ( src , dest , getuid ( ) , <S2SV_ModStart> ) , getgid ( ) , 0644 ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; return 1 ; } return 0 ;
<S2SV_ModStart> stderr , "Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , dest , getuid ( ) , <S2SV_ModStart> ) , getgid ( ) , 0600 ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; return 1 ; } return 0 ;
<S2SV_ModStart> buf ) ; } fclose ( fp ) ; unlink ( RUN_LIB_FILE ) ;
<S2SV_ModStart> ( "tmpfs" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
<S2SV_ModStart> ] && s [ 2 ] ) ) { char t <S2SV_ModEnd> = from_hex ( s [ 1 ] ) << <S2SV_ModStart> << 4 | from_hex ( s [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> ) ) outFileName = tqx_value ; } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> ! _zip_dirent_process_winzip_aes ( zde , error ) ) { <S2SV_ModEnd> return - 1 ; } zde -> extra_fields =
<S2SV_ModStart> f -> codebooks [ c ] . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read = n_read / r -> part_size
<S2SV_ModStart> * r = f -> residue_config + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read = n_read / r -> part_size
<S2SV_ModStart> ( output [ x ] , inverse_db_table [ y & 255 <S2SV_ModStart> ( output [ x ] , inverse_db_table [ y & 255
<S2SV_ModStart> ) return f -> window [ 1 ] ; <S2SV_ModEnd> return NULL ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> dim ) ) <= entries ) ++ r ; if <S2SV_ModEnd> ( pow ( ( float ) r + 1 <S2SV_ModStart> ( float ) r + 1 , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int ) floor ( pow ( ( <S2SV_ModStart> ( ( float ) r , dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , ilog ( limit ) ) ; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> if ( c -> lookup_type == 1 ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; c -> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } else { c -> lookup_values = c <S2SV_ModStart> j = 0 ; j < g -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> = get_bits ( f , 8 ) + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )
<S2SV_ModStart> * w = get_window ( f , n ) ; if ( w == NULL ) return 0
<S2SV_ModStart> ; } run_cmd ( tty_fd , xfr_cmd , fname <S2SV_ModEnd> ) ; free ( fname ) ; break ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int run_cmd ( int fd , const char * cmd , const char * args_extra <S2SV_ModEnd> ) { pid_t pid ; sigset_t sigm , sigm_old <S2SV_ModStart> 1 ; } } else { long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> ; term_remove ( STI ) ; term_erase ( fd <S2SV_ModStart> ) ; dup2 ( fd , STO ) ; argc = 0 ; r = split_quoted ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>command\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , "No<S2SV_blank>command<S2SV_blank>given\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , "$<S2SV_blank>%s<S2SV_blank>%s\\n" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; fd_printf ( STDERR_FILENO , "exec:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; exit ( RUNCMD_EXEC_FAIL <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; filegen = filegen_get ( filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "stats<S2SV_blank>%s<S2SV_blank>unrecognized" , filegen_string ) ; continue ; } <S2SV_ModStart> ) ; filegen = filegen_get ( filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized" , filegen_file ) ; continue ; }
<S2SV_ModStart> ( statsdir , "protostats" , & protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir , "cryptostats" , & cryptostats ) <S2SV_ModStart> ( statsdir , "cryptostats" , & cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir , "timingstats" , & timingstats ) <S2SV_ModStart> ( statsdir , "timingstats" , & timingstats ) ; <S2SV_ModEnd> step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit
<S2SV_ModStart> 215 : # line 997 "ntp_parser.y" { char prefix ; char * type ; switch ( <S2SV_ModEnd> ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModStart> ) - ( 1 ) ] . String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 235 : # line 1082 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] . Address_node ) ) ; } break <S2SV_ModStart> . Address_node ) ) ; } break ; case 238 : # line 1092 <S2SV_ModEnd> "ntp_parser.y" { if ( ( yyvsp [ ( 1 <S2SV_ModStart> ; } break ; case 239 : # line 1100 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Integer ) = 1 <S2SV_ModStart> ; } break ; case 240 : # line 1101 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Integer ) = 0 <S2SV_ModStart> ; } break ; case 241 : # line 1105 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Double ) = ( <S2SV_ModStart> ; } break ; case 243 : # line 1116 <S2SV_ModEnd> "ntp_parser.y" { cfgt . sim_details = create_sim_node ( ( <S2SV_ModStart> ; } break ; case 244 : # line 1130 <S2SV_ModEnd> "ntp_parser.y" { old_config_style = 0 ; } break ; <S2SV_ModStart> ; } break ; case 245 : # line 1134 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue <S2SV_ModStart> ; } break ; case 246 : # line 1135 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue <S2SV_ModStart> ; } break ; case 247 : # line 1139 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 248 : # line 1140 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 249 : # line 1144 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue <S2SV_ModStart> ; } break ; case 250 : # line 1145 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue <S2SV_ModStart> ; } break ; case 251 : # line 1150 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Sim_server ) = create_sim_server <S2SV_ModStart> ; } break ; case 252 : # line 1154 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Double ) = ( <S2SV_ModStart> ; } break ; case 253 : # line 1158 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Address_node ) = ( <S2SV_ModStart> ; } break ; case 254 : # line 1162 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue <S2SV_ModStart> ; } break ; case 255 : # line 1163 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue <S2SV_ModStart> ; } break ; case 256 : # line 1168 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Sim_script ) = create_sim_script_info <S2SV_ModStart> ; } break ; case 257 : # line 1172 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue <S2SV_ModStart> ; } break ; case 258 : # line 1173 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue <S2SV_ModStart> ; } break ; case 259 : # line 1178 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 260 : # line 1180 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 261 : # line 1182 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 262 : # line 1184 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> ; } break ; case 263 : # line 1186 <S2SV_ModEnd> "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_dval <S2SV_ModStart> Double ) ) ; } break ; # line 3836 <S2SV_ModEnd> "ntp_parser.c" default : break ; } YY_SYMBOL_PRINT ( "-><S2SV_blank>$$<S2SV_blank>="
<S2SV_ModStart> ; struct media_type * media , multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range ; size_t content_length = 0 <S2SV_ModEnd> ; int code = 500 , fd = - <S2SV_ModStart> = - 1 , i , nranges , ret <S2SV_ModEnd> ; char content_range [ 64 ] ; const char <S2SV_ModStart> , path , st ) ; if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code = 416 ; ( void ) <S2SV_ModStart> media_find_config ( env , srv_conf , path ) ; r -> range_media = media ; if ( nranges == 1 ) { range = & r -> range [ 0 ] ; ( void ) snprintf ( content_range , sizeof ( content_range ) , "bytes<S2SV_blank>%lld-%lld/%lld" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , "Content-Range" , content_range ) == NULL ) goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end - range -> start + 1 <S2SV_ModStart> range -> end - range -> start + 1 ; } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu\\r\\n" "Content-Type:<S2SV_blank>%s/%s\\r\\n" "Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 ) goto abort ; content_length += ret + range -> end - range -> start + 1 ; } if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu--\\r\\n" , clt -> clt_boundary ) ) < 0 ) goto abort ; content_length += ret <S2SV_ModEnd> ; ( void ) strlcpy ( multipart_media . media_type <S2SV_ModStart> media_subtype , sizeof ( multipart_media . media_subtype ) , "byteranges;<S2SV_blank>boundary=%llu" , clt -> clt_boundary ) ; media = & multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = server_response_http ( clt , 206 , <S2SV_ModStart> - 1 : goto fail ; case 0 : close ( fd ) ; goto done ; default : break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event" ; goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> clt_bev , EV_READ | EV_WRITE ) <S2SV_ModStart> clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt -> clt_bev ) ; clt -> <S2SV_ModStart> ; clt -> clt_bev = NULL ; abort : <S2SV_ModEnd> if ( fd != - 1 ) close (
<S2SV_ModStart> get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> struct monitor * monitor_init ( void ) { <S2SV_ModEnd> struct monitor * mon ; mon = xcalloc ( <S2SV_ModStart> ) ; monitor_openfds ( mon , 1 ) ; <S2SV_ModEnd> return mon ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int r , pktype , authenticated = 0 ; <S2SV_ModEnd> if ( ( r = sshpkt_get_cstring ( ssh , <S2SV_ModStart> ) ) ; goto done ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } if (
<S2SV_ModStart> = authctxt -> pw ; struct sshbuf * b = NULL <S2SV_ModStart> sshkey * key = NULL ; char * pkalg = NULL <S2SV_ModStart> , * ca_s = NULL ; u_char * pkblob = NULL , * sig = NULL <S2SV_ModEnd> , have_sig ; size_t blen , slen ; int <S2SV_ModStart> 0 ; struct sshauthopt * authopts = NULL ; <S2SV_ModEnd> if ( ( r = sshpkt_get_u8 ( ssh , <S2SV_ModStart> "%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done <S2SV_ModStart> = 1 ; } sshbuf_free ( b ) ; <S2SV_ModEnd> auth2_record_key ( authctxt , authenticated , key ) ; <S2SV_ModStart> , ssh_err ( r ) ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } if ( <S2SV_ModStart> ( key_s ) ; free ( ca_s ) ; free ( sig ) ;
<S2SV_ModStart> ( void ) { fprintf ( stderr , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" ) ; exit ( 1 ) ; }
<S2SV_ModStart> ( readonly && ( ( flags & O_ACCMODE ) != O_RDONLY || ( flags & ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> ) ) { verbose ( "Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode" ) ; status
<S2SV_ModStart> size_t len ; struct stat st ; int r , dontmax = 0 <S2SV_ModStart> st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;
<S2SV_ModStart> ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ! use_privsep
<S2SV_ModStart> 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep
<S2SV_ModStart> -> end , sack . end ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> -> rcv_lastsack , sack . start ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
<S2SV_ModStart> size = ( off_t ) ull ; if ( * cp == '\\0' || strchr ( cp , '/' ) != NULL || strcmp ( cp , "." ) == 0 || strcmp ( cp , ".." ) == 0 <S2SV_ModEnd> ) { run_err ( "error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s" , cp ) ;
<S2SV_ModStart> ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL )
<S2SV_ModStart> ) static int expire_checked = 0 ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
<S2SV_ModStart> goto err ; } # else { int i ; int ubits = BN_num_bits ( u ) ; int vbits = BN_num_bits ( v ) ; int <S2SV_ModEnd> top = p -> top ; BN_ULONG * udp <S2SV_ModStart> ubits -- ; } if ( ubits <= BN_BITS2 ) { if ( udp [ 0 ] == 0 ) goto err ; if ( udp [ 0 ] == 1 ) break ; } <S2SV_ModEnd> if ( ubits < vbits ) { i =
<S2SV_ModStart> "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>select<S2SV_blank>groups" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : return OFPERR_OFPGMFC_BAD_TYPE <S2SV_ModEnd> ; } switch ( group_cmd ) { case OFPGC15_ADD <S2SV_ModStart> "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>add<S2SV_blank>and<S2SV_blank>delete<S2SV_blank>group<S2SV_blank>modifications" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : return OFPERR_OFPGMFC_BAD_COMMAND <S2SV_ModEnd> ; } if ( payload -> size < sizeof
<S2SV_ModStart> -> n_slaves ) ; error = OFPERR_OFPBAC_BAD_LEN ; } else { <S2SV_ModStart> ) ; bundle = ofpacts -> header ; } }
<S2SV_ModStart> sizeof ( trust_data ) ; trust_data . dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ; trust_data . <S2SV_ModStart> ) ; safe_free ( trust_file . pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( "PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( "PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }
<S2SV_ModStart> error_code = GetLastError ( ) ; if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModEnd> return WindowsErrorString ( ) ; switch ( error_code ) <S2SV_ModStart> : return "Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check." ; case CRYPT_E_NO_TRUSTED_SIGNER : return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; case CERT_E_UNTRUSTEDROOT : return "The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted." ; case TRUST_E_NOSIGNATURE : return "Not<S2SV_blank>digitally<S2SV_blank>signed." ; case TRUST_E_EXPLICIT_DISTRUST : return "One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."
<S2SV_ModStart> PyObject * args , PyObject * kw ) { PyUnicodeObject <S2SV_ModEnd> * logical = NULL ; FriBidiParType base = FRIBIDI_TYPE_RTL <S2SV_ModStart> * logical = NULL ; FriBidiParType base = FRIBIDI_TYPE_RTL <S2SV_ModEnd> ; int clean = 0 ; int reordernsm = <S2SV_ModStart> kwargs [ ] = { "logical" , "base_direction" , <S2SV_ModEnd> "clean" , "reordernsm" , NULL } ; if ( <S2SV_ModStart> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , "U|iii" <S2SV_ModEnd> , kwargs , & logical , & base , <S2SV_ModStart> kwargs , & logical , & base , & clean , & reordernsm ) ) { return NULL ; } <S2SV_ModEnd> if ( ! ( base == FRIBIDI_TYPE_RTL || base <S2SV_ModStart> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) { <S2SV_ModStart> PyErr_Format ( PyExc_ValueError , "invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON" , base ) ; } return unicode_log2vis <S2SV_ModEnd> ( logical , base , clean , reordernsm ) <S2SV_ModStart> logical , base , clean , reordernsm ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } } break ; case 'p' : if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> username ) { int res ; PktBuf * buf <S2SV_ModEnd> ; client -> pool = get_pool ( client ->
<S2SV_ModStart> user = client -> auth_user ; if ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> size_required ; uint32_t num_extensions = 0 ; if ( <S2SV_ModEnd> size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" ,
<S2SV_ModStart> ; while ( size_left ) { uint32_t id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { _gdImageGifCtx ( im , out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( ! _gdImageGifCtx ( im , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData ( out , size ) ; <S2SV_ModStart> rv = gdDPExtractData ( out , size ) ; } else { rv = NULL ; }
<S2SV_ModStart> , int fg , gdIOCtx * out ) { _gdImageWBMPCtx ( image , fg , out ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> char digest [ 64 ] ; PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 32 ] ; PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 20 ] ; PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 16 ] ; PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; }
<S2SV_ModStart> ) ; if ( read != entry . uncompressed_filesize || read <= 8
<S2SV_ModStart> ) flags , hint_charset , double_encode TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
<S2SV_ModStart> var , zend_bool eof TSRMLS_DC ) { char * start , * <S2SV_ModStart> var -> end ) { return 0 ; } start = var -> ptr + var -> already_scanned ; vsep = memchr ( start , '&' , var -> end - start <S2SV_ModEnd> ) ; if ( ! vsep ) { if <S2SV_ModStart> vsep ) { if ( ! eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> + ( vsep != var -> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> return FAILURE ; } } if ( ! eof && vars -> str . c != vars -> ptr
<S2SV_ModStart> , zend_class_entry * ce ) { long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , "Bad<S2SV_blank>unserialize<S2SV_blank>data" ) ; return - 1 ; } <S2SV_ModStart> , "Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'" , ce -> name ) ; return - 1 <S2SV_ModEnd> ; } return elements ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } start = cursor ; # line 501 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE yych ; static const unsigned char <S2SV_ModStart> ':' ) goto yy95 ; yy3 : # line 875 "ext/standard/var_unserializer.re" { return 0 ; } # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : yych = * ( YYMARKER = <S2SV_ModStart> yy3 ; yy14 : ++ YYCURSOR ; # line 869 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , <S2SV_ModStart> "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data" ) ; return 0 ; } # line 612 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 717 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , len2 , len3 , <S2SV_ModStart> object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 795 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 704 "ext/standard/var_unserializer.re" { long elements ; <S2SV_ModEnd> if ( ! var_hash ) return 0 ; INIT_PZVAL <S2SV_ModStart> return 0 ; INIT_PZVAL ( * rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 833 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 683 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long elements = parse_iv ( start + <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 648 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 0 ) ; return 1 ; } # line 931 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 615 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 1 ) ; return 1 ; } # line 985 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> } } yy63 : ++ YYCURSOR ; # line 605 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 use_double : <S2SV_ModStart> ) ) ; return 1 ; } # line 1083 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 590 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ; } return 1 ; } # line 1157 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 int digits <S2SV_ModStart> ) ) ; return 1 ; } # line 1211 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 556 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ) ; return 1 ; } # line 1226 "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 549 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> rval ) ; return 1 ; } # line 1236 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 526 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1282 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 505 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1326 "ext/standard/var_unserializer.c" } # line 877 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> output ) == FAILURE ) { return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive" ) ; RETURN_FALSE ; }
<S2SV_ModStart> ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> ) goto yy18 ; yych = * ++ YYCURSOR <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 805 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } # line 837 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 882 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> str ) ; return 1 ; } # line 937 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> len ) ; return 1 ; } # line 990 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1087 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ; } return 1 ; } # line 1162 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1215 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1229 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 573 <S2SV_ModStart> rval ) ; return 1 ; } # line 1238 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> rval_ref ) ; return 1 ; } # line 1286 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ; } return 1 ; } # line 1335 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } # line 886 "ext/standard/var_unserializer.re" return 0 ;
<S2SV_ModStart> TSRMLS_CC ) ; ctx -> request_processed = 1 ; apr_brigade_cleanup ( brigade ) ;
<S2SV_ModStart> index >= intern -> llist -> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException , "Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" , 0 ) ;
<S2SV_ModStart> ) row_buffer -> ptr + data_size + 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> ++ ) { zend_uchar * this_field_len_pos = p ; const <S2SV_ModStart> long len = php_mysqlnd_net_field_length ( & p ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , "Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>" MYSQLND_SZ_T_SPEC "<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }
<S2SV_ModStart> * ) & var2 ) == SUCCESS ) { if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE ; } else { <S2SV_ModEnd> RETURN_FALSE ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . x = Z_LVAL ( lval ) ; } else { rect . x = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . y = Z_LVAL ( lval ) ; } else { rect . y = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . width = Z_LVAL ( lval ) ; } else { rect . width = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . height = Z_LVAL ( lval ) ; } else { rect . height = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> ( zval_affine_elem ) ; break ; case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; affine [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . x = Z_LVAL ( lval ) ; } else { rect . x = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . y = Z_LVAL ( lval ) ; } else { rect . y = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . width = Z_LVAL ( lval ) ; } else { rect . width = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . height = Z_LVAL ( lval ) ; } else { rect . height = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; x = Z_DVAL ( dval ) ; } else { x = Z_DVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; y = Z_DVAL ( dval ) ; } else { y = Z_DVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> ( tmp ) ; break ; case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; m1 [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC , <S2SV_ModStart> ( tmp ) ; break ; case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; m2 [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC ,
<S2SV_ModStart> * ) & var ) == SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points [ i ] . x = <S2SV_ModStart> ) ; points [ i ] . x = Z_LVAL ( lval ) ; } else { points [ i ] . x = Z_LVAL_PP ( var ) ; } <S2SV_ModEnd> } if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) <S2SV_ModStart> * ) & var ) == SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points [ i ] . y = <S2SV_ModStart> ) ; points [ i ] . y = Z_LVAL ( lval ) ; } else { points [ i ] . y = Z_LVAL_PP ( var ) ; } } } <S2SV_ModEnd> if ( filled ) { gdImageFilledPolygon ( im ,
<S2SV_ModStart> socket_gid = - 1 ; wp -> socket_mode = 0660 <S2SV_ModEnd> ; if ( ! c ) { return 0
<S2SV_ModStart> if ( zr_rsrc -> zf ) { buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 ) ; n = zip_fread ( zr_rsrc
<S2SV_ModStart> == NULL ) { RETURN_FALSE ; } buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 ) ; n = zip_fread ( zf
<S2SV_ModStart> get_properties = spl_array_get_properties ; spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
<S2SV_ModStart> tmp_line , response_code ) ; } } if ( tmp_line_len >= 1 && <S2SV_ModStart> == '\\n' ) { -- tmp_line_len ; if ( tmp_line_len >= 1 &&
<S2SV_ModStart> = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> } -- p ; count = Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> ) ) { goto outexcept ; } if ( <S2SV_ModEnd> * p == ',' ) { ++ p ; <S2SV_ModStart> & entry ) ; goto outexcept ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash = spl_object_storage_get_hash ( intern , getThis
<S2SV_ModStart> fpm_globals . max_requests = wp -> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
<S2SV_ModStart> - 1 ; zlog_set_fd ( - 1 ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
<S2SV_ModStart> ) ; } start = cursor ; # line 496 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE yych ; static const unsigned char <S2SV_ModStart> ':' ) goto yy95 ; yy3 : # line 861 "ext/standard/var_unserializer.re" { return 0 ; } # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : yych = * ( YYMARKER = <S2SV_ModStart> yy3 ; yy14 : ++ YYCURSOR ; # line 855 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , <S2SV_ModStart> "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data" ) ; return 0 ; } # line 607 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 708 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , len2 , len3 , <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 785 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 699 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { if ( ! var_hash ) return 0 <S2SV_ModStart> UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } # line 819 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 678 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long elements = parse_iv ( start + <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 643 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 0 ) ; return 1 ; } # line 917 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 610 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 1 ) ; return 1 ; } # line 971 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> } } yy63 : ++ YYCURSOR ; # line 600 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 use_double : <S2SV_ModStart> ) ) ; return 1 ; } # line 1069 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 585 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ; } return 1 ; } # line 1143 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 int digits <S2SV_ModStart> ) ) ; return 1 ; } # line 1197 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 551 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ) ; return 1 ; } # line 1212 "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 544 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> rval ) ; return 1 ; } # line 1222 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 521 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1268 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 500 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1312 "ext/standard/var_unserializer.c" } # line 863 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> "msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
<S2SV_ModStart> , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> ( php_gd_error ( "Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries" , nc ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> cidx = gdCalloc ( sidx , 1 ) ; if ( cidx == NULL ) { goto fail1 ; }
<S2SV_ModStart> ) ; double dTotalWeight = 0.0 ; int iSrc <S2SV_ModEnd> ; if ( iRight - iLeft + 1 > <S2SV_ModStart> ; } else { iRight -- ; } } res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . <S2SV_ModEnd> Weights [ iSrc - iLeft ] = scale_f_d *
<S2SV_ModStart> * sizeof ( uint32_t ) ) ; if ( q < p ||
<S2SV_ModStart> restoreAlphaBlending = 0 ; if ( border < 0 || color < 0
<S2SV_ModStart> int namelen ; int has_value ; php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> < endptr ; ) { zval * * tmp ; skip = 0 <S2SV_ModStart> * tmp == PS ( http_session_vars ) ) { skip = 1 <S2SV_ModEnd> ; } } if ( has_value ) { ALLOC_INIT_ZVAL <S2SV_ModStart> ) endptr , & var_hash TSRMLS_CC ) ) { if ( ! skip ) { <S2SV_ModStart> namelen , current , & var_hash TSRMLS_CC ) ; } <S2SV_ModStart> ( & var_hash , & current ) ; } if ( ! skip ) { PS_ADD_VARL ( name , namelen ) ; } <S2SV_ModEnd> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash
<S2SV_ModStart> int namelen ; int has_value ; php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> { zval * * tmp ; q = p ; skip = 0 <S2SV_ModStart> * tmp == PS ( http_session_vars ) ) { skip = 1 <S2SV_ModEnd> ; } } if ( has_value ) { ALLOC_INIT_ZVAL <S2SV_ModStart> ) endptr , & var_hash TSRMLS_CC ) ) { if ( ! skip ) { <S2SV_ModStart> namelen , current , & var_hash TSRMLS_CC ) ; } <S2SV_ModStart> ( & var_hash , & current ) ; } if ( ! skip ) { PS_ADD_VARL ( name , namelen ) ; } <S2SV_ModEnd> skip : efree ( name ) ; p =
<S2SV_ModStart> status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; buflen ++ ;
<S2SV_ModStart> * var , zend_bool eof ) { char * start , * <S2SV_ModStart> var -> end ) { return 0 ; } start = var -> ptr + var -> already_scanned ; vsep = memchr ( start , '&' , var -> end - start <S2SV_ModEnd> ) ; if ( ! vsep ) { if <S2SV_ModStart> vsep ) { if ( ! eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> + ( vsep != var -> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { zend_throw_error ( exception_ce , "%s" ,
<S2SV_ModStart> * options = NULL , * classes = NULL ; zval * retval <S2SV_ModStart> ) ; } ZEND_HASH_FOREACH_END ( ) ; } } retval = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p , p + buf_len , & <S2SV_ModStart> class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_ModEnd> if ( ! EG ( exception ) ) { <S2SV_ModStart> ) , buf_len ) ; } RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if (
<S2SV_ModStart> else { convert_to_string ( key ) ; if ( zend_hash_find <S2SV_ModEnd> ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P
<S2SV_ModStart> char * host = NULL ; # ifdef HAVE_IPV6 <S2SV_ModEnd> if ( * ( str ) == '[' && <S2SV_ModStart> ) == '[' && str_len > 1 ) { char * <S2SV_ModStart> + 1 , ']' , str_len - 2 ) , * e = NULL <S2SV_ModStart> ; } return NULL ; } * portno = strtol ( p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup ( str + 1 , p - <S2SV_ModStart> = NULL ; } if ( colon ) { char * e = NULL ; * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( str , colon - str ) ; <S2SV_ModStart> ( str , colon - str ) ; } } <S2SV_ModEnd> if ( get_err ) { * err = strpprintf <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( info & ZEND_MM_IS_SRUN ) { int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM ( info ) ; old_size = bin_data_size <S2SV_ModStart> ) ; old_size = bin_data_size [ old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> orig_lineno = __zend_orig_lineno ; # endif return ptr ; }
<S2SV_ModStart> , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
<S2SV_ModStart> , s + buf_len , & var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept ; } var_push_dtor ( & var_hash ,
<S2SV_ModStart> , 0 TSRMLS_CC ) ; if ( ! offset || ! ht
<S2SV_ModStart> ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers ( request_rec * r ) { oidc_cfg
<S2SV_ModStart> ( r , "invalid_token" , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user" ) ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> , "Invalid<S2SV_blank>Request" , apr_psprintf ( r -> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" <S2SV_ModEnd> ) , HTTP_INTERNAL_SERVER_ERROR ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> long long * table_start ) { int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long * index , start , end <S2SV_ModStart> return 0 ; SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ; ids = id_table . xattr_ids ; xattr_table_start = id_table . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( sBlk -> xattr_id_table_start + sizeof ( id_table ) ) ) ) { ERROR ( "read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModEnd> , index_bytes , index ) ; if ( res <S2SV_ModStart> index , indexes ) ; bytes = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ( unsigned char * ) xattr_ids ) + ( ( long long )
<S2SV_ModStart> color_type , NULL , NULL , NULL ) ; <S2SV_ModEnd> if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) <S2SV_ModStart> png_get_rowbytes ( png_ptr , info_ptr ) ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
<S2SV_ModStart> in_count ) ; count = in_count / 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> , & key_datums , & key_nulls , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
<S2SV_ModStart> tupTypmod ; my_extra -> ncolumns = ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;
<S2SV_ModStart> 0 ) ; PG_RETURN_POINTER ( out ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> * npairs = 0 ; return NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ) , errmsg ( "empty<S2SV_blank>query" ) ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
<S2SV_ModStart> ITEM * ptr , int32 * pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> ; } ptr += charlen ; } num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )
<S2SV_ModStart> ) num ++ ; ptr += charlen ; } if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;
<S2SV_ModStart> ITEM * ptr , int32 * pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> lenstack = 0 ; uint16 flag = 0 ; check_stack_depth ( ) ;
<S2SV_ModStart> ) , errdetail ( "Empty<S2SV_blank>query." ) ) ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> s ; int npts ; int size ; int base_size ; int <S2SV_ModStart> ) { s ++ ; depth ++ ; } base_size = sizeof ( path -> p [ 0 ] ) * npts ; size = offsetof ( PATH , p [ 0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; path = ( PATH * ) palloc (
<S2SV_ModStart> poly ; int npts ; int size ; int base_size ; int <S2SV_ModStart> errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\"%s\\"" , str ) ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ( POLYGON , p [ 0 ] ) + base_size ; if ( base_size / npts != <S2SV_ModStart> sizeof ( poly -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; poly = ( POLYGON * ) palloc0 (
<S2SV_ModStart> -> size = 0 ; return query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> cntsize ( in , & sumlen , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) )
<S2SV_ModStart> [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS <S2SV_ModEnd> ] ; char * realptr ; char * * <S2SV_ModStart> = 0 ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ;
<S2SV_ModStart> NULL ) { # ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ; * fsec = strtol ( fstr
<S2SV_ModStart> '.' ) { # ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ; * fsec = strtol ( fstr
<S2SV_ModStart> '\\0' ) { field [ nf ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart> * lp ++ = '\\0' ; nf ++ ; <S2SV_ModEnd> } * numfields = nf ; return 0 ;
<S2SV_ModStart> = 0 ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ;
<S2SV_ModStart> & realptr ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult
<S2SV_ModStart> path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_ModEnd> size_t pathlen ; path = dir ; if ( <S2SV_ModStart> [ pathlen - 1 ] = '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if ( res < 0 ) { <S2SV_ModStart> ) ; if ( res < 0 ) { if ( errno == EPERM ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM ; return - 1 ; }
<S2SV_ModStart> path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_ModEnd> size_t pathlen ; path = pstrdup ( p , <S2SV_ModStart> [ pathlen - 1 ] = '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if ( res < 0 ) { <S2SV_ModStart> ) ; if ( res < 0 ) { if ( errno == EPERM ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM ; return - 1 ; }
<S2SV_ModStart> ; s -> vex_v = 0 ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> ( haveQuote ) { cmd ++ ; p = cmd [ 0 ] ? find_eoq ( cmd + 1 ) : NULL <S2SV_ModEnd> ; if ( ! p || ! * p
<S2SV_ModStart> ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> ; } if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> 32 ) { for ( i = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> size ; i += 4 ) <S2SV_ModStart> } else { for ( i = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec -> size ; i += 8 )
<S2SV_ModStart> ( cnt = 0 , i = 0 ; i >= 0 && <S2SV_ModStart> sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; }
<S2SV_ModStart> == 0xaa ) { if ( pos + 8 + 8 <S2SV_ModStart> len ) { return op -> size ; } const <S2SV_ModStart> UINT ( data , pos + 4 ) ) ; const int <S2SV_ModEnd> max_val = ( ut32 ) ( UINT ( data
<S2SV_ModStart> live = true ; } -- parameters_size ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> ( ! values [ k ] . name ) { continue ; } <S2SV_ModEnd> if ( values [ k ] . name <
<S2SV_ModStart> || ! hdr || ! obuf || obuf_len < 1 <S2SV_ModEnd> ) { return NULL ; } value -> form <S2SV_ModStart> block . data = data ; } break ; # if 0 <S2SV_ModStart> READ ( buf , ut64 ) ; break ; # endif <S2SV_ModStart> value -> encoding . block . length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ] = READ ( buf , ut8 ) ; } <S2SV_ModStart> encoding . block . length + 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ] = READ ( buf , ut8 ) ; }
<S2SV_ModStart> , to ) ; return - 1 ; } int len = to - from ; ut8 * buf = calloc ( len <S2SV_ModEnd> , 1 ) ; if ( ! buf || <S2SV_ModStart> ( bf -> buf , from , buf , len <S2SV_ModEnd> ) ; while ( needle < to ) { <S2SV_ModStart> if ( ( to - needle ) > 5 + rc ) { bool is_wide32 = ( needle + rc + 2 < to ) && ( <S2SV_ModEnd> ! w [ 0 ] && ! w [ <S2SV_ModStart> [ 3 ] && ! w [ 4 ] )
<S2SV_ModStart> struct r_bin_mdmp_obj * obj ) { int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( obj -> kv , "mdmp_directory.offset" , <S2SV_ModStart> "mdmp_directory.format" , "[4]E?<S2SV_blank>" "(mdmp_stream_type)StreamType<S2SV_blank>" "(mdmp_location_descriptor)Location" , 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> -> hdr -> number_of_streams ; i ++ ) { ut32 delta = i * sizeof ( struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory ) ) ; if ( r ) { r_bin_mdmp_init_directory_entry ( obj , & entry ) ; } <S2SV_ModEnd> } return true ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> ; if ( vstart > end || vstart +
<S2SV_ModStart> , "NB10" , 4 ) == 0 ) { if ( dbg_data_len < 20 ) { eprintf ( "Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( <S2SV_ModStart> nb10_hdr . timestamp , nb10_hdr . age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> ( res -> file_name ) - 1 ) ; }
<S2SV_ModStart> res ) { const int nb10sz = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> r_bin_dyldcache_lib_t ) ; if ( ! ret ) { <S2SV_ModEnd> return NULL ; } if ( bin -> hdr <S2SV_ModStart> free ( ret ) ; return NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at ( bin -> b , bin -> hdr . startaddr , ( ut8 * ) image_infos , sz ) ; dyld_vmbase = r_buf_read64le ( bin -> b , <S2SV_ModEnd> bin -> hdr . baseaddroff ) ; liboff = <S2SV_ModStart> NULL ; } ret -> offset = liboff ; int pfo = image_infos [ idx ] . pathFileOffset ; if ( pfo < 0 || pfo > bin -> size ) { eprintf ( "corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n" , pfo <S2SV_ModEnd> ) ; free ( ret ) ; return NULL <S2SV_ModStart> ret ) ; return NULL ; } libname = r_buf_read_string ( bin -> b , pfo , 64 <S2SV_ModEnd> ) ; data = bin -> b -> buf
<S2SV_ModStart> 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i <S2SV_ModEnd> ) ; ++ cnt ) { Sdb * sdb_verdef <S2SV_ModStart> verdef -> vd_aux ; if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> += vdaux ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) <S2SV_ModEnd> ) { sdb_free ( sdb_verdef ) ; goto out_error <S2SV_ModStart> . vda_next ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) <S2SV_ModEnd> ) { sdb_free ( sdb_verdef ) ; sdb_free (
<S2SV_ModStart> if ( input [ 0 ] == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr ( input , '<S2SV_blank>' ) ; <S2SV_ModStart> fs , ptr , input , off ) ) { eprintf ( "Cannot<S2SV_blank>mount<S2SV_blank>%s\\n" , input ) ; } } <S2SV_ModEnd> else { if ( ! ( ptr = r_fs_name <S2SV_ModStart> -> fs , core -> offset ) ) ) { eprintf ( "Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n" ) ; } <S2SV_ModEnd> else if ( ! r_fs_mount ( core -> fs <S2SV_ModStart> ptr , input , core -> offset ) ) { eprintf ( "Cannot<S2SV_blank>mount<S2SV_blank>%s\\n" , input ) ; } <S2SV_ModEnd> free ( ptr ) ; } break ; case
<S2SV_ModStart> ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext <S2SV_ModStart> ) { grub_error ( GRUB_ERR_BAD_FS , "invalid<S2SV_blank>extent" ) ; free ( buf ) ; <S2SV_ModStart> ( ext [ i ] . len ) ) { free ( buf ) ; return 0 ; } <S2SV_ModEnd> else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( <S2SV_ModStart> ( ext [ i ] . start ) ; free ( buf ) ; <S2SV_ModStart> } } else { grub_error ( GRUB_ERR_BAD_FS , "something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent" ) ; free ( buf ) ; return - 1 ; } free ( buf ) ; <S2SV_ModEnd> } if ( fileblock < INDIRECT_BLOCKS ) { blknr <S2SV_ModStart> ( blksz ) ; if ( ! indir ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS <S2SV_ModStart> ( blksz ) ; if ( ! indir ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock
<S2SV_ModStart> , EXT2_BLOCK_SIZE ( data ) , buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = ( struct grub_ext4_extent_header * ) buf ;
<S2SV_ModStart> * currfound , struct grub_fshelp_find_file_closure * c ) { char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; <S2SV_ModEnd> while ( * name == '/' ) name ++ <S2SV_ModStart> ! * name ) { * currfound = currnode ; free ( fpath ) <S2SV_ModStart> ) { free_node ( currnode , c ) ; free ( fpath ) ; <S2SV_ModStart> ( ! found ) { if ( grub_errno ) { free ( fpath ) ; return grub_errno ; } <S2SV_ModEnd> break ; } if ( type == GRUB_FSHELP_SYMLINK ) <S2SV_ModStart> ) ; free_node ( oldnode , c ) ; free ( fpath ) ; <S2SV_ModStart> ! symlink ) { free_node ( oldnode , c ) ; free ( fpath <S2SV_ModStart> ) { free_node ( oldnode , c ) ; free ( fpath ) ; <S2SV_ModStart> = currnode ; c -> foundtype = type ; free ( fpath ) ; <S2SV_ModStart> return 0 ; } name = next ; } free ( fpath ) ;
<S2SV_ModStart> -> file && gf -> file -> device ) { <S2SV_ModStart> gf -> file -> device -> disk ) ; }
<S2SV_ModStart> size , char * buf ) { if ( ! disk ) { eprintf ( "oops.<S2SV_blank>no<S2SV_blank>disk\\n" ) ; return 1 ; } const int blocksize = 512 <S2SV_ModEnd> ; RIOBind * iob = disk -> data ; <S2SV_ModStart> = disk -> data ; if ( bio ) { iob = bio ; } if ( <S2SV_ModEnd> iob -> read_at ( iob -> io , delta <S2SV_ModStart> ut8 * ) buf , size * blocksize ) == - 1 ) { return 1 ; } <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } RBuffer * tbuf = r_buf_new ( ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> = calloc ( 1 , n_got * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ; if ( got_table ) { ut32
<S2SV_ModStart> op_LSB ; int ret ; if ( ! data || len < 2 ) { return 0 ; } <S2SV_ModEnd> memset ( op , '\\0' , sizeof ( RAnalOp
<S2SV_ModStart> send_msg ( g , "E01" ) ; } } return - 1 ;
<S2SV_ModStart> if ( dirent . namelen != 0 ) { char * filename = grub_malloc ( dirent . namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * fdiro ; enum grub_fshelp_filetype type = <S2SV_ModStart> * fdiro ; enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> namelen , filename ) ; if ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) <S2SV_ModStart> grub_fshelp_node ) ) ; if ( ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data = diro -> data ; fdiro <S2SV_ModStart> -> inode ) ; if ( grub_errno ) { free ( filename ) ; <S2SV_ModStart> filename , type , fdiro , closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos += grub_le_to_cpu16 ( dirent . direntlen
<S2SV_ModStart> ; } } if ( fileblock < INDIRECT_BLOCKS ) { <S2SV_ModStart> -> blocks . dir_blocks [ fileblock ] ) ; }
<S2SV_ModStart> > filesize ) len = filesize - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> != 2 || ! object -> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 <S2SV_ModEnd> ] || object -> list . objects [ 1
<S2SV_ModStart> ) { if ( reg != X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> op -> scale [ reg_index ] = temp ; } <S2SV_ModStart> } else { op -> offset += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> op -> regs [ reg_index ] = X86R_UNDEFINED ; }
<S2SV_ModStart> , addrsize ) ; if ( ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil , core -> anal , romem
<S2SV_ModStart> printline ( "bytes" , NULL , 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; for ( j = 0 ; j < minsz ; j ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : buf [ j + idx ] ; r_cons_printf ( "%02x" , ch <S2SV_ModEnd> ) ; } r_cons_newline ( ) ; if ( <S2SV_ModStart> ; if ( op . val != UT64_MAX ) { <S2SV_ModStart> "0x%08" PFMT64x "\\n" , op . val ) ; } if ( op . ptr != UT64_MAX ) { <S2SV_ModEnd> printline ( "ptr" , "0x%08" PFMT64x "\\n" , op <S2SV_ModStart> "0x%08" PFMT64x "\\n" , op . ptr ) ; } <S2SV_ModStart> if ( op . refptr != - 1 ) { <S2SV_ModStart> "refptr" , "%d\\n" , op . refptr ) ; }
<S2SV_ModStart> ; bool keep = true ; if ( argReg > regsz ) { return ; <S2SV_ModEnd> } p4 = r_uleb128 ( p4 , p4_end -
<S2SV_ModStart> CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; if ( len < 2 ) { return NULL ; }
<S2SV_ModStart> ; op -> type = R_ANAL_OP_TYPE_CJMP ; if ( len > 1 ) { if ( data [ 1 ] <= 127 ) { <S2SV_ModEnd> op -> jump = addr + data [ 1 <S2SV_ModStart> data [ 1 ] + op -> size ; } else { <S2SV_ModEnd> op -> jump = addr - ( 256 - <S2SV_ModStart> [ 1 ] ) + op -> size ; } } else { op -> jump = addr ; }
<S2SV_ModStart> i ] . encoding . str_struct . string ; if ( name > 1024 ) { <S2SV_ModStart> , "DW_AT_comp_dir" , name , 0 ) ; } else { eprintf ( "Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n" , name ) ; } }
<S2SV_ModStart> if ( data ) { if ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> data + pos + real_offset , len ) ; }
<S2SV_ModStart> "cnt" , entry -> vn_cnt , 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for ( j = 0 , isum =
<S2SV_ModStart> "dyld_info" , 0 ) ; bin -> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( struct dyld_info_command ) ) ; if ( <S2SV_ModStart> sizeof ( struct dyld_info_command ) ) ; if ( bin -> dyld_info ) { if ( <S2SV_ModStart> -> size ) { bprintf ( "Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n" ) ; R_FREE <S2SV_ModEnd> ( bin -> dyld_info ) ; return false ; <S2SV_ModStart> ] , bin -> big_endian ) ; } } }
<S2SV_ModStart> -> vd_aux ; if ( vdaux < 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free ( sdb_verdef ) ; goto out_error
<S2SV_ModStart> buf [ i ] != eoc ) { i ++ <S2SV_ModEnd> ; } if ( buf [ i ] !=
<S2SV_ModStart> = NULL ; RBinWasmDataEntry * ptr = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count = sec -> count ; ut32 <S2SV_ModStart> n = 0 ; while ( i < len && len < buflen <S2SV_ModStart> -> index , & i ) ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if ( ! ( n = consume_init_expr <S2SV_ModStart> , NULL , & i ) ) ) { goto beach <S2SV_ModEnd> ; } ptr -> offset . len = n <S2SV_ModStart> -> size , & i ) ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr -> data = sec -> payload_data <S2SV_ModStart> ; r += 1 ; } return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> r = 0 ; while ( i < len && len < buflen <S2SV_ModStart> -> index , & i ) ) ) { goto beach <S2SV_ModEnd> ; } if ( ! ( consume_init_expr ( buf <S2SV_ModStart> , NULL , & i ) ) ) { goto beach <S2SV_ModEnd> ; } if ( ! ( consume_u32 ( buf <S2SV_ModStart> -> num_elem , & i ) ) ) { goto beach <S2SV_ModEnd> ; } ut32 j = 0 ; while ( <S2SV_ModStart> ; r += 1 ; } return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> = NULL ; RBinWasmGlobalEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - <S2SV_ModEnd> ( ut32 ) sec -> payload_data ; ut32 len
<S2SV_ModStart> [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false
<S2SV_ModStart> ] . class_id > bin -> header . types_size <S2SV_ModEnd> ) { continue ; } if ( is_class_idx_in_code_classes (
<S2SV_ModStart> operands [ 1 ] . regs [ 0 ] % 6 <S2SV_ModStart> ; data [ l ++ ] = 0x8b ; data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> 0 ] . reg << 3 | 0x5 ; } <S2SV_ModStart> [ l ++ ] = offset >> 24 ; } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } return l ; } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> ) { data [ l ++ ] = op <S2SV_ModStart> | 0x4 ; data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 ; } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> op -> operands [ 0 ] . reg << <S2SV_ModStart> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> op -> operands [ 0 ] . reg << <S2SV_ModStart> operands [ 0 ] . reg << 3 | <S2SV_ModEnd> op -> operands [ 1 ] . regs [
<S2SV_ModStart> ( buf [ 7 ] << 24 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModEnd> "packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d" , array_size , first_key ) ; size = <S2SV_ModStart> ( buf [ 3 ] << 8 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModEnd> , "sparse-switch-payload<S2SV_blank>%d" , array_size ) ; size = 4 <S2SV_ModStart> [ 1 ] & 0xf0 ) >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; strasm <S2SV_ModStart> << 8 ) | buf [ 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; strasm <S2SV_ModStart> << 8 ) | buf [ 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; strasm <S2SV_ModStart> = ( int ) buf [ 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i" , vA ) ; strasm = r_str_concat <S2SV_ModStart> [ 1 ] & 0xf0 ) >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB ) ; strasm <S2SV_ModStart> << 8 ) | buf [ 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#04hx" , vA , sB ) ; strasm <S2SV_ModStart> 9 ] << 56 ) ; # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%" PFMT64x , vA , vA + 1 <S2SV_ModStart> = ( int ) buf [ 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB , vC ) <S2SV_ModStart> = ( int ) buf [ 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB , vC ) <S2SV_ModStart> << 8 ) | buf [ 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB , vC ) <S2SV_ModStart> ; switch ( vA ) { case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> >> 4 ) ; break ; case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> ) >> 4 ) ; break ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) ; } strasm = r_str_concat ( <S2SV_ModStart> strasm = r_str_concat ( strasm , str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , vB ) ; strasm = r_str_concat <S2SV_ModStart> << 8 ) | buf [ 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]" , vC , vC + vA - <S2SV_ModStart> ; switch ( vA ) { case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> >> 4 ) ; break ; case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> ) >> 4 ) ; break ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) ; break ; } strasm = <S2SV_ModStart> strasm = r_str_concat ( strasm , str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , vB ) ; strasm = r_str_concat <S2SV_ModStart> ; if ( offset == - 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , vA , vB ) ; } <S2SV_ModStart> , vA , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_ModStart> vB ) ; if ( ! flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>class+%i" , vA , vB ) ; } <S2SV_ModStart> , vA , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , vA , flag_str ) ; } <S2SV_ModStart> vB ) ; if ( ! flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>field+%i" , vA , vB ) ; } <S2SV_ModStart> , vA , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , vA , flag_str ) ; } <S2SV_ModStart> ; if ( offset == - 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]" , vA , vB , vC ) <S2SV_ModStart> , vB , vC ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%" PFMT64x "]" , vA , vB , <S2SV_ModStart> ; if ( offset == - 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>thing+%i" , vA , vB ) ; } <S2SV_ModStart> , vA , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_ModStart> , vC ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , vA , vB , flag_str ) <S2SV_ModStart> , vB , flag_str ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i" , vA , vB , vC ) <S2SV_ModStart> , vC ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , vA , vB , flag_str ) <S2SV_ModStart> , vB , flag_str ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i" , vA , vB , vC ) <S2SV_ModStart> ; if ( offset == - 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , vA , vB ) ; } <S2SV_ModStart> , vA , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_ModStart> , vB ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , vC , vC + vA - <S2SV_ModStart> - 1 , flag_str ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i" , vC , vC + vA - <S2SV_ModStart> , vB ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , vC , vC + vA - <S2SV_ModStart> - 1 , flag_str ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i" , vC , vC + vA - <S2SV_ModStart> ; switch ( vA ) { case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> >> 4 ) ; break ; case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> & 0x0f ) ; break ; case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> >> 4 ) ; break ; case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f <S2SV_ModStart> ] & 0x0f ) ; break ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) ; } strasm = r_str_concat ( <S2SV_ModStart> , vB ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , flag_str , vB ) ; } <S2SV_ModStart> , flag_str , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>class+%i" , vB ) ; } } else <S2SV_ModStart> , vB ) ; if ( flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , flag_str , vB ) ; } <S2SV_ModStart> , flag_str , vB ) ; } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>method+%i" , vB ) ; } } strasm
<S2SV_ModStart> ) { int va = info -> has_va ; char * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits = info -> bits ; ut64 <S2SV_ModStart> config , "anal.arch" , arch ) ; if ( cpu && * <S2SV_ModEnd> cpu ) { r_config_set ( r -> config , <S2SV_ModStart> { r_config_set ( r -> config , "anal.cpu" , <S2SV_ModEnd> cpu ) ; } else { r_config_set ( r <S2SV_ModStart> , NULL ) ; r_core_bin_set_cur ( r , binfile ) ; free ( cpu ) ; free ( arch
<S2SV_ModStart> ( char * ) defs ) + i ; size_t vstart_off = i ; <S2SV_ModStart> -> vd_aux ; if ( vdaux < 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { sdb_free ( sdb_verdef ) ; goto out_error <S2SV_ModStart> ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; vstart_off <S2SV_ModStart> . vda_next ; vstart += aux . vda_next ; vstart_off += aux . vda_next ;
<S2SV_ModStart> ) { case '<S2SV_blank>' : case '=' : case \'"\' : case '\\\\' : case
<S2SV_ModStart> = a ; while ( * arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case '@' : case '`' : case <S2SV_ModStart> '`' : case '|' : case ';' : case '=' : case <S2SV_ModStart> : break ; default : * b ++ = ch <S2SV_ModEnd> ; break ; } arg ++ ; } *
<S2SV_ModStart> r -> bin -> prefix ) { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\"\\n" <S2SV_ModEnd> , module , symbol -> ordinal , r -> <S2SV_ModStart> , symname ) ; } else { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s\\"\\n" <S2SV_ModEnd> , module , symbol -> ordinal , symname )
<S2SV_ModStart> cmd = sc + 1 ; continue ; } char op0 = 0 ; <S2SV_ModStart> , \'"\' ) ; if ( q ) { op0 = * q ; <S2SV_ModStart> * p == \'"\' ) { cmd = p ; } else { * p = op0 <S2SV_ModEnd> ; cmd = p ; } } } else
<S2SV_ModStart> RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 <S2SV_ModEnd> * length ) { int tag , len ;
<S2SV_ModStart> revcode ; collen = 0 ; } while ( indexw < width && <S2SV_ModStart> indexw ++ ; collen -- ; } while ( indexw < width && <S2SV_ModStart> revcode ; collen = 0 ; } while ( indexw < width && <S2SV_ModStart> indexw ++ ; collen -- ; } while ( indexw < width &&
<S2SV_ModStart> uint32 length , format ; uint8 * data ; struct stream packet = * s ; <S2SV_ModStart> type , status , length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } if (
<S2SV_ModStart> STREAM s ; int length ; int tagval ; struct stream packet ; <S2SV_ModStart> s = tcp_recv ( s , length ) ; packet = * s ; <S2SV_ModStart> | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> ) || tagval != BER_TAG_OCTET_STRING ) return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p ( token , s -> p ,
<S2SV_ModStart> * rest = NULL ; char * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> <S2SV_null> static RD_BOOL mcs_parse_domain_params ( STREAM s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length <S2SV_ModStart> ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> { UNUSED ( mcs_data ) ; uint8 result ; uint32 length ; STREAM s ; struct stream packet <S2SV_ModEnd> ; RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( <S2SV_ModStart> ; if ( s == NULL ) return False ; packet = * s <S2SV_ModStart> ) ; in_uint8s ( s , length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> uint16 flags ; uint8 type ; uint8 * next_order ; struct stream packet = * s <S2SV_ModStart> ) ; in_uint8 ( s , type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( "process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream" , & packet ) ; }
<S2SV_ModStart> ( ef -> sb ) ; exfat_error ( "exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart> ) ; return - EIO ; } if ( <S2SV_ModEnd> le64_to_cpu ( ef -> sb -> sector_count ) *
<S2SV_ModStart> , var , iface ) >= sizeof ( spath ) ) return - 1 ; if ( strstr ( name , ".." ) || strchr ( name , '/'
<S2SV_ModStart> l -- ; if ( l == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , "/dev/null/" , 2 ) ; # else <S2SV_ModStart> memcpy ( own_dir , "." , 2 ) ; # endif
<S2SV_ModStart> { COMPS_HSList * subnodes ; char * key ; <S2SV_ModEnd> } * pair , * parent_pair ; pair = <S2SV_ModStart> it -> data ; free ( it ) ; <S2SV_ModEnd> for ( it = tmp_subnodes -> first ; it
<S2SV_ModStart> { COMPS_HSList * subnodes ; char * key ; <S2SV_ModEnd> } * pair , * parent_pair ; pair = <S2SV_ModStart> it -> data ; free ( it ) ; <S2SV_ModEnd> for ( it = tmp_subnodes -> first ; it
<S2SV_ModStart> { COMPS_HSList * subnodes ; char * key ; <S2SV_ModEnd> } * pair , * parent_pair ; pair =
<S2SV_ModStart> { COMPS_HSList * subnodes ; char * key ; <S2SV_ModEnd> } * pair , * parent_pair ; pair =
<S2SV_ModStart> fi , const char * dest , rpmpsm psm , int exclusive <S2SV_ModStart> 0577 ) ; wfd = Fopen ( dest , exclusive ? "wx.ufdio" : "a.ufdio" ) ; umask ( old_umask ) ; if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } <S2SV_ModEnd> } if ( Ferror ( wfd ) ) {
<S2SV_ModStart> = expandRegular ( fi , dest , psm , 1 , <S2SV_ModStart> = expandRegular ( fi , dest , psm , 1 , <S2SV_ModStart> = expandRegular ( fi , dest , psm , 0 ,
<S2SV_ModStart> = expandRegular ( fi , fn , psm , 0 ,
<S2SV_ModStart> fmode ) && S_ISLNK ( sb . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if ( S_ISLNK ( sb . st_mode )
<S2SV_ModStart> fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb <S2SV_ModStart> ( S_ISLNK ( dsb . st_mode ) ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> saveerrno ; if ( S_ISDIR ( dsb . st_mode ) && ( luid == 0 || luid == fsb -> st_uid
<S2SV_ModStart> ) { rc = fsmVerify ( fpath , fi , & sb
<S2SV_ModStart> ) { rv = zsocket_connect ( * sock , "%s" , <S2SV_ModStart> else { rv = zsocket_bind ( * sock , "%s" ,
<S2SV_ModStart> - 1 == zsocket_bind ( pData -> socket , "%s" , <S2SV_ModStart> ( - 1 == zsocket_connect ( pData -> socket , "%s"
<S2SV_ModStart> ) ; id_auth_tag_len = rb_intern_const ( "auth_tag_len" ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> { ossl_raise ( eCipherError , NULL ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> ; const EVP_CIPHER * cipher ; char * name <S2SV_ModEnd> ; name = StringValueCStr ( str ) ; GetCipherInit <S2SV_ModStart> ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL <S2SV_ModEnd> , NULL , - 1 ) != 1 )
<S2SV_ModStart> ; OPENSSL_cleanse ( iv , sizeof iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> 1 ) ossl_raise ( eCipherError , NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> "11" , & data , & str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> pool * pool , json_t * val ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , "Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting." ) ; return false ; } <S2SV_ModEnd> char * url , * port , address [ <S2SV_ModStart> , * port , address [ 256 ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> = ( char * ) json_string_value ( json_array_get ( <S2SV_ModStart> char * ) json_string_value ( json_array_get ( val , <S2SV_ModEnd> 1 ) ) ; if ( ! port ) <S2SV_ModStart> ! port ) port = pool -> stratum_port ; snprintf ( address , sizeof ( address ) <S2SV_ModEnd> , "%s:%s" , url , port ) ; if
<S2SV_ModStart> -> header_bin , header , 128 ) ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> cb1 = ( unsigned char * ) calloc (
<S2SV_ModStart> ( res_val , 2 ) ) ; if ( n2size < 1 <S2SV_ModEnd> ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ;
<S2SV_ModStart> static void build_config ( char * prefix , struct manager_ctx * manager , struct <S2SV_ModStart> fprintf ( f , "\\"password\\":\\"%s\\"" , server -> password ) ; if ( server -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , server -> method ) ; else if ( manager -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , manager -> method <S2SV_ModStart> server -> mode ) ; if ( server -> <S2SV_ModEnd> plugin ) fprintf ( f , ",\\n\\"plugin\\":\\"%s\\"" , server
<S2SV_ModStart> ) { static char cmd [ BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) ; build_config ( working_dir , manager , server ) <S2SV_ModEnd> ; memset ( cmd , 0 , BUF_SIZE ) <S2SV_ModStart> BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , "%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf" , executable , manager -> manager_address , working_dir , port , working_dir , <S2SV_ModEnd> port ) ; if ( manager -> acl !=
<S2SV_ModStart> return FALSE ; Stream_Read_UINT32 ( s , scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
<S2SV_ModStart> rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off = tsk_getu16 ( fs -> endian <S2SV_ModStart> rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off = tsk_getu16 ( fs -> endian
<S2SV_ModStart> endian , key -> key_len ) ; if ( keylen >= nodesize - rec_off <S2SV_ModEnd> ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( <S2SV_ModStart> PRIu16 ")" , rec , cur_node , keylen , ( nodesize - rec_off ) <S2SV_ModEnd> ) ; free ( node ) ; return 1
<S2SV_ModStart> -> tokenlen ) ; if ( p -> tokenpos >= ( p -> tokenlen - 1 ) <S2SV_ModEnd> ) { p -> tokenlen = p -> tokenlen
<S2SV_ModStart> key , char * * where TSRMLS_DC ) { int o_name_len = name_len ; char * buf , * buf2 <S2SV_ModEnd> , * d , * d_url ; int l <S2SV_ModStart> * d , * d_url ; int l ; <S2SV_ModEnd> buf = estrndup ( name , name_len ) ; <S2SV_ModStart> buf = estrndup ( name , name_len ) ; <S2SV_ModEnd> name_len = php_url_decode ( buf , name_len ) ; <S2SV_ModStart> , name_len + 1 ) ) { decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( * where , name , o_name_len ) <S2SV_ModStart> 1 ) ) { goto decrypt_return_plain ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode ( buf2 , value_len ) ; <S2SV_ModStart> l ; efree ( d_url ) ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return * where ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> value_len , char * key TSRMLS_DC ) { char * buf , * buf2 <S2SV_ModEnd> , * d , * d_url ; int l <S2SV_ModStart> * d , * d_url ; int l ; <S2SV_ModEnd> buf = estrndup ( name , name_len ) ; <S2SV_ModStart> buf = estrndup ( name , name_len ) ; <S2SV_ModEnd> name_len = php_url_decode ( buf , name_len ) ; <S2SV_ModStart> , name_len + 1 ) ) { encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup ( value , value_len ) ; } <S2SV_ModStart> 1 ) ) { goto encrypt_return_plain ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode ( buf2 , value_len ) ; <S2SV_ModStart> & l ) ; efree ( d ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> + req [ offset + 4 ] ; int nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> start_bits ; if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 <S2SV_ModStart> + req [ offset + 4 ] ; int nb_bytes = req [ offset + 5 ] ; int <S2SV_ModStart> start_registers ; if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8
<S2SV_ModStart> ( __force __le16 ) msg_tmp . controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; if ( peekonly ) { <S2SV_ModEnd> goto peekout ; } if ( ( msg_tmp . <S2SV_ModStart> space_rem < sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } <S2SV_ModEnd> saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int enable ( bool start_restricted ) { LOG_INFO ( LOG_TAG , "%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d" , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> ; if ( ! interface_ready ( ) ) return
<S2SV_ModStart> int remove_bond ( const bt_bdaddr_t * bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
<S2SV_ModStart> LEGACY_CONFIG_FILE_PATH ) ; } btif_config_remove_unpaired ( config ) ; if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ;
<S2SV_ModStart> , link_key , sizeof ( LINK_KEY ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( "%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , "Restricted" , 1 ) ; }
<S2SV_ModStart> return ; } status = sBtInterface -> enable ( false
<S2SV_ModStart> ; CALL_AND_WAIT ( error = bt_interface -> enable ( false
<S2SV_ModStart> discover ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> discoverable ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> ) ; } CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> up ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> get_name ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> set_name ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> sco_listen ) { CALL_AND_WAIT ( bt_interface -> enable ( false <S2SV_ModStart> ) ; } CALL_AND_WAIT ( bt_interface -> enable ( false
<S2SV_ModStart> , dump_a2dp_ctrl_event ( cmd ) ) ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL )
<S2SV_ModStart> buffer , int length ) { int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) <S2SV_ModStart> if ( errno == EINTR ) { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> common -> ctrl_fd , buffer , length , MSG_NOSIGNAL )
<S2SV_ModStart> 0 ) break ; ERROR ( "error<S2SV_blank>:<S2SV_blank>a2dp<S2SV_blank>not<S2SV_blank>ready,<S2SV_blank>wait<S2SV_blank>250<S2SV_blank>ms<S2SV_blank>and<S2SV_blank>retry" ) ; TEMP_FAILURE_RETRY ( usleep ( 250000 ) <S2SV_ModEnd> ) ; skt_disconnect ( common -> ctrl_fd ) ; <S2SV_ModStart> ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; } TEMP_FAILURE_RETRY ( usleep ( 250000 ) ) <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> goto err_open ; } DEBUG ( "success" ) ; TEMP_FAILURE_RETRY ( usleep ( 250000 ) <S2SV_ModEnd> ) ; return 0 ; err_open : free (
<S2SV_ModStart> ) ; DEBUG ( "emulate<S2SV_blank>a2dp<S2SV_blank>read<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)" , us_delay ) ; TEMP_FAILURE_RETRY ( usleep ( us_delay ) <S2SV_ModEnd> ) ; pthread_mutex_unlock ( & in -> common .
<S2SV_ModStart> ) ; DEBUG ( "emulate<S2SV_blank>a2dp<S2SV_blank>write<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)" , us_delay ) ; TEMP_FAILURE_RETRY ( usleep ( us_delay ) <S2SV_ModEnd> ) ; pthread_mutex_unlock ( & out -> common .
<S2SV_ModStart> , NULL ) ; if ( ( read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> recv ( fd , p , len , MSG_NOSIGNAL )
<S2SV_ModStart> ; pfd . events = POLLOUT ; if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 500 ) <S2SV_ModEnd> ) == 0 ) return 0 ; ts_log ( <S2SV_ModStart> , NULL ) ; if ( ( sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> send ( fd , p , len , MSG_NOSIGNAL )
<S2SV_ModStart> fd < 0 ) { p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) <S2SV_ModEnd> ; if ( p_dev -> fd < 0 ) <S2SV_ModStart> btif_hh_cb . device_num ++ ; p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) <S2SV_ModEnd> ; if ( p_dev -> fd < 0 )
<S2SV_ModStart> while ( p_dev -> hh_keep_polling ) { ret = TEMP_FAILURE_RETRY ( poll ( pfds , 1 , 50 ) <S2SV_ModEnd> ) ; if ( ret < 0 ) {
<S2SV_ModStart> __FUNCTION__ ) return - 1 ; } ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> fd , & ev , sizeof ( ev )
<S2SV_ModStart> struct uhid_event * ev ) { ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( fd , ev , sizeof ( * ev )
<S2SV_ModStart> mcl_idx , mdl_idx , data_size ) ; r = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , p_dcb -> p_rx_pkt , data_size , 0 ) )
<S2SV_ModStart> , val ) ; if ( ( addr_fd = TEMP_FAILURE_RETRY ( open ( val , O_RDONLY ) <S2SV_ModEnd> ) ) != - 1 ) { memset ( <S2SV_ModStart> , 0 , sizeof ( val ) ) ; TEMP_FAILURE_RETRY ( read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) <S2SV_ModEnd> ) ; if ( ( string_to_bdaddr ( val ,
<S2SV_ModStart> BTIF_TRACE_ERROR ( "Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>" ) ; btif_config_flush ( ) ; TEMP_FAILURE_RETRY ( usleep ( 100000 ) <S2SV_ModEnd> ) ; kill ( getpid ( ) , SIGKILL
<S2SV_ModStart> ( "%s:<S2SV_blank>Sending<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>to<S2SV_blank>kernel<S2SV_blank>" "indicating<S2SV_blank>lock<S2SV_blank>key<S2SV_blank>state<S2SV_blank>0x%x" , __FUNCTION__ , keylockstates ) ; TEMP_FAILURE_RETRY ( usleep ( 200000 ) <S2SV_ModEnd> ) ; toggle_os_keylockstates ( p_dev -> fd , keylockstates
<S2SV_ModStart> , hidreport , sizeof ( hidreport ) ) ; TEMP_FAILURE_RETRY ( usleep ( 200000 ) ) <S2SV_ModEnd> ; memset ( hidreport , 0 , 9 )
<S2SV_ModStart> btif_hl_signal_select_exit ; BTIF_TRACE_DEBUG ( "btif_hl_signal_select_exit" ) ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & sig_on , sizeof ( sig_on ) , 0 )
<S2SV_ModStart> = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> sig_on , sizeof ( sig_on ) , 0 ) )
<S2SV_ModStart> p_dcb ) { int r = ( int ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> p_tx_pkt , p_dcb -> mtu , MSG_DONTWAIT ) )
<S2SV_ModStart> org_set ; max_curr_s = max_org_s ; int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & curr_set , NULL , NULL , NULL ) )
<S2SV_ModStart> sig_recv = 0 ; BTIF_TRACE_DEBUG ( "btif_hl_select_wake_reset" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) )
<S2SV_ModStart> = btif_hl_signal_select_wakeup ; BTIF_TRACE_DEBUG ( "btif_hl_select_wakeup" ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> sig_on , sizeof ( sig_on ) , 0 ) )
<S2SV_ModStart> clonedev = "/dev/tun" ; if ( ( fd = TEMP_FAILURE_RETRY ( open ( clonedev , O_RDWR ) <S2SV_ModEnd> ) ) < 0 ) { BTIF_TRACE_DEBUG ( "could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%s,<S2SV_blank>err:%d" <S2SV_ModStart> , IFNAMSIZ ) ; if ( ( err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , TUNSETIFF , ( void * ) & ifr ) <S2SV_ModStart> ) ) == 0 ) { int flags = TEMP_FAILURE_RETRY ( fcntl ( fd , F_GETFL , 0 ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> fcntl ( fd , F_SETFL , flags | O_NONBLOCK <S2SV_ModStart> fcntl ( fd , F_SETFL , flags | O_NONBLOCK )
<S2SV_ModStart> , buf , len ) ; int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> tap_fd , packet , len + sizeof ( tETH_HDR )
<S2SV_ModStart> ! btpan_cb . congest_packet_size ) { ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) <S2SV_ModStart> ; ufd . revents = 0 ; if ( TEMP_FAILURE_RETRY ( poll ( & ufd , 1 , 0 ) <S2SV_ModEnd> ) <= 0 || IS_EXCEPTION ( ufd . revents
<S2SV_ModStart> ) ; ifr . ifr_flags &= ~ IFF_UP ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , SIOCSIFFLAGS , ( caddr_t ) & ifr ) )
<S2SV_ModStart> devname , IFNAMSIZ - 1 ) ; err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCGIFHWADDR , & ifr ) <S2SV_ModEnd> ) ; if ( err < 0 ) { <S2SV_ModStart> 0 ] &= ~ 0x01 ; } err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) <S2SV_ModStart> ; ifr . ifr_flags |= IFF_MULTICAST ; err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sk , SIOCSIFFLAGS , ( caddr_t ) & ifr )
<S2SV_ModStart> ) ; if ( uinput_fd > 0 ) { TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) <S2SV_ModEnd> ) ; close ( uinput_fd ) ; uinput_fd =
<S2SV_ModStart> code ; event . value = value ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & event , sizeof ( event ) ) )
<S2SV_ModStart> < MAX_UINPUT_PATHS ; x ++ ) { fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> open ( uinput_dev_path [ x ] , O_RDWR ) ) <S2SV_ModStart> . id . version = 0x0000 ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & dev , sizeof ( dev ) ) ) <S2SV_ModStart> ( fd ) ; return - 1 ; } TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ) ; TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_REL ) ) ; TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_SYN ) <S2SV_ModEnd> ) ; for ( x = 0 ; key_map <S2SV_ModStart> ] . name != NULL ; x ++ ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( ioctl ( fd , UI_DEV_CREATE , NULL ) <S2SV_ModStart> ( ioctl ( fd , UI_DEV_CREATE , NULL ) )
<S2SV_ModStart> , & len ) ) { int sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sock -> our_fd , buf , len , MSG_DONTWAIT )
<S2SV_ModStart> ( ! slot ) goto out ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ioctl ( slot -> fd , FIONREAD , size )
<S2SV_ModStart> ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> slot -> fd , FIONREAD , & size ) ) == 0 && size ) ) { <S2SV_ModEnd> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id <S2SV_ModStart> slot -> rfc_handle , slot -> id ) ; } <S2SV_ModStart> int size = 0 ; if ( need_close || TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( slot -> fd , FIONREAD , & size )
<S2SV_ModStart> == 0 ) return SENT_ALL ; ssize_t sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> p_buf -> offset , p_buf -> len , MSG_DONTWAIT )
<S2SV_ModStart> sockaddr_un client_address ; socklen_t clen ; int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sockaddr * ) & client_address , & clen ) )
<S2SV_ModStart> ( "adding<S2SV_blank>fd:%d,<S2SV_blank>flags:0x%x" , fd , flags ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> cmd , sizeof ( cmd ) , 0 ) )
<S2SV_ModStart> 0 , 0 , 0 } ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & cmd , sizeof ( cmd ) , 0 )
<S2SV_ModStart> size_send ) ; return FALSE ; } } return TEMP_FAILURE_RETRY ( <S2SV_ModStart> . cmd_fdw , cmd_send , size_send , 0 ) )
<S2SV_ModStart> , 0 , 0 , 0 } ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> cmd , sizeof ( cmd ) , 0 ) )
<S2SV_ModStart> , 0 , 0 , 0 } ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> cmd , sizeof ( cmd ) , 0 ) )
<S2SV_ModStart> ts [ h ] . cmd_fdr ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & cmd , sizeof ( cmd ) , MSG_WAITALL )
<S2SV_ModStart> int blocking ) { int opts ; opts = TEMP_FAILURE_RETRY ( fcntl ( s , F_GETFL ) <S2SV_ModEnd> ) ; if ( opts < 0 ) APPL_TRACE_ERROR <S2SV_ModStart> O_NONBLOCK ; else opts |= O_NONBLOCK ; if ( TEMP_FAILURE_RETRY ( fcntl ( s , F_SETFL , opts ) <S2SV_ModEnd> ) < 0 ) APPL_TRACE_ERROR ( "set<S2SV_blank>blocking<S2SV_blank>(%s)" , strerror
<S2SV_ModStart> ; while ( r ) { do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> recv ( sock_fd , buf , r , MSG_WAITALL )
<S2SV_ModStart> ; while ( s ) { do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> send ( sock_fd , buf , s , 0 )
<S2SV_ModStart> . msg_iovlen = 1 ; do { ret = TEMP_FAILURE_RETRY ( sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) <S2SV_ModEnd> ) ; } while ( ret < 0 &&
<S2SV_ModStart> ) ; int err ; do { err = TEMP_FAILURE_RETRY ( nanosleep ( & delay , & delay ) <S2SV_ModEnd> ) ; } while ( err == - 1
<S2SV_ModStart> length ) { if ( logfile_fd != INVALID_FD ) TEMP_FAILURE_RETRY ( write ( logfile_fd , data , length ) <S2SV_ModEnd> ) ; btsnoop_net_write ( data , length ) ;
<S2SV_ModStart> strerror ( errno ) ) ; } logfile_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) <S2SV_ModStart> ) ; is_logging = false ; return ; } TEMP_FAILURE_RETRY ( write ( logfile_fd , "btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea" , 16 ) <S2SV_ModEnd> ) ; } else { if ( logfile_fd !=
<S2SV_ModStart> ( client_socket_ != - 1 ) { if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> send ( client_socket_ , data , length , 0 )
<S2SV_ModStart> for ( ; ; ) { int client_socket = TEMP_FAILURE_RETRY ( accept ( listen_socket_ , NULL , NULL ) <S2SV_ModEnd> ) ; if ( client_socket == - 1 ) <S2SV_ModStart> ( & client_socket_ ) ; client_socket_ = client_socket ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> send ( client_socket_ , "btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea" , 16 , 0 )
<S2SV_ModStart> ( length > 0 ) { ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> write ( uart_fd , data + transmitted_length , length )
<S2SV_ModStart> ( length > 0 ) { ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> write ( fd , data + transmitted_length , length )
<S2SV_ModStart> ; } LOG_ERROR ( "%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process." , __func__ ) ; TEMP_FAILURE_RETRY ( usleep ( 10000 ) <S2SV_ModEnd> ) ; kill ( getpid ( ) , SIGKILL
<S2SV_ModStart> ; assert ( * filename != '\\0' ) ; int dir_fd = - 1 ; FILE * fp = NULL ; static const char * temp_file_ext = ".new" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * temp_filename = osi_calloc ( temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , "%s%s" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname ) ; if ( ! directoryname ) { LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> fp = fopen ( temp_filename , "wt" ) ; <S2SV_ModStart> const section_t * ) list_node ( node ) ; if ( <S2SV_ModStart> ( fp , "[%s]\\n" , section -> name ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> for ( const list_node_t * enode = list_begin ( <S2SV_ModStart> const entry_t * ) list_node ( enode ) ; if ( <S2SV_ModStart> , entry -> key , entry -> value ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> } if ( list_next ( node ) != list_end <S2SV_ModStart> ) != list_end ( config -> sections ) ) { if ( fputc ( '\\n' , fp ) == EOF ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( fclose ( fp ) == EOF ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModEnd> ; if ( chmod ( temp_filename , S_IRUSR | <S2SV_ModStart> ( errno ) ) ; goto error ; } if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } osi_free ( temp_filename ) ; osi_free ( temp_dirname ) ; return true ; error : unlink ( temp_filename ) ; if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; osi_free ( temp_filename ) ; osi_free ( temp_dirname <S2SV_ModEnd> ) ; return false ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = 0 ; timeout . tv_usec = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> read_fds , NULL , NULL , & timeout ) )
<S2SV_ModStart> buffer -> offset = 0 ; int bytes_read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> inbound_fd , buffer -> data , reader -> buffer_size )
<S2SV_ModStart> -> fd != INVALID_FD ) ; int flags = TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_GETFL ) <S2SV_ModEnd> ) ; if ( flags == - 1 ) <S2SV_ModStart> ) ) ; return false ; } if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) <S2SV_ModStart> == - 1 ) return false ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> fcntl ( semaphore -> fd , F_SETFL , flags )
<S2SV_ModStart> ( socket != NULL ) ; int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> accept ( socket -> fd , NULL , NULL )
<S2SV_ModStart> ) ; int size = 0 ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( socket -> fd , FIONREAD , & size )
<S2SV_ModStart> ; assert ( buf != NULL ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> fd , buf , count , MSG_DONTWAIT ) )
<S2SV_ModStart> ; assert ( buf != NULL ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> fd , buf , count , MSG_DONTWAIT ) )
<S2SV_ModStart> ( header ) = fd ; ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( socket -> fd , & msg , MSG_DONTWAIT )
<S2SV_ModStart> sin_port = htons ( 8873 ) ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) & addr , sizeof ( addr ) ) ) == - 1 ) goto error ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( send ( sock , & type , 1 <S2SV_ModStart> sock , & type , 1 , 0 ) ) != 1 ) goto error ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( send ( sock , & length , 2 <S2SV_ModStart> sock , & length , 2 , 0 ) ) != 2 ) goto error ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( send ( sock , packet , length , <S2SV_ModStart> send ( sock , packet , length , 0 )
<S2SV_ModStart> . events = POLLIN | POLLHUP ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) <S2SV_ModStart> ( ) ; return 0 ; } n = TEMP_FAILURE_RETRY ( <S2SV_ModStart> + n_read , len - n_read , 0 ) )
<S2SV_ModStart> msglen ) ; UIPC_LOCK ( ) ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> [ ch_id ] . fd , p_buf , msglen )
<S2SV_ModStart> ; pfd . events = POLLIN ; if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 0 ) <S2SV_ModEnd> ) == 0 ) { BTIF_TRACE_EVENT ( "accept<S2SV_blank>poll<S2SV_blank>timeout" ) <S2SV_ModStart> - 1 ; } if ( ( fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> struct sockaddr * ) & remote , & len )
<S2SV_ModStart> read_set ) ) { char sig_recv = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) )
<S2SV_ModStart> ; } while ( 1 ) { ret = TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 1 ) <S2SV_ModEnd> ) ; BTIF_TRACE_VERBOSE ( "%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d" , __FUNCTION__ , pfd <S2SV_ModStart> , __FUNCTION__ , ret ) ; return ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) )
<S2SV_ModStart> . read_set = uipc_main . active_set ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> uipc_main . read_set , NULL , NULL , NULL )
<S2SV_ModStart> sig_on = 1 ; BTIF_TRACE_EVENT ( "UIPC<S2SV_blank>SEND<S2SV_blank>WAKE<S2SV_blank>UP" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> sig_on , sizeof ( sig_on ) , 0 ) )
<S2SV_ModStart> ( UINT16 len , UINT8 * data ) { UINT16 buflen = <S2SV_ModEnd> ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof <S2SV_ModStart> len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , "28672558" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen
<S2SV_ModStart> , accept ) ; if ( pin_code == NULL || pin_len > PIN_CODE_LEN
<S2SV_ModStart> != NULL ) ; alarm_cancel ( alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ) ; alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb <S2SV_ModEnd> , NULL ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } btif_config_devcache_cleanup ( ) ;
<S2SV_ModStart> -> parent , buf , bufsize - namelen - 1 <S2SV_ModEnd> ) ; if ( pathlen < 0 ) {
<S2SV_ModStart> ] ; long int inode ; char file [ 1024 <S2SV_ModEnd> ] ; strlcat ( info -> path , "maps" <S2SV_ModStart> goto out ; while ( fscanf ( maps , "%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\n" <S2SV_ModEnd> , & offset , device , & inode ,
<S2SV_ModStart> native_handle_create ( int numFds , int numInts ) { if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = sizeof ( native_handle_t ) + ( <S2SV_ModEnd> sizeof ( int ) * ( numFds + numInts <S2SV_ModStart> ( int ) * ( numFds + numInts ) ) ; native_handle_t * h = malloc ( mallocSize
<S2SV_ModStart> type ) ; return ERROR ; } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , entry . type , entry . count ) != OK ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <S2SV_ModEnd> if ( data_size != 0 ) { camera_metadata_data_t *
<S2SV_ModStart> if ( dst == NULL || src == NULL ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count
<S2SV_ModStart> __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( "%s:<S2SV_blank>Data<S2SV_blank>count<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>capacity<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , "30591838"
<S2SV_ModStart> r < 0 ) return r ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> , false , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ) return - errno ; if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r = fchmod ( fd , mode
<S2SV_ModStart> # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , "Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n" , tmp_dir ) ; exit ( 1 ) ; } # endif
<S2SV_ModStart> tmp_dir == '\\0' ) ) tmp_dir = "/tmp" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , "/w3m-XXXXXX" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
<S2SV_ModStart> 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; }
<S2SV_ModStart> ; int i , attr_id = 0 , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> l = l -> next ) { if ( l == NULL ) break ; if (
<S2SV_ModStart> MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
<S2SV_ModStart> ptr ; int newlen ; newlen = x -> area_size <S2SV_ModEnd> * 6 / 5 ; if ( newlen == <S2SV_ModStart> / 5 ; if ( newlen == x -> area_size <S2SV_ModEnd> ) newlen += 2 ; x -> ptr =
<S2SV_ModStart> Mat_VarFree ( matvar ) ; return NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> = '\\0' ; plen -= nread ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device" ) ; goto error ; } if (
<S2SV_ModStart> ifdef HAVE_GETSPNAM struct spwd * usersp ; # endif char * crypt_password ; <S2SV_ModStart> else user_password = user -> pw_passwd ; # endif crypt_password = crypt ( password , user_password ) ; if ( crypt_password == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; return - 1 ; } if ( strcmp ( user_password , crypt_password <S2SV_ModEnd> ) != 0 ) { pcap_snprintf ( errbuf ,
<S2SV_ModStart> , char * errbuf ) { # ifdef _WIN32 DWORD error ; HANDLE Token ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; <S2SV_ModEnd> if ( LogonUser ( username , "." , password <S2SV_ModStart> LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; error = GetLastError ( ) ; if ( error != ERROR_LOGON_FAILURE ) { pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , "LogonUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; } return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else int error ; <S2SV_ModEnd> struct passwd * user ; char * user_password ; <S2SV_ModStart> NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return - 1 ; } # ifdef <S2SV_ModStart> NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return - 1 ; } user_password = <S2SV_ModStart> else user_password = user -> pw_passwd ; # endif errno = 0 ; <S2SV_ModStart> ) ; if ( crypt_password == NULL ) { error = errno ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; if ( error == 0 ) { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed" ) ; } else { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) ) ; } <S2SV_ModEnd> return - 1 ; } if ( strcmp ( <S2SV_ModStart> 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return - 1 ; } if ( <S2SV_ModStart> ( setuid ( user -> pw_uid ) ) { error = errno ; pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , error , "setuid" ) ; rpcapd_log ( LOGPRIO_ERROR , "setuid()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) <S2SV_ModEnd> ) ; return - 1 ; } return 0
<S2SV_ModStart> pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> return - 1 ; } return 0 ; } replylen = 0 ; <S2SV_ModStart> nif ++ ; if ( d -> description ) replylen <S2SV_ModEnd> += strlen ( d -> description ) ; if <S2SV_ModStart> description ) ; if ( d -> name ) replylen += strlen ( d -> name ) ; replylen <S2SV_ModEnd> += sizeof ( struct rpcap_findalldevs_if ) ; for ( <S2SV_ModStart> : # ifdef AF_INET6 case AF_INET6 : # endif replylen <S2SV_ModEnd> += ( sizeof ( struct rpcap_sockaddr ) * 4 <S2SV_ModStart> ) sendbuf , ver , RPCAP_MSG_FINDALLIF_REPLY , nif , replylen <S2SV_ModEnd> ) ; for ( d = alldevs ; d
<S2SV_ModStart> * shbp ) + sizeof ( struct block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof ( * bhdrp ) + sizeof ( <S2SV_ModStart> * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX <S2SV_ModEnd> ) ; * err = 1 ; return (
<S2SV_ModStart> 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" <S2SV_ModEnd> PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize , bytes_to_read , amt_read ) ;
<S2SV_ModStart> { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof ( * bhdrp ) + sizeof (
<S2SV_ModStart> const u_char * mask ; if ( len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" <S2SV_ModEnd> , len ) ) ; else { mask =
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> total_subobj_len > 0 && hexdump == FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> . f * 8 / 1000000 ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
<S2SV_ModStart> ; } msgptr ; int msg_len_valid = 0 ; if ( is_ipv6 ) { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 = ( const struct olsr_msg6 * <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ; } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> } break ; case OLSR_NAMESERVICE_MSG : { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; addr_size = 4 ; if ( is_ipv6 ) addr_size = 16 ; name_entries_valid = 0 <S2SV_ModEnd> ; if ( ( name_entries > 0 ) && <S2SV_ModStart> ) ) <= msg_tlen ) ) name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s" , EXTRACT_16BITS
<S2SV_ModStart> int length ) { u_char * b , * t , c ; const u_char * s <S2SV_ModEnd> ; int i , proto ; const void * <S2SV_ModStart> length <= 0 ) return ; b = ( u_char <S2SV_ModEnd> * ) malloc ( length ) ; if ( <S2SV_ModStart> == NULL ) return ; for ( s = <S2SV_ModEnd> p , t = b , i = length <S2SV_ModStart> b , i = length ; i > 0 && ND_TTEST ( * s ) <S2SV_ModStart> ( c == 0x7d ) { if ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> i -- ; c = * s ++ ^ <S2SV_ModStart> -- ; c = * s ++ ^ 0x20 <S2SV_ModEnd> ; } * t ++ = c ; }
<S2SV_ModStart> "...)" ) ) ; break ; case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>?)" ) ) ; break ; }
<S2SV_ModStart> { case ARPOP_REQUEST : ND_PRINT ( ( ndo , "who-has<S2SV_blank>" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if ( ATMTHRD_LEN ( ap ) != <S2SV_ModStart> ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro ) ; break ; case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>" <S2SV_ModEnd> ) ) ; atmarp_addr_print ( ndo , ATMSHA ( <S2SV_ModStart> ap ) ) ; ND_PRINT ( ( ndo , "at<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break ; case ARPOP_NAK : ND_PRINT ( <S2SV_ModStart> ; case ARPOP_NAK : ND_PRINT ( ( ndo , "for<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break ; default : ND_DEFAULTPRINT ( (
<S2SV_ModStart> tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
<S2SV_ModStart> if ( v3 ) { ND_TCHECK ( dp [ 4 <S2SV_ModEnd> ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%" <S2SV_ModStart> ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank><%s>" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) ) ) ; } } else {
<S2SV_ModStart> 3 ) ) / sizeof ( uint32_t ) ; ND_TCHECK ( dp [ 0 ] <S2SV_ModEnd> ) ; astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS
<S2SV_ModStart> case TUNNEL_PASS : if ( length < 3 ) goto trunc ; <S2SV_ModEnd> if ( * data && ( * data <= <S2SV_ModStart> 0x1F ) { if ( length < 1 ) goto trunc ; <S2SV_ModEnd> if ( * data ) ND_PRINT ( ( ndo <S2SV_ModStart> length -- ; } break ; case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> break ; } for ( i = 0 ; i < length && * data <S2SV_ModEnd> ; i ++ , data ++ ) ND_PRINT (
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; return hdrlen ; } if ( caplen
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; else isoclns_print ( ndo , p , <S2SV_ModStart> ; else isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; break ; default : if ( !
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; return ( 1 ) ; case ETHERTYPE_PPPOED
<S2SV_ModStart> ndo , p - 1 , length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : <S2SV_ModEnd> if ( ! ndo -> ndo_eflag ) fr_hdr_print ( <S2SV_ModStart> ) fr_hdr_print ( ndo , length + hdr_len , addr_len <S2SV_ModEnd> , dlci , flags , nlpid ) ; if <S2SV_ModStart> , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p <S2SV_ModEnd> , length ) ; } return hdr_len ; trunc
<S2SV_ModStart> ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp <S2SV_ModEnd> , NULL , NULL ) ; break ; default
<S2SV_ModStart> ndo , const uint8_t * p , u_int length ) { if ( ! ND_TTEST ( * p ) <S2SV_ModEnd> ) { ND_PRINT ( ( ndo , "|OSI" ) <S2SV_ModStart> ) print_unknown_data ( ndo , p , "\\n\\t" , length <S2SV_ModEnd> ) ; break ; case NLPID_ESIS : esis_print ( <S2SV_ModStart> ) print_unknown_data ( ndo , p , "\\n\\t" , length <S2SV_ModEnd> ) ; break ; case NLPID_NULLNS : ND_PRINT ( <S2SV_ModStart> : ",<S2SV_blank>" , length ) ) ; if ( length <S2SV_ModEnd> > 1 ) print_unknown_data ( ndo , p , <S2SV_ModStart> ) print_unknown_data ( ndo , p , "\\n\\t" , length <S2SV_ModEnd> ) ; break ; } } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; return ( hdrlen ) ; } if
<S2SV_ModStart> PT_OSI : isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; break ; default : break ; }
<S2SV_ModStart> PPP_OSI : isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST
<S2SV_ModStart> { const u_char * buf2 ; depth ++ ; if ( depth == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else
<S2SV_ModStart> ndo , "[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid ; switch ( subobj_type ) {
<S2SV_ModStart> ( & bp -> bp_secs ) ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
<S2SV_ModStart> { case IPOPT_EOL : return ; case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , cp , option_len ) == - <S2SV_ModStart> - 1 ) goto trunc ; break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options * ndo , register const u_char <S2SV_ModStart> ndo , "[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; return ( 0 ) <S2SV_ModStart> ( ndo , "[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ndo , "[bad<S2SV_blank>ptr<S2SV_blank>%u]" , cp [ 2 ] ) ) ; ND_TCHECK ( cp [ 3 ] <S2SV_ModStart> if ( ptr == len ) type = "<S2SV_blank>^<S2SV_blank>" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ND_PRINT ( ( ndo , "}" ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> const struct ip6_hdr * ) bp2 ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if ( ndo -> ndo_vflag ) {
<S2SV_ModStart> ( opli > 0 ) { ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>(0x%02x)" , <S2SV_ModStart> ) ; pptr += opli ; } trunc : ND_PRINT ( ( ndo , "[|esis]" ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = FALSE ; u_int sublen ; u_int tval ; u_int <S2SV_ModEnd> i ; if ( tlv_len < 4 ) { <S2SV_ModStart> + 5 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u" <S2SV_ModEnd> , tval >> 5 , ( tval >> 3 <S2SV_ModStart> ) & 0x03 , ( tval & 0x07 ) <S2SV_ModEnd> , EXTRACT_16BITS ( tptr + i + 5 )
<S2SV_ModStart> 0 ; while ( i < length ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> ndo , "<S2SV_blank>(%u)" , optlen + 4 ) ) ; if ( i + 4 + optlen > length ) return - 1
<S2SV_ModStart> ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; ND_TCHECK_32BITS ( cp ) ;
<S2SV_ModStart> NULL ; register int compress = 0 ; int elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> if ( ! ND_TTEST2 ( * cp , 1 <S2SV_ModStart> , 1 ) ) return ( NULL ) ; offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , "<BAD<S2SV_blank>PTR>" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset <S2SV_ModEnd> ; if ( ( l = labellen ( ndo <S2SV_ModStart> NULL ) ; i = * cp ++ ; <S2SV_ModEnd> continue ; } if ( ( i & INDIR_MASK <S2SV_ModStart> ( NULL ) ; } cp += l ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "." ) ) ; <S2SV_ModStart> return ( NULL ) ; i = * cp <S2SV_ModEnd> ++ ; if ( ! compress ) rp +=
<S2SV_ModStart> while ( tmp && alen < tmp ) { ND_TCHECK2 ( * tptr , alen ) ;
<S2SV_ModStart> * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t nitems ; tptr = pptr ; <S2SV_ModStart> * ) pptr ; ND_TCHECK ( * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> = ( const struct vqp_obj_tlv_t * ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> } ND_TCHECK2 ( * tptr , vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; switch ( vqp_obj_type ) { case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%s<S2SV_blank>(0x%08x)" , ipaddr_string ( <S2SV_ModStart> ; break ; case VQP_OBJ_MAC_ADDRESS : case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
<S2SV_ModStart> = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , <S2SV_ModStart> ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
<S2SV_ModStart> if ( in_cksum ( vec , 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> & bp [ 6 ] ) ) ) ; }
<S2SV_ModStart> ) ( io + nid ) ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp , len ) ) { ND_PRINT
<S2SV_ModStart> ) ; while ( -- n >= 0 && <S2SV_ModEnd> ND_TTEST ( * ps ) ) { const struct <S2SV_ModStart> + ps -> nid ; io < ie && <S2SV_ModEnd> ND_TTEST ( * io ) ; ++ io )
<S2SV_ModStart> DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; }
<S2SV_ModStart> ; if ( ! ( opt_len == 12 && ( flags & TH_SYN ) <S2SV_ModEnd> ) && ! ( opt_len == 20 && (
<S2SV_ModStart> const struct mp_dss * ) opt ; if ( opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> flags & TH_SYN ) return 0 ; if ( <S2SV_ModStart> , "<S2SV_blank>fin" ) ) ; opt += 4 ; opt_len -= 4 ; <S2SV_ModStart> if ( mdss -> flags & MP_DSS_a ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 8 ; opt_len -= 8 ; } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; <S2SV_ModStart> if ( mdss -> flags & MP_DSS_m ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 8 ; opt_len -= 8 ; } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "<S2SV_blank>subseq<S2SV_blank>%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>csum<S2SV_blank>0x%x" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! ( opt_len == 12 && ( flags & TH_SYN ) <S2SV_ModEnd> ) && ! ( opt_len == 16 && ( <S2SV_ModStart> ) ) && ! ( opt_len == 24 && ( flags & TH_ACK ) <S2SV_ModEnd> ) ) return 0 ; if ( opt_len !=
<S2SV_ModStart> , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
<S2SV_ModStart> , "(altcoa:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> ) ] ; char * pos = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; for ( i = 1 ; i <= sysid_len <S2SV_ModEnd> ; i ++ ) { snprintf ( pos ,
<S2SV_ModStart> } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> 1 ) / 4 ; te_class ++ ) { <S2SV_ModEnd> bw . i = EXTRACT_32BITS ( tptr ) ;
<S2SV_ModStart> netdissect_options * ndo , register const u_char * tptr , const u_int length <S2SV_ModStart> { u_int network_addr_type ; u_int hexdump = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data" ) ) ; return hexdump ; } <S2SV_ModStart> ; switch ( network_addr_type ) { case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ) ) ) ; break ; case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; }
<S2SV_ModStart> . ssid ) - 1 ) return 0 ; <S2SV_ModEnd> memcpy ( & ssid . ssid , p + <S2SV_ModStart> . text ) - 1 ) return 0 ; <S2SV_ModEnd> memcpy ( & challenge . text , p + <S2SV_ModStart> > sizeof rates . rate ) return 0 ; <S2SV_ModEnd> memcpy ( & rates . rate , p + <S2SV_ModStart> memcpy ( tim . bitmap , p + offset <S2SV_ModEnd> , tim . length - 3 ) ; offset
<S2SV_ModStart> , "%s" , tstr ) ) ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> icmp6_data16 [ 0 ] ) ) ) ; ND_TCHECK ( dp -> icmp6_data16 [ 1 ] ) ;
<S2SV_ModStart> s += ( * s ) + 1 ; ND_TCHECK2 ( * s , 1 ) ;
<S2SV_ModStart> ; switch ( otype ) { case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ( ndo , EXTRACT_16BITS ( bp ) ) ; } <S2SV_ModStart> ; break ; } break ; case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> "0x%08x" , EXTRACT_32BITS ( bp ) ) ) ; } break ; case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModEnd> ND_PRINT ( ( ndo , "v%d" , * bp <S2SV_ModStart> EXTRACT_16BITS ( bp + 2 ) ) ) ; }
<S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x" ,
<S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)" ) ) ; return len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u" , <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u" , <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u" ,
<S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; compproto = EXTRACT_16BITS ( p +
<S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)" ) ) ; return len ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%u" <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>0x%08x" , <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%s" <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; if ( EXTRACT_16BITS ( p + <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return 0 ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>0x%08x" , <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>0x%04x" <S2SV_ModStart> , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%u"
<S2SV_ModStart> i ; register char * cp ; register struct bsnamemem <S2SV_ModEnd> * tp ; char buf [ BUFSIZE ] ; <S2SV_ModStart> ep , len ) ; if ( tp -> bs_name ) return ( tp -> bs_name <S2SV_ModEnd> ) ; cp = buf ; for ( i <S2SV_ModStart> -- ; * cp = '\\0' ; tp -> bs_name <S2SV_ModEnd> = strdup ( buf ) ; if ( tp <S2SV_ModStart> strdup ( buf ) ; if ( tp -> bs_name <S2SV_ModEnd> == NULL ) ( * ndo -> ndo_error ) <S2SV_ModStart> ndo , "le64addr_string:<S2SV_blank>strdup(buf)" ) ; return ( tp -> bs_name <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> i ; register char * cp ; register struct bsnamemem <S2SV_ModEnd> * tp ; if ( len == 0 ) <S2SV_ModStart> ep , len ) ; if ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = ( char * ) malloc ( <S2SV_ModStart> len * 3 ) ; if ( tp -> bs_name <S2SV_ModEnd> == NULL ) ( * ndo -> ndo_error ) <S2SV_ModStart> * cp = '\\0' ; return ( tp -> bs_name <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline struct bsnamemem <S2SV_ModEnd> * lookup_bytestring ( netdissect_options * ndo , register const <S2SV_ModStart> bs , const unsigned int nlen ) { struct bsnamemem <S2SV_ModEnd> * tp ; register u_int i , j , <S2SV_ModStart> - 1 ) ] ; while ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes && tp -> bs_addr0 == i && tp -> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> == k && memcmp ( ( const char * <S2SV_ModStart> , ( const char * ) ( tp -> bs_bytes <S2SV_ModEnd> ) , nlen ) == 0 ) return tp <S2SV_ModStart> ) return tp ; else tp = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> = ( u_char * ) calloc ( 1 , <S2SV_ModStart> nlen + 1 ) ; if ( tp -> bs_bytes <S2SV_ModEnd> == NULL ) ( * ndo -> ndo_error ) <S2SV_ModStart> ndo , "lookup_bytestring:<S2SV_blank>calloc" ) ; memcpy ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt = ( struct bsnamemem <S2SV_ModEnd> * ) calloc ( 1 , sizeof ( * <S2SV_ModStart> * tp ) ) ; if ( tp -> bs_nxt <S2SV_ModEnd> == NULL ) ( * ndo -> ndo_error )
<S2SV_ModStart> ND_PRINT ( ( ndo , "MLPPP,<S2SV_blank>" ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; }
<S2SV_ModStart> , 0 ) ; if ( sfsname ) { char temp [ NFSX_V3FHMAX + 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; strncpy ( temp , sfsname , stringlen ) ; temp [ stringlen <S2SV_ModEnd> ] = '\\0' ; spacep = strchr ( temp
<S2SV_ModStart> , "(ni:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> , buf , sizeof ( buf ) ) ; if ( plenbytes < 0 ) return plenbytes ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * <S2SV_ModStart> netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> pdu_len , hexdump ; const u_char * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , "%sRPKI-RTRv%u<S2SV_blank>(unknown)" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , "(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <S2SV_ModEnd> hexdump = FALSE ; ND_PRINT ( ( ndo , <S2SV_ModStart> , pdu_type ) , pdu_type , pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; break ; case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x" , indent_string ( <S2SV_ModStart> case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_IPV6_PREFIX_PDU : { const rpki_rtr_pdu_ipv6_prefix * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> u_int encapsulated_pdu_length , text_length , tlen , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = EXTRACT_16BITS ( pdu -> pdu_header . <S2SV_ModStart> error_code ) , error_code , encapsulated_pdu_length ) ) ; if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( ( ndo , "%s-----encapsulated<S2SV_blank>PDU-----" , indent_string <S2SV_ModStart> indent_string ( indent + 4 ) ) ) ; rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ; } tlen += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; text_length = EXTRACT_32BITS ( tptr + tlen ) ; tlen += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , "%sError<S2SV_blank>text:<S2SV_blank>" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE ; } if ( ndo -> <S2SV_ModStart> tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , pdu_len ) ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len ; trunc : ND_PRINT ( ( ndo , "\\n\\t%s" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) ) ; p += 2 ; caplen
<S2SV_ModStart> ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> const char * str2 , u_int l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
<S2SV_ModStart> const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options ) ;
<S2SV_ModStart> == SE ) break ; p ++ ; } ND_TCHECK ( * p ) ;
<S2SV_ModStart> uint32_t proto _U_ , int depth _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> , dumphex ; const unsigned char * typedata ; idp = ( const struct ikev2_id * ) ext ; ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY ( & id , ext ,
<S2SV_ModStart> sizeof ( a ) ; unsigned int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY ( & a , ext ,
<S2SV_ModStart> struct ikev2_ke * ) ext ; ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY ( & ke , ext ,
<S2SV_ModStart> ( paramlen + datalen ) , unicodestr ) ; # define MAILSLOT_BROWSE_STR "\\\\MAILSLOT\\\\BROWSE" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> char * ) ( data1 + 2 ) , MAILSLOT_BROWSE_STR <S2SV_ModEnd> ) == 0 ) { print_browse ( ndo , <S2SV_ModStart> , data , datalen ) ; return ; } # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR "\\\\PIPE\\\\LANMAN" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> char * ) ( data1 + 2 ) , PIPE_LANMAN_STR <S2SV_ModEnd> ) == 0 ) { print_ipc ( ndo , <S2SV_ModStart> , data , datalen ) ; return ; } # undef PIPE_LANMAN_STR
<S2SV_ModStart> { if ( ! ND_TTEST2 ( * tptr , 2 <S2SV_ModEnd> ) ) return ( 0 ) ; status_byte =
<S2SV_ModStart> ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; type = * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModEnd> ) ; len = EXTRACT_16BITS ( tptr + 2 <S2SV_ModStart> ) ; if ( type <= 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , "\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( eap_type_values , "unknown" , subtype ) , subtype <S2SV_ModEnd> ) ) ; switch ( subtype ) { case <S2SV_ModStart> 5 ; while ( count < len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> count ++ ; } break ; case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ( tptr + 5 ) ) ) ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x," , bittok2str ( <S2SV_ModStart> * ( tptr + 5 ) ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ) ) ; } break ; case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> * ( tptr + 5 ) ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
<S2SV_ModStart> ; memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 <S2SV_ModEnd> ) ; offset += tim . length - 3
<S2SV_ModStart> , char * ptr ) { char * ret ; size_t len <S2SV_ModStart> ; if ( ! ret ) return NULL ; len = strlen ( ptr ) ; if ( len > 0 && ptr [ len - 1 ] == '\\n' ) ptr [ len <S2SV_ModEnd> - 1 ] = '\\0' ; return ret ;
<S2SV_ModStart> ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; <S2SV_ModEnd> if ( caplen < 3 ) { ND_PRINT ( <S2SV_ModStart> < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ; seq = EXTRACT_LE_8BITS ( p + 2 <S2SV_ModStart> ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<<S2SV_blank>" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS ( p ) ; p += <S2SV_ModStart> EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! <S2SV_ModEnd> ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen <S2SV_ModStart> ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> char * sep ) { static char buf [ 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> ; register u_int rotbit ; register u_int tokval ; <S2SV_ModStart> tokval == ( v & rotbit ) ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , lp -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> ; sepstr = sep ; break ; } rotbit <S2SV_ModStart> 1 ; } lp ++ ; } if ( bufp == buf <S2SV_ModEnd> ) ( void ) snprintf ( buf , sizeof
<S2SV_ModStart> h , register const u_char * p ) { return chdlc_print ( ndo , p , h -> len <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ;
<S2SV_ModStart> oid_len = * tptr ; if ( tlen < 1U +
<S2SV_ModStart> "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p <S2SV_ModEnd> ) ) ) ; p += 8 ; caplen
<S2SV_ModStart> , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; ND_TCHECK_32BITS ( bp ) ;
<S2SV_ModStart> ; switch ( ie_type ) { case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>length)" ) ) ; break ; }
<S2SV_ModStart> 4 ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; return 0 ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; break ; case LDP_TLV_FT_SESSION : TLV_TCHECK ( 12 <S2SV_ModEnd> ) ; ft_flags = EXTRACT_16BITS ( tptr ) ; <S2SV_ModStart> ) ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; return 0 ; badtlv : ND_PRINT
<S2SV_ModStart> = ( const struct vtp_vlan_ * ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ( & vtp_vlan -> index ) ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr <S2SV_ModEnd> , vtp_vlan -> name_len , NULL ) ; len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= <S2SV_ModEnd> 4 * ( ( vtp_vlan -> name_len + 3 <S2SV_ModStart> + 3 ) / 4 ) ; tptr += <S2SV_ModEnd> 4 * ( ( vtp_vlan -> name_len + 3 <S2SV_ModStart> ) ; while ( len > 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> type ) , type ) ) ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; <S2SV_ModEnd> return ; } ND_TCHECK2 ( * tptr , tlv_len <S2SV_ModStart> tptr , tlv_len * 2 + 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> + tlv_len * 2 ) ; break ; } }
<S2SV_ModStart> atype , const u_char * pptr , u_int len , const unsigned attr_set_level <S2SV_ModStart> ndo , "]:<S2SV_blank>" ) ) ; } if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else if ( <S2SV_ModStart> bgp_attr_print ( ndo , atype , tptr , alen , attr_set_level + 1
<S2SV_ModStart> bgp_attr_print ( ndo , atype , p , alen , 0
<S2SV_ModStart> tmp ; while ( len > 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> stlv_len ) ) ; len = len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ; switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>CIST<S2SV_blank>Root-ID:<S2SV_blank>%08x" , EXTRACT_32BITS <S2SV_ModStart> ++ ) ; len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; while ( tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U:%d,<S2SV_blank>M:%d,<S2SV_blank>A:%d,<S2SV_blank>RES:%d" , * <S2SV_ModStart> tptr = tptr + 3 ; len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> tmp -- ; } break ; case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>BMAC:<S2SV_blank>%08x" , EXTRACT_32BITS <S2SV_ModStart> ; } break ; default : break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> i ; while ( len > 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> stlv_len ) ) ; len = len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> ; subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) <S2SV_ModStart> -> aux_mcid ) ) ; tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; break ; } case ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d<S2SV_blank>V:<S2SV_blank>%d<S2SV_blank>A:<S2SV_blank>%d<S2SV_blank>D:<S2SV_blank>%d" , ( <S2SV_ModStart> 4 ; } len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; break ; } case ISIS_SUBTLV_SPB_BVID : { while ( stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_ModEnd> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ECT:<S2SV_blank>%08x" , EXTRACT_32BITS ( <S2SV_ModStart> tptr = tptr + 2 ; len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len <S2SV_ModStart> } break ; } default : break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> sizeof ( ip6 -> ip6_dst ) ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> ( & rp -> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ;
<S2SV_ModStart> , "(refresh:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> uint8_t route_target [ 8 ] ; u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> ( 32 > plen ) return - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> ( route_target ) ) ; ND_TCHECK2 ( pptr [ 5 <S2SV_ModEnd> ] , ( plen + 7 ) / 8 <S2SV_ModStart> ; memcpy ( & route_target , & pptr [ 5 <S2SV_ModEnd> ] , ( plen + 7 ) / 8 <S2SV_ModStart> } snprintf ( buf , buflen , "origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print ( ndo , ( u_char * )
<S2SV_ModStart> : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
<S2SV_ModStart> += netal ; li -= netal ; if ( snpal == 6 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != 0 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s" , netal <S2SV_ModEnd> , isonsap_string ( ndo , neta , netal )
<S2SV_ModStart> . s_addr == sip && rxent -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh -> serviceId ) && rxent ->
<S2SV_ModStart> -> dport = dport ; rxent -> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( & rxh -> serviceId ) ; rxent ->
<S2SV_ModStart> item_len , const u_char * ep , uint32_t phase _U_ <S2SV_ModStart> doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ <S2SV_ModStart> item_len ; if ( cp < ep ) { <S2SV_ModEnd> switch ( ntohs ( n . type ) ) <S2SV_ModStart> oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) <S2SV_ModStart> : ep2 , map , nmap ) ; } ND_PRINT ( ( ndo , ")" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "replay<S2SV_blank>detection<S2SV_blank>%sabled" , EXTRACT_32BITS ( <S2SV_ModStart> cp ) ? "en" : "dis" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ")" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; }
<S2SV_ModStart> e ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>n<S2SV_blank>len=%u" <S2SV_ModEnd> , ntohs ( e . len ) - 4 <S2SV_ModStart> len ) - 4 ) ) ; if ( ntohs ( e . len ) > 4 ) { if ( ndo -> ndo_vflag > 2 <S2SV_ModEnd> ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) <S2SV_ModStart> ) ) goto trunc ; } else if ( ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) <S2SV_ModStart> ( ndo , ( const u_char * ) ( <S2SV_ModEnd> ext + 1 ) , ep ) ) goto <S2SV_ModStart> ) , ep ) ) goto trunc ; } }
<S2SV_ModStart> . len ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" <S2SV_ModEnd> , len - 4 , STR_OR_ID ( a . <S2SV_ModStart> auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT ( ( ndo , "<S2SV_blank>authdata=(" ) <S2SV_ModStart> ) ; } else if ( ndo -> ndo_vflag <S2SV_ModEnd> ) { if ( ! ike_show_somedata ( ndo , <S2SV_ModStart> authdata , ep ) ) goto trunc ; } }
<S2SV_ModStart> n ; const u_char * cp ; u_char showspi <S2SV_ModEnd> , showsomedata ; const char * notify_name ; uint32_t <S2SV_ModStart> h . critical ) ; showspi = 1 ; <S2SV_ModEnd> showsomedata = 0 ; notify_name = NULL ; ND_PRINT <S2SV_ModStart> "cookie" ; showspi = 1 ; showsomedata = 1 <S2SV_ModEnd> ; break ; case IV2_NOTIFY_USE_TRANSPORT_MODE : notify_name = "use_transport_mode" <S2SV_ModStart> 1 ) + n . spi_size ; if ( cp < ep ) { if ( ndo -> ndo_vflag > 3 <S2SV_ModEnd> || ( showsomedata && ep - cp < 30 <S2SV_ModStart> showsomedata && ep - cp < 30 ) ) <S2SV_ModEnd> { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) <S2SV_ModStart> ")" ) ) ; } else if ( showsomedata <S2SV_ModEnd> ) { if ( ! ike_show_somedata ( ndo , <S2SV_ModStart> , cp , ep ) ) goto trunc ; }
<S2SV_ModStart> 0 ; while ( i < length ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> ndo , "<S2SV_blank>(%u)" , optlen + 2 ) ) ; if ( i + 2 + optlen > length ) return - 1
<S2SV_ModStart> tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ;
<S2SV_ModStart> ap [ sizeof ( short ) ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
<S2SV_ModStart> u_int length ) { const struct aodv_hello * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> sizeof ( struct aodv_hello ) ) goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u" , ep -> length ) ) ; break ; }
<S2SV_ModStart> if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS ( & prep -> pp_n )
<S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> 1 ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) )
<S2SV_ModStart> case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> ; flags = * tptr ; tlen = len <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str
<S2SV_ModStart> const char * * pptr , int * len , int * truncated ) { const char * s ; s = * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( * * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> ( * pptr ) ++ ; ( * len <S2SV_ModStart> ) ++ ; ( * len ) -- ; <S2SV_ModEnd> return s ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> + BGP_VPN_RD_LEN ) ) ) ; pptr += BGP_VPN_RD_LEN + 4
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ; return ; # undef ECHECK }
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ; return ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ; return ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ; return ; tooshort : ND_PRINT (
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ; return ; tooshort : ND_PRINT (
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ; return ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) + optlen ) ; length -= optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ; return ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if 0 trunc : ND_PRINT ( ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ; return ; # endif } <S2SV_null>
<S2SV_ModStart> , lmp_obj_len , lmp_obj_ctype , obj_tlen ; int hexdump , ret <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 <S2SV_ModStart> , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 <S2SV_ModStart> , obj_tptr , obj_tlen - 36 , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 <S2SV_ModStart> , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
<S2SV_ModStart> obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ;
<S2SV_ModStart> , & ip6 -> ip6_dst ) ) ) ; <S2SV_ModEnd> } else { ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]" <S2SV_ModStart> , & ip -> ip_dst ) ) ) ; } return ; <S2SV_ModEnd> } sport = EXTRACT_16BITS ( & pgm -> pgm_sport <S2SV_ModStart> ( 2 * sizeof ( uint16_t ) ) ; ND_TCHECK_16BITS ( bp ) ;
<S2SV_ModStart> IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , <S2SV_ModStart> IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , <S2SV_ModStart> 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x" , <S2SV_ModStart> ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if ( bp [ hlen ] & <S2SV_ModStart> if ( bp [ hlen ] & 0xf0 ) { <S2SV_ModStart> ND_PRINT ( ( ndo , "K" ) ) ; } hlen += 1 ; hlen += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , <S2SV_ModStart> mh -> ip6m_data8 [ 0 ] ) ) ; ND_TCHECK ( mh -> ip6m_data8 [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModEnd> & 0x80 ) ND_PRINT ( ( ndo , "<S2SV_blank>K" <S2SV_ModStart> , "<S2SV_blank>K" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , <S2SV_ModStart> ] ) ) ) ; hlen += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , <S2SV_ModStart> ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>homeaddr<S2SV_blank>%s"
<S2SV_ModStart> dataend ) goto trunc ; ND_TCHECK ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" ,
<S2SV_ModStart> , const u_char * p , const u_char * ep2 ) { int totlen ; uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModEnd> if ( p [ 0 ] & 0x80 ) <S2SV_ModStart> ] & 0x80 ) totlen = 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> EXTRACT_16BITS ( & p [ 2 ] ) ; } if ( ep2 <S2SV_ModEnd> < p + totlen ) { ND_PRINT ( ( <S2SV_ModStart> ( ( ndo , "[|attr]" ) ) ; return ep2 + 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "(" ) ) ; <S2SV_ModStart> ) ; t = p [ 2 ] ; if ( ! <S2SV_ModStart> ) & p [ 2 ] , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } <S2SV_ModEnd> } else { ND_PRINT ( ( ndo , "len=%d<S2SV_blank>value=" <S2SV_ModStart> else { ND_PRINT ( ( ndo , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo , ( const uint8_t * ) <S2SV_ModStart> uint8_t * ) & p [ 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; return p + totlen ; trunc : return NULL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , const u_char * p , const u_char * ep2 <S2SV_ModEnd> , const struct attrmap * map , size_t nmap <S2SV_ModStart> { int totlen ; uint32_t t , v ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ] & 0x80 ) totlen = 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> EXTRACT_16BITS ( & p [ 2 ] ) ; } if ( ep2 <S2SV_ModEnd> < p + totlen ) { ND_PRINT ( ( <S2SV_ModStart> ( ( ndo , "[|attr]" ) ) ; return ep2 + 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "(" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , "value=" ) ) ; ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> . value [ v ] ) ) ; else { if ( ! <S2SV_ModStart> ) & p [ 2 ] , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } <S2SV_ModEnd> } else { ND_PRINT ( ( ndo , "len=%d<S2SV_blank>value=" <S2SV_ModStart> else { ND_PRINT ( ( ndo , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo , ( const uint8_t * ) <S2SV_ModStart> uint8_t * ) & p [ 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; return p + totlen ; trunc : return NULL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } <S2SV_ModEnd> } ND_PRINT ( ( ndo , ")" ) )
<S2SV_ModStart> ep2 ) { if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if ( ep < ep2 ) <S2SV_ModEnd> ND_PRINT ( ( ndo , "..." ) ) ;
<S2SV_ModStart> { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if ( ep < ep2 ) <S2SV_ModEnd> ND_PRINT ( ( ndo , "..." ) ) ;
<S2SV_ModStart> ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;
<S2SV_ModStart> ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
<S2SV_ModStart> dat ; register const struct netinfo6 * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch ( rp -> rip6_cmd ) { <S2SV_ModStart> ( rp -> rip6_cmd ) { case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( * ni ) ; if ( <S2SV_ModStart> * ni ) ; if ( j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED <S2SV_ModStart> ndo , "<S2SV_blank>ripng-req<S2SV_blank>dump" ) ) ; break ; } } <S2SV_ModStart> ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:" , j , length <S2SV_ModEnd> ) ) ; else ND_PRINT ( ( ndo , <S2SV_ModStart> ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u:" , j ) <S2SV_ModEnd> ) ; for ( ni = rp -> rip6_nets <S2SV_ModStart> ; for ( ni = rp -> rip6_nets ; length_left >= sizeof ( * ni ) ; length_left <S2SV_ModEnd> -= sizeof ( * ni ) , ++ ni <S2SV_ModStart> ( * ni ) , ++ ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ( ndo , ni , 0 ) ; } if ( length_left != 0 ) goto trunc ; break ; case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( * ni ) ; if ( <S2SV_ModStart> ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:" , j , length <S2SV_ModEnd> ) ) ; else ND_PRINT ( ( ndo , <S2SV_ModStart> ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d:" , j ) ) ; for ( ni = rp -> rip6_nets ; length_left >= sizeof ( * ni ) ; length_left <S2SV_ModEnd> -= sizeof ( * ni ) , ++ ni <S2SV_ModStart> ( * ni ) , ++ ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> , ni -> rip6_metric ) ; } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; default : ND_PRINT ( ( ndo <S2SV_ModStart> rip6_cmd , length ) ) ; break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> , "<S2SV_blank>[vers<S2SV_blank>%d]" , rp -> rip6_vers ) ) ; return ; trunc : ND_PRINT ( ( ndo , "[|ripng]" ) ) ; return ;
<S2SV_ModStart> case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc <S2SV_ModEnd> ; break ; case IPOPT_RA : if ( option_len
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options * ndo , register const u_char <S2SV_ModStart> ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; return ( 0 ) <S2SV_ModStart> ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> len < length ; len += 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ( ( ndo , "," ) ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> ) ; break ; } needcomma = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> * ) ( ni6 + 1 ) + 4 ; ND_TCHECK ( cp [ 0 ] )
<S2SV_ModStart> BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; <S2SV_ModEnd> tlen = len ; while ( tlen >= 3 <S2SV_ModStart> len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_ModStart> length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart> ; ND_TCHECK2 ( tptr [ 3 ] , length <S2SV_ModEnd> ) ; switch ( type ) { case BGP_AIGP_TLV <S2SV_ModStart> ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , <S2SV_ModStart> ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr <S2SV_ModEnd> ) ) ) ; break ; default : if <S2SV_ModStart> <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length <S2SV_ModEnd> ) ; } } tptr += length ; tlen
<S2SV_ModStart> = g_options . desired_port ; struct tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { tcp_socket = tcp_open ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || g_options . only_desired_port ) break ; <S2SV_ModEnd> desired_port ++ ; if ( desired_port == 1 || <S2SV_ModStart> || desired_port == 0 ) desired_port = 49152 ; NOTE ( "Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket == NULL ) goto cleanup_tcp ; uint16_t real_port ; if ( tcp_socket ) real_port = tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModEnd> ) ; if ( desired_port != 0 && g_options <S2SV_ModStart> , real_port ) ; fflush ( stdout ) ; NOTE ( "Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable" , real_port , tcp_socket ? "" : "not<S2SV_blank>" , tcp6_socket ? "" : "not<S2SV_blank>" ) ; <S2SV_ModStart> -> usb_sock = usb_sock ; args -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> ) ; if ( args -> tcp == NULL <S2SV_ModStart> tcp_socket != NULL ) tcp_close ( tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;
<S2SV_ModStart> if ( this == NULL ) { ERR ( "IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed" <S2SV_ModEnd> ) ; goto error ; } this -> sd <S2SV_ModStart> - 1 ; this -> sd = socket ( AF_INET <S2SV_ModEnd> , SOCK_STREAM , 0 ) ; if ( this <S2SV_ModStart> this -> sd < 0 ) { ERR ( "IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> addr ; memset ( & addr , 0 , <S2SV_ModStart> , 0 , sizeof addr ) ; addr . sin_family = AF_INET ; addr . sin_port = htons ( port ) ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> ; if ( bind ( this -> sd , <S2SV_ModStart> ( g_options . only_desired_port == 1 ) ERR ( "IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>" <S2SV_ModEnd> "Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions." ) ; goto error ; } if ( <S2SV_ModStart> , HTTP_MAX_PENDING_CONNS ) < 0 ) { ERR ( "IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket" <S2SV_ModEnd> ) ; goto error ; } return this ;
<S2SV_ModStart> ; } if ( rh . command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family ( const tor_addr_t * a1 , const
<S2SV_ModStart> ; uint16_t port = 0 ; or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> ; if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) { or_circ = TO_OR_CIRCUIT ( circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModEnd> relay_header_unpack ( & rh , cell -> payload ) <S2SV_ModStart> ( rh . stream_id , circ , end_reason , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( ! <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( or_circ <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( ! <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; return 0 ; } } log_debug ( <S2SV_ModStart> if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; log_info ( LD_REND , "begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream." ) ; <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ; connection_free ( TO_CONN ( n_stream ) )
<S2SV_ModStart> -> bios + data_offset ) ; if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING ) return false ; mode -> crtc_htotal = <S2SV_ModStart> -> bios + data_offset ) ; if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ; dtd_timings = & tv_info_v1_2
<S2SV_ModStart> ) ; if ( q -> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_ctx ; flush_rq -> tag = first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
<S2SV_ModStart> ) ; if ( q -> mq_ops ) { struct blk_mq_hw_ctx * hctx ; spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq <S2SV_ModEnd> ) ; flush_rq -> tag = - 1 ;
<S2SV_ModStart> , bit + 1 ) ) { rq = hctx -> tags -> rqs [ off + bit ] <S2SV_ModEnd> ; if ( rq -> q == hctx ->
<S2SV_ModStart> , bit + 1 ) ) { rq = tags -> rqs [ off + bit ] <S2SV_ModEnd> ; fn ( rq , data , reserved )
<S2SV_ModStart> blk_mq_tags * tags , unsigned int tag ) { return tags -> rqs [ tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = usb_get_intfdata ( intf ) ; const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModEnd> ; dev_dbg ( & d -> udev -> dev <S2SV_ModStart> ( d ) ; dvb_usbv2_exit ( d ) ; pr_info ( "%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( client -> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> = ns ; new -> uid = uid ; new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( & ucounts_lock ) ; ucounts = <S2SV_ModStart> ; ucounts = new ; } } if ( ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts
<S2SV_ModStart> ucounts * ucounts ) { unsigned long flags ; spin_lock_irqsave ( & ucounts_lock , flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ; else ucounts = NULL <S2SV_ModEnd> ; spin_unlock_irqrestore ( & ucounts_lock , flags ) ; <S2SV_ModStart> , flags ) ; kfree ( ucounts ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> } mutex_unlock ( & ufile -> umap_lock ) ; skip_mm :
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
<S2SV_ModStart> out ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } skip_mm :
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
<S2SV_ModStart> ) ; if ( res ) return res ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct domain_device * dev , * n <S2SV_ModStart> ) { struct domain_device * dev , * n <S2SV_ModEnd> ; list_for_each_entry_safe ( dev , n , & port
<S2SV_ModStart> ) ; port -> port_dev = NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> ) ; if ( res ) return res ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = <S2SV_ModStart> ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices <S2SV_ModEnd> , } ; disc -> pending = 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct domain_device * dev , * n <S2SV_ModStart> ) { struct domain_device * dev , * n <S2SV_ModEnd> ; list_for_each_entry ( dev , & port -> disco_list
<S2SV_ModStart> : mutex_unlock ( & ha -> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> -> disco_list_node , & port -> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = sas_find_bcast_dev ( port_dev , & dev ) ; if <S2SV_ModEnd> ( res == 0 && dev ) { struct <S2SV_ModStart> while ( i < ex -> num_phys ) ; <S2SV_ModEnd> } return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy -> port = NULL ; }
<S2SV_ModStart> == 1 ) { sas_unregister_domain_devices ( port , gone ) ; sas_destruct_devices ( port
<S2SV_ModStart> ; INIT_LIST_HEAD ( & port -> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> ( rc ) { sas_unregister_dev ( port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ; size_t size ; u8 * data = NULL ; int max , <S2SV_ModEnd> ret = 0 ; minsz = offsetofend ( struct <S2SV_ModStart> || hdr . index >= VFIO_PCI_NUM_IRQS || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> VFIO_IRQ_SET_DATA_TYPE_MASK | VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count ( vdev , hdr . index <S2SV_ModStart> vdev , hdr . index ) ; if ( <S2SV_ModEnd> hdr . start >= max || hdr . start <S2SV_ModStart> hdr . start + hdr . count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
<S2SV_ModStart> ) return - EINVAL ; vdev -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;
<S2SV_ModStart> usb_device * usb_dev = atusb -> usb_dev ; char * build ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModEnd> ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( <S2SV_ModStart> -> dev , "Firmware:<S2SV_blank>build<S2SV_blank>%s\\n" , build ) ; } kfree ( build ) ;
<S2SV_ModStart> * usb_dev = atusb -> usb_dev ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( <S2SV_ModStart> & usb_dev -> dev , "Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer" ) ; } kfree ( buffer ) ;
<S2SV_ModStart> = atusb -> usb_dev ; int ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( & usb_dev -> dev , "atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n" <S2SV_ModStart> , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ; if ( ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return ret ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> mdev = dev -> mdev ; struct mlx5_ib_create_qp_resp resp = { }
<S2SV_ModStart> utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
<S2SV_ModStart> * outlen = utf8s_to_utf16s ( name , len , UTF16_HOST_ENDIAN , ( wchar_t * ) outname , FAT_LFN_LEN + 2 <S2SV_ModEnd> ) ; if ( * outlen < 0 )
<S2SV_ModStart> = f_hidg_req_complete ; req -> context = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; goto release_write_pending <S2SV_ModEnd> ; } else { status = count ; } <S2SV_ModStart> ; } else { status = count ; } <S2SV_ModEnd> return status ; release_write_pending : spin_lock_irqsave ( & hidg <S2SV_ModStart> ( & hidg -> write_spinlock , flags ) ; <S2SV_ModEnd> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( &
<S2SV_ModStart> { case ACL_TYPE_ACCESS : if ( acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval ) goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry <S2SV_ModStart> ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : if ( !
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret = 0 ; break ; case
<S2SV_ModStart> EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode <S2SV_ModStart> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT
<S2SV_ModStart> EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime = ext4_current_time ( inode ) ; <S2SV_ModStart> ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT
<S2SV_ModStart> F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error ; set_acl_inode ( inode , inode <S2SV_ModStart> ; set_acl_inode ( inode , inode -> i_mode ) <S2SV_ModEnd> ; } break ; case ACL_TYPE_DEFAULT : name_index =
<S2SV_ModStart> umode_t mode = inode -> i_mode ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( mode != inode -> i_mode ) <S2SV_ModStart> ; if ( mode != inode -> i_mode ) mark_inode_dirty ( inode ) ; <S2SV_ModEnd> } if ( acl ) { len = posix_acl_to_xattr
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { err = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err ; } err = 0 ;
<S2SV_ModStart> JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { umode_t mode ; rc = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc ; if ( inode -> i_mode <S2SV_ModStart> ( rc < 0 ) return rc ; } <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { rc = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) <S2SV_ModEnd> goto out ; } rc = __jfs_setxattr ( tid
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { umode_t mode ; error = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( error ) { gossip_err ( "%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n" <S2SV_ModEnd> , __func__ , error ) ; return error ; <S2SV_ModStart> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT
<S2SV_ModStart> if ( type == ACL_TYPE_ACCESS ) { umode_t mode ; error = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> error = xfs_set_mode ( inode , mode ) ;
<S2SV_ModStart> d_instantiate ( dentry , inode ) ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
<S2SV_ModStart> ; int ret ; uint32_t size ; uint32_t backup_handle = 0 <S2SV_ModStart> -> backup_base ) ; if ( ret == 0 ) { if ( <S2SV_ModEnd> res -> backup -> base . num_pages * PAGE_SIZE <S2SV_ModStart> ; ret = - EINVAL ; goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
<S2SV_ModStart> == NULL ) return - ENOMEM ; ue -> card = card ; ue ->
<S2SV_ModStart> struct user_element * ue = kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> ue -> elem_data , ue -> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> ; struct user_element * ue = kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> ucontrol -> value , ue -> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> new_data ) ) return PTR_ERR ( new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = new_data ; ue -> tlv_data_size = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModEnd> if ( ! ue -> tlv_data_size || ! ue <S2SV_ModStart> ue -> tlv_data_size || ! ue -> tlv_data ) { ret = - ENXIO ; goto err_unlock ; } if ( size < ue -> tlv_data_size ) { ret = - ENOSPC ; goto err_unlock ; } <S2SV_ModEnd> if ( copy_to_user ( tlv , ue -> tlv_data <S2SV_ModStart> ue -> tlv_data , ue -> tlv_data_size ) ) ret = - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ; <S2SV_ModEnd> } return change ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock
<S2SV_ModStart> & resp_buftype , flags , & rsp_iov ) ; <S2SV_ModEnd> rsp = ( struct smb2_read_rsp * ) rsp_iov . <S2SV_ModStart> io_parms -> offset , io_parms -> length ) ; cifs_small_buf_release ( req ) ;
<S2SV_ModStart> short op , int st ) { struct blkif_response * <S2SV_ModStart> flags ; union blkif_back_rings * blk_rings ; int notify <S2SV_ModEnd> ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags <S2SV_ModStart> -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> <S2SV_ModStart> -> native , blk_rings -> native . rsp_prod_pvt ) ; break ; case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> <S2SV_ModStart> -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ; break ; case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> <S2SV_ModStart> -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; default : BUG ( ) ; <S2SV_ModStart> break ; default : BUG ( ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
<S2SV_ModStart> [ i ] ; goto out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
<S2SV_ModStart> ] ; goto out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; } if (
<S2SV_ModStart> posix_acl * acl ; struct xfs_acl_entry * ace ; unsigned
<S2SV_ModStart> ret = - EFAULT ; goto exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> , s_cmd , sizeof ( * s_cmd ) + s_cmd -> <S2SV_ModEnd> insize ) ) ret = - EFAULT ; exit
<S2SV_ModStart> ) ; if ( ret == 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> = key -> payload . data [ 0 ] ; else zap = NULL
<S2SV_ModStart> kvm ) ; kvm_for_each_memslot ( memslot , slots ) kvm_iommu_unmap_pages ( kvm , memslot <S2SV_ModEnd> ) ; srcu_read_unlock ( & kvm -> srcu ,
<S2SV_ModStart> ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ;
<S2SV_ModStart> __user * utp ) { struct compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> ( hid -> name , req -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf ( hid -> phys , sizeof
<S2SV_ModStart> q -> bufs [ first ] -> map = kzalloc <S2SV_ModEnd> ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL )
<S2SV_ModStart> q ; int i ; dprintk ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map , map -> count , vma ->
<S2SV_ModStart> = vma -> vm_private_data ; dprintk ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map , map -> count , vma ->
<S2SV_ModStart> ( "lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n" , - task -> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : goto retry_rebind ; } <S2SV_ModEnd> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay
<S2SV_ModStart> ; task -> tk_cred_retry = 2 ; task -> tk_rebind_retry = 2 ; task ->
<S2SV_ModStart> -> disk_name , cmd ) ) ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
<S2SV_ModStart> ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 <S2SV_ModEnd> ) ; } smin_val = src_reg . smin_value ;
<S2SV_ModStart> env , regs , insn -> dst_reg ) ; coerce_reg_to_size ( & regs [ insn -> dst_reg ] , 4 <S2SV_ModEnd> ) ; } } else { regs [ insn
<S2SV_ModStart> [ value_regno ] . type == SCALAR_VALUE ) { coerce_reg_to_size ( & regs [ value_regno ] , size <S2SV_ModEnd> ) ; } return err ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = nvmet_fc_getqueueid ( connection_id ) ; unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
<S2SV_ModStart> * xtregs = uregs ; int ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
<S2SV_ModStart> verbose ( "%d:<S2SV_blank>" , insn_idx ) ; print_bpf_insn ( env ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ( BPF_MODE ( insn -> code ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , insn -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ; } else { verbose ( "BUG_ld_%02x\\n"
<S2SV_ModStart> op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) <S2SV_ModEnd> ) { flags &= ~ FLAG_LAST_MATCHED ; pc +=
<S2SV_ModStart> , uid ) ; if ( user -> uid_keyring && user -> session_keyring
<S2SV_ModStart> tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen + frag_hdr_sz ) ) { if
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct super_block * sb , unsigned char <S2SV_ModStart> from , int fromlen , unsigned char * to , int tolen <S2SV_ModStart> struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; <S2SV_ModEnd> while ( elen < fromlen ) { pc = <S2SV_ModStart> lengthComponentIdent > 0 ) break ; case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p , "../" , 3 ) ; <S2SV_ModStart> "../" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p , "./" , 2 ) ; <S2SV_ModStart> "./" , 2 ) ; p += 2 ; tolen -= 2 ; break ; case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- <S2SV_ModEnd> ; break ; } elen += sizeof ( struct <S2SV_ModStart> ; else p [ 0 ] = '\\0' ; return 0 ;
<S2SV_ModStart> ; } symlink = bh -> b_data ; } err = <S2SV_ModStart> i_sb , symlink , inode -> i_size , p , PAGE_SIZE ) ; brelse ( bh ) ; if ( err ) goto out_unlock_inode <S2SV_ModEnd> ; up_read ( & iinfo -> i_data_sem ) ;
<S2SV_ModStart> ) { pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void * memory ; if ( dma_alloc_from_coherent
<S2SV_ModStart> ) { pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void * memory ; if ( dma_alloc_from_coherent
<S2SV_ModStart> ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> ] ; altsd = get_iface_desc ( alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> S_ISDIR ( mode ) ) mode |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> ; same = NULL ; goto out ; } same -> dest_count = count ;
<S2SV_ModStart> = upperdir -> d_inode ; struct dentry * upper <S2SV_ModEnd> ; int err ; inode_lock_nested ( dir , I_MUTEX_PARENT <S2SV_ModStart> err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; err = - ESTALE ; if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir ) err = vfs_rmdir ( dir <S2SV_ModStart> vfs_unlink ( dir , upper , NULL ) ; ovl_dentry_version_inc ( dentry -> d_parent ) ; } dput ( upper ) ; <S2SV_ModEnd> if ( ! err ) d_drop ( dentry ) <S2SV_ModStart> ( ! err ) d_drop ( dentry ) ; out_unlock :
<S2SV_ModStart> lock_rename ( new_upperdir , old_upperdir ) ; olddentry = lookup_one_len ( old -> d_name . name , old_upperdir , old <S2SV_ModEnd> -> d_name . len ) ; err = PTR_ERR <S2SV_ModStart> d_name . len ) ; err = PTR_ERR ( olddentry ) ; if ( IS_ERR ( olddentry ) ) goto out_unlock ; err = - ESTALE ; if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir ) goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModEnd> if ( olddentry == trap ) goto out_dput ; <S2SV_ModStart> ) ; out_dput : dput ( newdentry ) ; out_dput_old : dput ( olddentry ) ;
<S2SV_ModStart> base = i -> iov_offset ; while ( bytes || ! iov -> iov_len
<S2SV_ModStart> ; copied = status ; cond_resched ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> ( i ) ) ; goto again ; } <S2SV_ModEnd> pos += copied ; written += copied ; balance_dirty_pages_ratelimited
<S2SV_ModStart> ( "%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n" , bd -> name , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
<S2SV_ModStart> ) { if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw <S2SV_ModEnd> ( ) && ! capable ( CAP_SYS_ADMIN ) )
<S2SV_ModStart> ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn
<S2SV_ModStart> & end_ptr , 0 ) ; if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) { printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" "<S2SV_blank>%u\\n" ,
<S2SV_ModStart> return - EBUSY ; } chip -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL ) ; if ( chip -> data_buffer
<S2SV_ModStart> source_mnt , struct list_head * tree_list ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> m , prev_dest_mnt , prev_src_mnt , & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
<S2SV_ModStart> rqstp -> rq_arg . head [ 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> ntohl ( * p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ; if (
<S2SV_ModStart> void * ) p - head -> iov_base ; if ( hdr > head -> iov_len ) return 0 ;
<S2SV_ModStart> ep_loop_check ( ep , tfile ) != 0 ) { clear_tfile_check_list ( ) ; goto error_tgt_fput ; } <S2SV_ModEnd> } else list_add ( & tfile -> f_tfile_llink ,
<S2SV_ModStart> , KLSI_STATUSBUF_LEN , 10000 ) ; if ( rc != KLSI_STATUSBUF_LEN ) { dev_err ( & port -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status = get_unaligned_le16 ( status_buf ) ;
<S2SV_ModStart> ( bh ) ; clear_buffer_new ( bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
<S2SV_ModStart> ( sbi ) ; unsigned int ovp_segments , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i <S2SV_ModStart> KERN_ERR , "Wrong<S2SV_blank>layout:<S2SV_blank>check<S2SV_blank>mkfs.f2fs<S2SV_blank>version" ) ; return 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer <S2SV_ModStart> * pipe , struct pipe_buffer * buf ) { return try_get_page <S2SV_ModEnd> ( buf -> page ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> & ( opipe -> buffers - 1 ) ; if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe -> bufs + nbuf ; *
<S2SV_ModStart> -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf = * ibuf ; obuf -> flags
<S2SV_ModStart> rcur -> var_off ) ; } else { return false <S2SV_ModEnd> ; } case PTR_TO_MAP_VALUE : return memcmp ( rold
<S2SV_ModStart> -> cid_shift = 16 ; new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
<S2SV_ModStart> cifs_dbg ( VFS , "BAD_NETWORK_NAME:<S2SV_blank>%s\\n" , tree ) ; if ( tcon )
<S2SV_ModStart> ) ; goto err ; } if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) { dev_err ( dev , "Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n" ,
<S2SV_ModStart> vma -> vm_flags & VM_WRITE ) ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) { pte_unmap_unlock ( ptep , ptl )
<S2SV_ModStart> unsigned int flags ) { struct dentry * dir <S2SV_ModEnd> ; int dir_has_key , cached_with_key ; if ( flags <S2SV_ModStart> dput ( dir ) ; return 0 ; } <S2SV_ModEnd> spin_lock ( & dentry -> d_lock ) ; cached_with_key <S2SV_ModStart> & dentry -> d_lock ) ; dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL ) ; dput ( dir ) ;
<S2SV_ModStart> -> len ; return 0 ; } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir ) ; if ( ret && ret
<S2SV_ModStart> struct inode * inode ) { struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res ; if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( ! ci ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free (
<S2SV_ModStart> keyring_key ) ) return PTR_ERR ( keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> res = - ENOKEY ; goto out ; } <S2SV_ModEnd> ukp = user_key_payload ( keyring_key ) ; if ( <S2SV_ModStart> struct fscrypt_key ) ) { res = - EINVAL <S2SV_ModEnd> ; goto out ; } master_key = ( struct <S2SV_ModStart> -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read ( & keyring_key -> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * np = netdev_priv ( dev ) ; struct mii_ioctl_data * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = np -> phy_addr ; switch ( <S2SV_ModStart> -> phy_addr ; switch ( cmd ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; break ; case SIOCGMIIREG : miidata -> val_out <S2SV_ModEnd> = mii_read ( dev , phy_addr , miidata -> <S2SV_ModStart> , miidata -> reg_num ) ; break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev , phy_addr , miidata -> reg_num <S2SV_ModStart> , phy_addr , miidata -> reg_num , miidata -> val_in <S2SV_ModEnd> ) ; break ; default : return - EOPNOTSUPP
<S2SV_ModStart> - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; spin_lock_init ( & ctx -> cancel_lock
<S2SV_ModStart> void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) { spin_lock ( & ctx -> cancel_lock ) ; __timerfd_remove_cancel ( ctx ) ; spin_unlock ( & ctx -> cancel_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct timerfd_ctx * ctx , int flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> spin_unlock ( & cancel_lock ) ; } } else { __timerfd_remove_cancel ( ctx ) ; } spin_unlock ( & ctx -> cancel_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> src_addr , struct page * * pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> ( page ) ; set_page_huge_active ( page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; if ( vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = huge_add_to_page_cache ( page , mapping , <S2SV_ModStart> dst_mm , dst_pte ) ; spin_lock ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
<S2SV_ModStart> wait ; unsigned long flags ; if ( ! tty ) return ; if ( !
<S2SV_ModStart> demodulator_priv ; int i , ret ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> } printk ( ")<S2SV_blank>toneburst=%d\\n" , toneburst ) ; } <S2SV_ModEnd> for ( i = 0 ; i < d
<S2SV_ModStart> 0 ; out_cancel : xfs_trans_cancel ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
<S2SV_ModStart> , buf [ sizeof ( "nnnnn\\0" ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( copy_from_user ( buf , buffer , <S2SV_ModStart> ; if ( copy_from_user ( buf , buffer , size <S2SV_ModEnd> ) ) return - EFAULT ; tmp = simple_strtol
<S2SV_ModStart> += 255 ) len = * ip ++ ; if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;
<S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) ) { const unsigned char * <S2SV_ModStart> ; } else # endif { NEED_OP ( t , 0 ) ; NEED_IP ( t , <S2SV_ModEnd> 3 ) ; do { * op ++ = <S2SV_ModStart> ; TEST_LB ( m_pos ) ; NEED_OP ( 2 , 0 <S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> 31 + * ip ++ ; NEED_IP ( 2 , 0 <S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> 7 + * ip ++ ; NEED_IP ( 2 , 0 <S2SV_ModStart> t ; if ( likely ( HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) ) { do { COPY8 ( <S2SV_ModStart> op = oe ; if ( HAVE_IP ( 6 , 0 <S2SV_ModStart> continue ; } } else { NEED_OP ( t , 0 <S2SV_ModStart> oe = op + t ; NEED_OP ( t , 0 <S2SV_ModStart> CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 <S2SV_ModEnd> ) ) ) { COPY4 ( op , ip <S2SV_ModStart> ; } else # endif { NEED_IP ( t , 3 ) ; NEED_OP ( t , 0 <S2SV_ModEnd> ) ; while ( t > 0 ) {
<S2SV_ModStart> = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> ( & mpu -> input_lock , flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = <S2SV_ModEnd> readw ( mpu -> dev -> MIDQ + JQS_wTail <S2SV_ModStart> ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head <S2SV_ModEnd> ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & <S2SV_ModStart> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , mpu -> dev -> MIDQ + JQS_wHead ) <S2SV_ModStart> -> dev -> MIDQ + JQS_wHead ) ; } out :
<S2SV_ModStart> netns_ids , id ) ; if ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer ) ; spin_unlock_bh ( & net ->
<S2SV_ModStart> - EFAULT ; len = namelen ; if ( len <S2SV_ModEnd> > 32 ) len = 32 ; down_read (
<S2SV_ModStart> strlen ( res ) + 1 ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len = count ; if ( copy_to_user
<S2SV_ModStart> struct rusage r ; long ret , err ; unsigned int status = 0 ; <S2SV_ModStart> KERNEL_DS ) ; ret = sys_wait4 ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , ( struct rusage __user * ) <S2SV_ModStart> - EFAULT ; err = 0 ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> return 1 ; case GSI_GET_HWRPB : if ( nbytes > <S2SV_ModEnd> sizeof ( * hwrpb ) ) return - EINVAL
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst <S2SV_ModStart> struct x86_emulate_ctxt * ctxt , ulong dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_call ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_ModStart> = ( unsigned long ) ctxt -> _eip ; rc = jmp_rel ( ctxt , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc <S2SV_ModEnd> ; return em_push ( ctxt ) ; } <S2SV_null>
<S2SV_ModStart> int old_eip ; old_eip = ctxt -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModEnd> ; ctxt -> src . val = old_eip ; <S2SV_ModStart> ctxt ) ; break ; } case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) <S2SV_ModEnd> ; break ; case 5 : rc = em_jmp_far
<S2SV_ModStart> int em_jcxz ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = <S2SV_ModStart> , ctxt -> src . val ) ; return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_loop ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ^ 0x5 , ctxt -> eflags ) ) ) rc = <S2SV_ModStart> , ctxt -> src . val ) ; return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_ret ( struct x86_emulate_ctxt * ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct x86_emulate_ctxt * ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; if ( rc != X86EMUL_CONTINUE ) return
<S2SV_ModStart> ; struct desc_struct cs , ss ; u64 msr_data , rcx , rdx <S2SV_ModStart> usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 0 ; cs . l = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> 0 , VCPU_SREG_SS ) ; ctxt -> _eip = rdx <S2SV_ModEnd> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = <S2SV_ModStart> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel <S2SV_ModStart> struct x86_emulate_ctxt * ctxt , int rel ) { return
<S2SV_ModStart> ctxt -> b , ctxt -> eflags ) ) rc = <S2SV_ModStart> ; break ; case 0xe9 : case 0xeb : rc = <S2SV_ModStart> ctxt -> b , ctxt -> eflags ) ) rc =
<S2SV_ModStart> if ( keyring == new -> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> * find_keyring_by_name ( const char * name , bool uid_keyring <S2SV_ModEnd> ) { struct key * keyring ; int bucket <S2SV_ModStart> name ) != 0 ) continue ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref ( keyring , 0 ) , <S2SV_ModStart> ) , KEY_NEED_SEARCH ) < 0 ) continue ; }
<S2SV_ModStart> -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
<S2SV_ModStart> inode_owner_or_capable ( const struct inode * inode ) { struct user_namespace * ns ; <S2SV_ModStart> , inode -> i_uid ) ) return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return true ; return false ; }
<S2SV_ModStart> , fsuid ) ) return 0 ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_FOWNER ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( inode -> i_mode ) ) { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_OVERRIDE ) ) return 0 ; <S2SV_ModStart> ! ( mask & MAY_WRITE ) ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ; <S2SV_ModStart> inode -> i_mode & S_IXUGO ) ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_OVERRIDE ) ) return 0 ; <S2SV_ModStart> ; if ( mask == MAY_READ ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;
<S2SV_ModStart> & ( S_ISUID | S_ISGID ) ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I ( ip ) , CAP_FSETID ) )
<S2SV_ModStart> ; } inode -> i_generation = iinfo -> i_unique ; if ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out
<S2SV_ModStart> [ dp ++ ] ; if ( tag == ASN1_EOC <S2SV_ModEnd> ) { if ( data [ dp ++ ] <S2SV_ModStart> ++ ] ; if ( len <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) <S2SV_ModStart> ; if ( unlikely ( n > sizeof ( len <S2SV_ModEnd> ) - 1 ) ) goto length_too_long ; if <S2SV_ModStart> > datalen - dp ) ) goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > 0 ; n -- ) { <S2SV_ModStart> len |= data [ dp ++ ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
<S2SV_ModStart> case S_IFREG : case S_IFLNK : case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else { switch ( dip -> di_aformat )
<S2SV_ModStart> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid <S2SV_ModEnd> ( ) ) ) { int mode = ( <S2SV_ModStart> << 3 ) | mode ; } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) { int mode = ( table ->
<S2SV_ModStart> pdev -> dev ) ; gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc <S2SV_ModEnd> , gpio_dev ) ; if ( IS_ERR ( gpio_dev <S2SV_ModStart> gc , gpio_dev ) ; if ( ret ) return ret <S2SV_ModEnd> ; ret = gpiochip_add_pin_range ( & gpio_dev -> gc <S2SV_ModStart> : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> chunk_end - chunk -> skb -> data ) ; <S2SV_ModEnd> } } if ( ! chunk ) { struct <S2SV_ModStart> v = NULL ; if ( chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> > skb_tail_pointer ( chunk -> skb ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( "+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ia_valid & ATTR_SIZE ; if ( size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ia_size ) ; if ( status ) goto bail_unlock <S2SV_ModEnd> ; if ( i_size_read ( inode ) >= attr
<S2SV_ModStart> -> dentry = dentry ; path -> mnt = nd -> path . mnt <S2SV_ModEnd> ; if ( should_follow_link ( dentry , nd -> <S2SV_ModStart> -> flags & LOOKUP_FOLLOW ) ) return 1 ; mntget ( path -> mnt ) ;
<S2SV_ModStart> platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> : port -> port . count = 0 ; info -> port = NULL ;
<S2SV_ModStart> ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
<S2SV_ModStart> BUG_ON ( ! vma_can_userfault ( vma ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
<S2SV_ModStart> == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u64 mode = ( * ( u64 <S2SV_ModEnd> * ) valp ) & PSR_AA32_MODE_MASK ; switch ( <S2SV_ModStart> ; switch ( mode ) { case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
<S2SV_ModStart> offset ; struct iov_iter i ; struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> & pages [ cur_page ] ) ; if ( unlikely ( ret < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - EFAULT ; goto out_unmap ; } <S2SV_ModStart> ( bio ) ; return bio ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; } out : kfree ( pages )
<S2SV_ModStart> ( & stime -> running , 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime -> hrt ) ; hrtimer_start (
<S2SV_ModStart> ( & stime -> running , 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
<S2SV_ModStart> ; cdev_del ( cc -> cdev ) ; } fuse_conn_put ( & cc -> fc ) ;
<S2SV_ModStart> ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id <S2SV_ModStart> struct iwl_priv * priv , u8 sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , "invalid<S2SV_blank>sta_id<S2SV_blank>%u" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> . sta . sta . addr ) ; } return 0 ;
<S2SV_ModStart> = xfs_attr_rmtval_get ( & args ) ; if ( ! retval ) <S2SV_ModEnd> retval = context -> put_listent ( context , entry
<S2SV_ModStart> -> namelen ] ) ; if ( error ) { kmem_free ( sbuf ) ; return error ; } <S2SV_ModEnd> if ( context -> seen_enough ) break ; cursor
<S2SV_ModStart> ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ; <S2SV_ModEnd> result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev <S2SV_ModStart> , le16_to_cpu ( get_version_reply . build_no ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
<S2SV_ModStart> timer = & pit -> pit_state . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
<S2SV_ModStart> * tty , struct usb_serial_port * port ) { <S2SV_ModEnd> return usb_serial_generic_open ( tty , port ) ; }
<S2SV_ModStart> 0 , } ; char * command , * largs = NULL , * <S2SV_ModStart> if ( size == 0 ) return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> [ size - 1 ] != '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - EINVAL ; args = strim ( args ) ; command = strsep ( & args , "<S2SV_blank>" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , "current" ) == 0 ) { if ( strcmp ( command , "changehat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permhat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , "changeprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else if ( strcmp ( name , "exec" ) == 0 ) { if ( strcmp ( command , "exec" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; else goto fail ; } else goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error ; fail : sa . type <S2SV_ModStart> . info = name ; aad . error = error = <S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NM_I ( sbi ) ; struct free_nid * i , * e ; struct nat_entry * ne ; int err = - EINVAL ; bool ret = false <S2SV_ModEnd> ; if ( unlikely ( nid == 0 ) <S2SV_ModStart> ( nid == 0 ) ) return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> kgid_t group = new -> egid ; int ret ; if ( current_chrooted ( ) ) return - EPERM
<S2SV_ModStart> ( cmd -> device -> host ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> ) ; sas_end_task ( cmd , task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
<S2SV_ModStart> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n" , __func__ , task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; continue ; case TASK_IS_ABORTED : <S2SV_ModStart> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n" , __func__ , task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; continue ; case TASK_IS_AT_LU : <S2SV_ModStart> ) , cmd -> device -> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; sas_scsi_clear_queue_lu ( work_q , cmd
<S2SV_ModStart> -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; } } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; } if ( move_group ) { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if ( gctx -> task == TASK_TOMBSTONE <S2SV_ModStart> err = - ESRCH ; goto err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_unpin_context ( ctx ) ; if ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock ( & ctx -> mutex ) <S2SV_ModStart> return event_fd ; err_locked : if ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock ( & ctx -> mutex )
<S2SV_ModStart> ; struct kvm_vcpu * vcpu , * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
<S2SV_ModStart> i8042_lock , flags ) ; if ( likely ( serio <S2SV_ModEnd> && ! filtered ) ) serio_interrupt ( serio ,
<S2SV_ModStart> struct i8042_port * port = serio -> port_data ; spin_lock_irq ( & i8042_lock ) ; port -> exists = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct i8042_port * port = serio -> port_data ; spin_lock_irq ( & i8042_lock ) ; port -> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModEnd> ; synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ <S2SV_ModStart> ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> printk ( KERN_ERR "kvm_iommu_map_address:" "iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n" , pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn
<S2SV_ModStart> ( & net -> passive , 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
<S2SV_ModStart> void queue_delete ( struct snd_seq_queue * q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ( q -> timer ) ; snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
<S2SV_ModStart> = llc_sk ( sk ) ; int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( sllc ) ) ; lock_sock ( <S2SV_ModStart> goto out ; * uaddrlen = sizeof ( sllc <S2SV_ModEnd> ) ; if ( peer ) { rc =
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , ":<S2SV_blank>%zu<S2SV_blank>[%s]"
<S2SV_ModStart> key_payload_reserve ( key , 0 ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) && ( size_t ) key ->
<S2SV_ModStart> -> next , struct key , graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ) ; key_check ( key ) ; if ( state == KEY_IS_POSITIVE <S2SV_ModEnd> && key -> type -> destroy ) key -> <S2SV_ModStart> key -> user -> nkeys ) ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec ( & key -> user -> nikeys
<S2SV_ModStart> ; mutex_lock ( & key_construction_mutex ) ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret = key -> type -> instantiate <S2SV_ModStart> ( & key -> user -> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , &
<S2SV_ModStart> prep ) ; if ( ret == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write ( & key -> sem )
<S2SV_ModStart> } mutex_lock ( & key_construction_mutex ) ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_inc ( & key -> user -> <S2SV_ModStart> ( & key -> user -> nikeys ) ; mark_key_instantiated ( key , - error <S2SV_ModEnd> ) ; now = current_kernel_time ( ) ; key
<S2SV_ModStart> prep ) ; if ( ret == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write ( & key -> sem )
<S2SV_ModStart> seq_puts ( m , "[anon]" ) ; if ( key_is_positive <S2SV_ModEnd> ( keyring ) ) { if ( keyring ->
<S2SV_ModStart> keyring_ptr_to_key ( object ) ; unsigned long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( "{%d}" , key -> serial ) <S2SV_ModStart> ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( state < 0 ) { ctx -> result = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]" , ctx -> skipped_ret
<S2SV_ModStart> if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key ; ret = key_task_permission ( key_ref
<S2SV_ModStart> ; if ( ret ) return - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate ( key ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , "<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , ":<S2SV_blank>%u"
<S2SV_ModStart> -> expiry = prep -> expiry ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap = dereference_key_locked ( key ) ;
<S2SV_ModStart> BUG ( ) ; BUG_ON ( ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> primary , new ) ; synchronize_rcu ( ) ; unlock :
<S2SV_ModStart> mutex_unlock ( & key_construction_mutex ) ; if ( keyring && link_ret == 0
<S2SV_ModStart> -> wq . entry , & fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_ModEnd> spin_lock ( & ctx -> event_wqh . lock ) <S2SV_ModStart> ( ! list_empty ( & fork_event ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> -> event_wqh , & uwq -> wq ) ; if ( likely ( ! ret ) ) userfaultfd_event_complete ( ctx , uwq ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
<S2SV_ModStart> size ) ; if ( ret != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> follow_dotdot ( struct nameidata * nd ) { if <S2SV_ModStart> . dentry ) ; dput ( old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> = nd -> path . dentry -> d_inode ; return 0 ;
<S2SV_ModStart> = parent ; nd -> seq = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
<S2SV_ModStart> { return follow_dotdot_rcu ( nd ) ; } else return
<S2SV_ModStart> struct vcpu_data vcpu_info ; int idx , ret = 0 <S2SV_ModEnd> ; if ( ! kvm_arch_has_assigned_device ( kvm ) || <S2SV_ModStart> -> irq_routing , & kvm -> irq_srcu ) ; if ( guest_irq >= irq_rt -> nr_rt_entries || hlist_empty ( & irq_rt -> map [ guest_irq ] ) ) { pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } <S2SV_ModEnd> hlist_for_each_entry ( e , & irq_rt -> map [
<S2SV_ModStart> timer , 1 ) ; # endif _end : <S2SV_ModEnd> kill_fasync ( & runtime -> fasync , SIGIO , <S2SV_ModStart> runtime -> fasync , SIGIO , POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;
<S2SV_ModStart> void acpi_ns_terminate ( void ) { acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * prev ; union acpi_operand_object * next <S2SV_ModStart> union acpi_operand_object * prev ; union acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> = NULL ; acpi_ut_remove_reference ( prev ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex (
<S2SV_ModStart> ; struct scatterlist sg [ 3 ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen , err ; err = format_input
<S2SV_ModStart> , offset , bytes ) ; flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart> length = tmp ; req -> num_pages ++ ; <S2SV_ModEnd> count += tmp ; pos += tmp ; offset
<S2SV_ModStart> ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr = 0x800 ; msr <= 0x8ff <S2SV_ModStart> ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_ModEnd> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull ,
<S2SV_ModStart> ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
<S2SV_ModStart> ) ) msr_bitmap = vmx_msr_bitmap_nested ; else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if ( is_long_mode ( vcpu ) )
<S2SV_ModStart> pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> ) ; kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT
<S2SV_ModStart> kvm_memory_slot * slot , gfn_t gfn , unsigned long npages <S2SV_ModEnd> ) { gfn_t end_gfn ; pfn_t pfn ; pfn <S2SV_ModStart> slot , gfn ) ; end_gfn = gfn + npages <S2SV_ModEnd> ; gfn += 1 ; if ( is_error_noslot_pfn (
<S2SV_ModStart> * st = d -> priv ; int ret <S2SV_ModEnd> ; if ( 1 + wlen > MAX_XFER_SIZE ) <S2SV_ModStart> , wlen ) ; return - EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & d -> data_mutex ) ; st <S2SV_ModStart> [ 1 ] , wbuf , wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw ( d , st -> data <S2SV_ModStart> , st -> data , 1 + wlen , st -> data , rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen <S2SV_ModEnd> ) ; mutex_unlock ( & d -> data_mutex )
<S2SV_ModStart> ; haddr -> hci_dev = hdev -> id ; haddr -> hci_channel = 0 ;
<S2SV_ModStart> if ( ! addr ) return - ENODEV ; <S2SV_ModEnd> switch ( io -> regsize ) { case 1 <S2SV_ModStart> -> io_size ) ; return - EIO ; } io -> io_cleanup = mem_cleanup ;
<S2SV_ModStart> ; if ( ! addr ) return - ENODEV <S2SV_ModEnd> ; switch ( io -> regsize ) { case <S2SV_ModStart> regsize ) ; return - EIO ; } } io -> io_cleanup = port_cleanup ;
<S2SV_ModStart> struct iso_directory_record * de , struct inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = parse_rock_ridge_inode_internal ( de , inode , <S2SV_ModStart> int result = parse_rock_ridge_inode_internal ( de , inode , flags <S2SV_ModEnd> ) ; if ( ( ISOFS_SB ( inode -> <S2SV_ModStart> { result = parse_rock_ridge_inode_internal ( de , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; } return result ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * de , struct inode * inode , int flags <S2SV_ModEnd> ) { int symlink_len = 0 ; int cnt <S2SV_ModStart> int symlink_len = 0 ; int cnt , sig ; unsigned int reloc_block <S2SV_ModStart> , inode , & rs ) ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs . chr += 14 ; rs <S2SV_ModStart> ; case SIG ( 'C' , 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block ; reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block <S2SV_ModEnd> , 0 ) ; if ( IS_ERR ( reloc
<S2SV_ModStart> int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> sizeof ( info ) ) ) return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL
<S2SV_ModStart> [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; int i <S2SV_ModStart> return - EFAULT ; else info = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
<S2SV_ModStart> ) ; if ( PageDirty ( page ) ) SetPageDirty ( newpage ) ; <S2SV_ModEnd> if ( page_is_young ( page ) ) set_page_young (
<S2SV_ModStart> , enum migrate_mode mode , int extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> SetPageSwapBacked ( newpage ) ; return MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> newpage , page_private ( page ) ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> page_unfreeze_refs ( page , expected_count - 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone , NR_FILE_PAGES ) ; __inc_zone_state ( newzone , NR_FILE_PAGES ) ; if ( PageSwapBacked ( page ) && ! PageSwapCache ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return MIGRATEPAGE_SUCCESS ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( nsock ) ; return - EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
<S2SV_ModStart> , insn -> dst_reg ) ; break ; } <S2SV_ModEnd> dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value <S2SV_ModStart> = S64_MIN ; dst_reg -> smax_value = S64_MAX ; <S2SV_ModEnd> if ( src_known ) dst_reg -> var_off = tnum_rshift
<S2SV_ModStart> ( "clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( "execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n" , args -> num_cliprects ) ; return - EINVAL ; }
<S2SV_ModStart> * saddr = NULL , * final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> sk , flowi6_to_flowi ( & fl6 ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; final_p = fl6_update_dst ( & fl6 , <S2SV_ModEnd> opt , & final ) ; dst = ip6_dst_lookup_flow <S2SV_ModStart> ; icsk -> icsk_ext_hdr_len = 0 ; if ( opt ) icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen <S2SV_ModEnd> ; inet -> inet_dport = usin -> sin6_port ;
<S2SV_ModStart> struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; <S2SV_ModStart> newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen <S2SV_ModEnd> ; dccp_sync_mss ( newsk , dst_mtu ( dst )
<S2SV_ModStart> req , flowi6_to_flowi ( & fl6 ) ) ; rcu_read_lock ( ) ; final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst = ip6_dst_lookup_flow ( sk , & <S2SV_ModStart> ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; err = net_xmit_eval ( err ) ;
<S2SV_ModStart> & ( MSG_OOB ) ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> RCV_SHUTDOWN ) return 0 ; return err ; } <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg . smin_value ; smax_val = src_reg <S2SV_ModStart> ; break ; case BPF_LSH : if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown ( env , regs , insn <S2SV_ModStart> ; break ; case BPF_RSH : if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown ( env , regs , insn <S2SV_ModStart> , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
<S2SV_ModStart> do { if ( frags >= work_to_do ) { netdev_err ( vif -> dev , "Need<S2SV_blank>more<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } if ( <S2SV_ModStart> ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { netdev_err ( vif -> dev , "Too<S2SV_blank>many<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } memcpy ( <S2SV_ModStart> txp -> size > first -> size ) { netdev_err ( vif -> dev , "Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } first -> <S2SV_ModStart> txp -> size ) > PAGE_SIZE ) ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n" , txp -> <S2SV_ModStart> "txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n" , txp -> offset , txp -> size ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> gso -> u . gso . size ) { netdev_err ( vif -> dev , "GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - EINVAL ; } if ( <S2SV_ModStart> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n" , gso -> <S2SV_ModStart> "Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n" , gso -> u . gso . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> unlikely ( work_to_do -- <= 0 ) ) { netdev_err ( vif -> dev , "Missing<S2SV_blank>extra<S2SV_blank>info\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - EBADR ; } memcpy ( <S2SV_ModStart> vif -> tx . req_cons = ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> dev , "Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n" , extra . <S2SV_ModStart> vif -> dev , "Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n" , extra . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) ; if ( ! vif ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , "Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>" "req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> if ( unlikely ( work_to_do < 0 ) ) continue ; <S2SV_ModEnd> } ret = netbk_count_requests ( vif , & txreq <S2SV_ModStart> if ( unlikely ( ret < 0 ) ) continue ; <S2SV_ModEnd> idx += ret ; if ( unlikely ( txreq <S2SV_ModStart> txreq . size ) > PAGE_SIZE ) ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n" , txreq . <S2SV_ModStart> ~ PAGE_MASK ) + txreq . size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue ; } index = pending_index ( <S2SV_ModStart> gso ) ) { kfree_skb ( skb ) ; <S2SV_ModEnd> continue ; } } page = xen_netbk_alloc_page ( netbk
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct rtattr * * tb , u32 <S2SV_ModStart> ; if ( IS_ERR ( algt ) ) return false ; * type |= algt -> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & CRYPTO_ALG_INTERNAL ; if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; u32 mask = 0 ; int err ; if ( ! <S2SV_ModStart> ( tb , & type , & mask ) ) return - EINVAL
<S2SV_ModStart> if ( type == ACL_TYPE_ACCESS ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; } inode -> i_ctime = current_time ( inode
<S2SV_ModStart> ( tp ) ; inet_csk_delack_init ( sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> ; bool is_dir = d_is_dir ( old_dentry ) ; <S2SV_ModEnd> struct inode * source = old_dentry -> d_inode ; <S2SV_ModStart> unsigned max_links = new_dir -> i_sb -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> ) ; if ( error ) return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return error ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( p_inode -> i_fsnotify_mask & mask ) { struct name_snapshot name ; mask |= FS_EVENT_ON_CHILD ; take_dentry_name_snapshot ( & name , dentry ) <S2SV_ModEnd> ; if ( path ) ret = fsnotify ( <S2SV_ModStart> ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , name <S2SV_ModEnd> . name , 0 ) ; else ret = <S2SV_ModStart> , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , name . name , 0 ) ; release_dentry_name_snapshot ( & name <S2SV_ModEnd> ) ; } dput ( parent ) ; return
<S2SV_ModStart> tlb , vma , pmd , addr ) ) goto next ; } if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) goto next <S2SV_ModEnd> ; next = zap_pte_range ( tlb , vma , <S2SV_ModStart> pmd , addr , next , details ) ; next :
<S2SV_ModStart> >> PAGE_SHIFT ; continue ; } } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) mincore_unmapped_range ( vma , addr
<S2SV_ModStart> walk -> mm , pmd ) ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) goto again ; err =
<S2SV_ModStart> pmd_addr_end ( addr , end ) ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) continue ; ret = unuse_pte_range
<S2SV_ModStart> [ 24 ] ) ; out : kfree ( req ) ; kfree (
<S2SV_ModStart> * rsize ) { if ( * rsize >= 18 <S2SV_ModEnd> && rdesc [ 11 ] == 0x3c && rdesc
<S2SV_ModStart> { case USB_DEVICE_ID_KYE_ERGO_525V : if ( * rsize >= 75 <S2SV_ModEnd> && rdesc [ 61 ] == 0x05 && rdesc
<S2SV_ModStart> -> quirks & LG_RDESC ) && * rsize >= 91 <S2SV_ModEnd> && rdesc [ 83 ] == 0x26 && rdesc <S2SV_ModStart> -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 51 <S2SV_ModEnd> && rdesc [ 32 ] == 0x81 && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 31 <S2SV_ModEnd> && rdesc [ 29 ] == 0x05 && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 62 <S2SV_ModEnd> && rdesc [ 39 ] == 0x2a && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 112 <S2SV_ModEnd> && rdesc [ 104 ] == 0x26 && rdesc
<S2SV_ModStart> alg_sock * ask2 ; struct hash_ctx * ctx2 ; bool more ; int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? crypto_ahash_export ( req , state ) : 0 ; release_sock ( sk ) <S2SV_ModEnd> ; if ( err ) return err ; err <S2SV_ModStart> = ask2 -> private ; ctx2 -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err = crypto_ahash_import ( & ctx2 -> req
<S2SV_ModStart> ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
<S2SV_ModStart> ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i = 0 ; i < HASHBIN_SIZE <S2SV_ModStart> ; i < HASHBIN_SIZE ; i ++ ) { while ( 1 ) { <S2SV_ModStart> & hashbin -> hb_queue [ i ] ) ; if ( ! queue ) break ; if ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } } } <S2SV_ModEnd> hashbin -> hb_current = NULL ; hashbin -> magic <S2SV_ModStart> ; if ( hashbin -> hb_type & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) <S2SV_ModStart> ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> kfree ( hashbin ) ; return 0 ; }
<S2SV_ModStart> dev , int voice , int value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
<S2SV_ModStart> voice , int chn ) { struct channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct key * * _dest_keyring ) { <S2SV_ModStart> * dest_keyring = * _dest_keyring , * authkey ; int ret ; <S2SV_ModStart> { key_get ( dest_keyring ) ; } else { bool do_perm_check = true ; <S2SV_ModStart> authkey -> sem ) ; if ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred <S2SV_ModStart> KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> "<S2SV_blank>[dk<S2SV_blank>%d]" , key_serial ( dest_keyring ) ) ; return 0
<S2SV_ModStart> key_type_keyring ) return ERR_PTR ( - EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ( ) ) ; if ( ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key ( ctx , dest_keyring , flags <S2SV_ModStart> { ret = 0 ; } else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put ( dest_keyring ) ; kleave ( <S2SV_ModStart> , NULL ) ; key_put ( key ) ; error_put_dest_keyring : key_put ( dest_keyring ) ; error : <S2SV_ModEnd> kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ERR_PTR
<S2SV_ModStart> if ( len > INT_MAX ) len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
<S2SV_ModStart> if ( size > INT_MAX ) size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
<S2SV_ModStart> ; case SIG ( 'E' , 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
<S2SV_ModStart> ; } if ( need_dev ) { if ( ! dev_name ||
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static unsigned long stack_maxrandom_size ( void ) { unsigned long <S2SV_ModEnd> max = 0 ; if ( ( current -> <S2SV_ModStart> ADDR_NO_RANDOMIZE ) ) { max = ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK ) << PAGE_SHIFT ; } return
<S2SV_ModStart> mct_u232_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct mct_u232_private * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , "expected<S2SV_blank>endpoint<S2SV_blank>missing\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> priv = kzalloc ( sizeof ( * priv ) <S2SV_ModStart> ) return - ENOMEM ; priv -> read_urb = <S2SV_ModEnd> serial -> port [ 1 ] -> interrupt_in_urb ;
<S2SV_ModStart> ; rcu_read_unlock ( ) ; return ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> le16_to_cpu ( udev -> descriptor . idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> out_buf ) return - ENOMEM ; if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2 ) count = DJREPORT_SHORT_LENGTH - 2
<S2SV_ModStart> ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif }
<S2SV_ModStart> ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
<S2SV_ModStart> , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
<S2SV_ModStart> error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
<S2SV_ModStart> 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
<S2SV_ModStart> -> flags = IFF_NOARP | IFF_POINTOPOINT ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; } } payload = NULL ; if ( plen <S2SV_ModEnd> ) { ret = - ENOMEM ; payload =
<S2SV_ModStart> nodemask_t * nodemask , unsigned long totalpages ) { long <S2SV_ModEnd> points ; if ( oom_unkillable_task ( p , mem
<S2SV_ModStart> } if ( pmd_trans_unstable ( pmd ) ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto out ; } ptep = pte_offset_map_lock <S2SV_ModStart> ptep ; if ( pte_none ( pte ) ) * vec = 0 <S2SV_ModEnd> ; else if ( pte_present ( pte ) ) <S2SV_ModStart> { swp_entry_t entry = pte_to_swp_entry ( pte ) ; * vec = ! ! non_swap_entry ( entry ) ; <S2SV_ModEnd> } vec ++ ; } pte_unmap_unlock ( ptep -
<S2SV_ModStart> long end , struct mm_walk * walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; walk -> private += nr <S2SV_ModEnd> ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> page ) ) ; if ( locked_vma ) { if ( page == check_page ) { mlock_vma_page ( page ) ; ret = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; } <S2SV_ModEnd> continue ; } if ( ptep_clear_flush_young_notify ( vma ,
<S2SV_ModStart> - ( addr + 5 ) ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif return len ; } <S2SV_ModEnd> b -> opcode = 0xe8 ; b -> delta
<S2SV_ModStart> 5 ) ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif return len ; } <S2SV_ModEnd> b -> opcode = 0xe9 ; b -> delta
<S2SV_ModStart> & miux , 0 , & miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & rw , 0 , & rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> , sock -> service_name_len , & service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & miux , 0 , & miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & rw , 0 , & rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> nfc_llcp_local * local ) { u8 * gb_cur , version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> ; __be16 wks = cpu_to_be16 ( local -> local_wks <S2SV_ModStart> & version , 1 , & version_length ) ; if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> -> lto , 1 , & lto_length ) ; if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> & wks , 2 , & wks_length ) ; if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> -> miux , 0 , & miux_length ) ; if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; }
<S2SV_ModStart> , buffer -> cpumask ) ) return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if ( atomic_read ( & buffer -> resize_disabled
<S2SV_ModStart> IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page ) ; goto out ; }
<S2SV_ModStart> ( pskb_expand_head ( skb_out , 0 , size - skb_out <S2SV_ModEnd> -> len , GFP_ATOMIC ) < 0 ) {
<S2SV_ModStart> ) { unsigned long nr_pages , i ; size_t bytes , <S2SV_ModStart> ; i < nr_pages ; i ++ ) { bytes <S2SV_ModEnd> = min_t ( const size_t , cur_len , PAGE_SIZE <S2SV_ModStart> [ i ] , & it , 0 , bytes <S2SV_ModEnd> ) ; cur_len -= copied ; iov_iter_advance ( & <S2SV_ModStart> ; iov_iter_advance ( & it , copied ) ; if ( copied < bytes ) break ; } cur_len = save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) <S2SV_ModEnd> ; wdata -> sync_mode = WB_SYNC_ALL ; wdata ->
<S2SV_ModStart> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; first_source = source_mnt
<S2SV_ModStart> else { struct mount * n , * p ; bool done <S2SV_ModStart> p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE ; if ( IS_MNT_SHARED ( m
<S2SV_ModStart> ( p ) ; if ( ret < 0 && ! p -> skip_release_on_error
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root
<S2SV_ModStart> , int flags ) { struct btrfs_dir_item * di = NULL <S2SV_ModStart> if ( ! path ) return - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; goto out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( ! di ) { ret = - ENODATA ; goto out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item ( <S2SV_ModEnd> trans , root , path , btrfs_ino ( inode <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { goto out ; } if ( di && ( flags & XATTR_CREATE ) ) { ret = - EEXIST ; goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC ; goto out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out : btrfs_free_path ( path ) ; return
<S2SV_ModStart> res = - ENOTCONN ; goto exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> res = - ENOTCONN ; goto exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> family = AF_TIPC ; addr -> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
<S2SV_ModStart> -> vbd . bdev ; unsigned long secure ; struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX "access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> discard . nr_sectors , GFP_KERNEL , secure ) ; fail_response :
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe == NULL <S2SV_ModStart> - EIO ; if ( dvb_attach ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , & <S2SV_ModStart> ] . fe , & dw2104_ts2020_config , & d <S2SV_ModEnd> -> i2c_adap ) ) { info ( "Attached<S2SV_blank>RS2000/TS2020!" )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe == NULL <S2SV_ModStart> - EIO ; if ( dvb_attach ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , & <S2SV_ModStart> ] . fe , & dw2104_ts2020_config , & d <S2SV_ModEnd> -> i2c_adap ) ) { info ( "Attached<S2SV_blank>DS3000/TS2020!" )
<S2SV_ModStart> dvb_usb_device * d = i2c_get_adapdata ( adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( ! d ) return - ENODEV <S2SV_ModStart> if ( ! d ) return - ENODEV ; state = d -> priv ; <S2SV_ModStart> i2c_mutex ) < 0 ) return - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> 0 ] . addr ) { case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] = msg [ 0 ] . <S2SV_ModStart> ] . buf [ 0 ] + 0x36 ; state -> data [ 1 ] = 3 ; state -> data <S2SV_ModEnd> [ 2 ] = 0 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 0 , 0 ) < 0 ) err <S2SV_ModStart> ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; break ; case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] = 0x10 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0x10 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , 0 ) < 0 ) err <S2SV_ModStart> [ 0 ] . buf [ 1 ] = state -> data <S2SV_ModEnd> [ 0 ] ; msg [ 0 ] . <S2SV_ModStart> [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ; break ; default : state -> data [ 0 ] = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] = msg [ 0 ] . <S2SV_ModStart> ] = msg [ 0 ] . addr ; state -> data <S2SV_ModEnd> [ 2 ] = msg [ 0 ] . <S2SV_ModStart> [ 0 ] . len ; memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] , msg [ 0 ] . <S2SV_ModStart> len ) ; if ( dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , msg [ 0 ] . len + 3 <S2SV_ModStart> msg [ 0 ] . len + 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; } break ; case 2 : state -> data [ 0 ] = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] = msg [ 1 ] . <S2SV_ModStart> ] = msg [ 1 ] . len ; state -> data <S2SV_ModEnd> [ 3 ] = msg [ 0 ] . <S2SV_ModStart> [ 0 ] . addr ; memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] , msg [ 0 ] . <S2SV_ModStart> len ) ; if ( dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , msg [ 0 ] . len + 4 <S2SV_ModStart> msg [ 0 ] . len + 4 , state -> data <S2SV_ModEnd> , msg [ 1 ] . len + 1 <S2SV_ModStart> ( msg [ 1 ] . buf , & state -> data <S2SV_ModEnd> [ 1 ] , msg [ 1 ] . <S2SV_ModStart> ; break ; } mutex_unlock ( & d -> data_mutex ) ; mutex_unlock ( & d ->
<S2SV_ModStart> ( struct dw2102_state * ) d -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( "%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d" , __func__ , i , <S2SV_ModStart> ( i && ! state -> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; state -> initialized = 1 ; ret = dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 2 , NULL , 0 , 0 ) <S2SV_ModStart> 2 , NULL , 0 , 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int t220_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 50 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( cxd2820r_attach , & cxd2820r_config , & d -> i2c_adap , NULL ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe != NULL <S2SV_ModStart> NULL ) { if ( dvb_attach ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , 0x60 <S2SV_ModStart> 0 ] . fe , 0x60 , & d <S2SV_ModEnd> -> i2c_adap , & tda18271_config ) ) { info
<S2SV_ModStart> struct dw2102_state * state = d -> priv ; <S2SV_ModEnd> struct i2c_adapter * i2c_adapter ; struct i2c_client * client <S2SV_ModStart> } ; struct ts2020_config ts2020_config = { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] = 1 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] = 0 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] = 1 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> , 0 ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex
<S2SV_ModStart> -> list ) ; kfree ( pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> * * new_cred ) { struct cred * cred ; int err = - ENOMEM <S2SV_ModStart> ; cred = prepare_creds ( ) ; if ( cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else * new_cred = cred ; } return err <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( src ) ; flush_spe_to_thread ( src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
<S2SV_ModStart> struct iovec * ) _iov ; size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> unlikely ( total_len == 0 ) ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> struct pipe_buf_operations * ops = buf -> ops ; size_t chars = buf -> len ; size_t written ; int error <S2SV_ModEnd> ; if ( chars > total_len ) chars = <S2SV_ModStart> ret ) ret = error ; break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; } ret += chars ; buf
<S2SV_ModStart> } mark_discard_range_all ( sbi ) ; f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> <S2SV_null> <S2SV_null> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount <S2SV_ModStart> __drop_discard_cmd ( sbi ) ; __wait_discard_cmd ( sbi , ! umount <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , & cpc ) ; } f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( iova < mem -> iova || length > mem -> length || iova > mem -> iova + mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default : return - EFAULT ; }
<S2SV_ModStart> * sdp = GFS2_SB ( inode ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ptrs_per_blk ; const unsigned end_of_metadata = height - 1 ; int ret <S2SV_ModStart> ptr ++ = cpu_to_be64 ( bn ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , "Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n" ) ; clear_buffer_zeronew ( bh_map ) ; } }
<S2SV_ModStart> ; struct buffer_head * dibh ; int error ; unsigned int nr_blks ; sector_t lblock = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if ( offset + len <S2SV_ModEnd> > inode -> i_size && ! ( mode & <S2SV_ModStart> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) i_size_write ( inode , offset + len ) ; mark_inode_dirty ( inode ) ; out : brelse ( dibh ) ; <S2SV_ModEnd> return error ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 1 ) >> sdp -> sd_sb . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> } max_bytes = bytes ; calc_max_reserv ( ip , ( len > max_chunk_size ) ? max_chunk_size :
<S2SV_ModStart> = - EPERM ; if ( ! new_idmap_permitted ( file ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static bool new_idmap_permitted ( const struct file * file , <S2SV_ModStart> ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid )
<S2SV_ModStart> type ) { struct hexline * hx ; u8 * buf ; int ret , pos = 0 ; u16 cpu_cs_register = cypress [ type ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 ) err ( "could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU." ) ; <S2SV_ModStart> "firmware<S2SV_blank>download<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>%d" , pos , ret ) ; kfree ( buf <S2SV_ModEnd> ) ; return ret ; } if ( ret <S2SV_ModStart> ; } if ( ret == 0 ) { buf [ 0 ] = 0 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) != 1 ) { err ( <S2SV_ModStart> } else ret = - EIO ; kfree ( buf <S2SV_ModEnd> ) ; return ret ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> activation_params . nfca_poll_iso_dep ; nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ) <S2SV_ModEnd> ; pr_debug ( "rats_res_len<S2SV_blank>%d\\n" , nfca_poll -> rats_res_len ) <S2SV_ModStart> -> activation_params . nfcb_poll_iso_dep ; nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ) <S2SV_ModEnd> ; pr_debug ( "attrib_res_len<S2SV_blank>%d\\n" , nfcb_poll -> attrib_res_len )
<S2SV_ModStart> ; data += 2 ; nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n" , nfca_poll -> sens_res ,
<S2SV_ModStart> __u8 * data ) { nfcb_poll -> sensb_res_len = min_t ( __u8 , * data ++ , NFC_SENSB_RES_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "sensb_res_len<S2SV_blank>%d\\n" , nfcb_poll -> sensb_res_len )
<S2SV_ModStart> = * data ++ ; nfcf_poll -> sensf_res_len = min_t ( __u8 , * data ++ , NFC_SENSF_RES_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\n" , nfcf_poll -> bit_rate ,
<S2SV_ModStart> MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ; if ( err ) goto out ; <S2SV_ModEnd> if ( msg -> msg_name ) { struct sockaddr_vm
<S2SV_ModStart> , __func__ ) ; return ; } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n" , __func__ ) ; return ; } if ( <S2SV_ModStart> "%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n" , __func__ ) ; } else if ( ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 <S2SV_ModEnd> ) ; command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up
<S2SV_ModStart> ; ptr = ( void * ) val ; <S2SV_ModEnd> memset ( ptr , 0 , size ) ;
<S2SV_ModStart> ) ; addr = page_address ( page ) ; <S2SV_ModEnd> memset ( addr , 0 , size ) ;
<S2SV_ModStart> ext4_put_nojournal ( handle ) ; return 0 ; } err = handle -> h_err ; if ( ! handle -> h_transaction ) { rc = jbd2_journal_stop ( handle ) ; return err ? err : rc <S2SV_ModEnd> ; } sb = handle -> h_transaction -> t_journal <S2SV_ModStart> sb = handle -> h_transaction -> t_journal -> j_private <S2SV_ModEnd> ; rc = jbd2_journal_stop ( handle ) ; if
<S2SV_ModStart> * child , struct task_struct * new_parent ) { __ptrace_link ( child , new_parent , current_cred ( ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> } ufs -> lower_namelen = statfs . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> & resp_buftype , flags , & rsp_iov ) ; <S2SV_ModEnd> rsp = ( struct smb2_write_rsp * ) rsp_iov . <S2SV_ModStart> io_parms -> offset , * nbytes ) ; } cifs_small_buf_release ( req ) ;
<S2SV_ModStart> ) ; for ( i = 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i ++ ) { ret = serdes_phy_create
<S2SV_ModStart> ] ; for ( i = 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i ++ ) { struct serdes_macro *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer <S2SV_ModStart> * pipe , struct pipe_buffer * buf ) { return try_get_page <S2SV_ModEnd> ( buf -> page ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> & ( opipe -> buffers - 1 ) ; if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe -> bufs + nbuf ; *
<S2SV_ModStart> -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf = * ibuf ; obuf -> flags
<S2SV_ModStart> retry ; } if ( flags & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags & FOLL_TOUCH ) { if (
<S2SV_ModStart> ) ret = - EBUSY ; } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl ) ; lock_page ( page )
<S2SV_ModStart> ( * page ) ) goto unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret = 0 ; unmap : pte_unmap
<S2SV_ModStart> = pte_page ( huge_ptep_get ( pte ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> < exec_size ) { DRM_ERROR ( "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> { signo = SIGCHLD ; err = 0 ; if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> interface_to_usbdev ( usbif ) ; int brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness = data [ 4 ] ; <S2SV_ModStart> , "Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n" , data [ 4 ] ) ; ret = - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> interface_to_usbdev ( usbif ) ; int current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile = data [ 7 ] ; <S2SV_ModStart> , "Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n" , data [ 7 ] ) ; ret = - EIO ; goto out ; } ret = <S2SV_ModEnd> snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile <S2SV_ModStart> buf , PAGE_SIZE , "%d\\n" , current_profile ) ; out : kfree ( data ) ; return ret ;
<S2SV_ModStart> usbif ) ; const char * macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } switch ( data [ 0 ] ) <S2SV_ModStart> , "K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n" , data [ 0 ] ) ; ret = - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( * req ) ) return - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
<S2SV_ModStart> struct file * file = vma -> vm_file ; * prev = vma ; <S2SV_ModStart> # ifdef CONFIG_SWAP if ( ! file ) { <S2SV_ModEnd> force_swapin_readahead ( vma , start , end ) ; <S2SV_ModStart> ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma , start , end , file <S2SV_ModStart> file ) ) ) { return 0 ; } <S2SV_ModEnd> start = ( ( start - vma -> vm_start
<S2SV_ModStart> & balloon_mutex ) ; return 0 ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
<S2SV_ModStart> ) ; } if ( credit < 0 ) { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; state = decrease_reservation ( n_pages , GFP_BALLOON ) ; if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; } <S2SV_ModEnd> state = update_schedule ( state ) ; mutex_unlock (
<S2SV_ModStart> ) ; if ( err ) goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> ; filp -> f_pos ++ ; case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> i_ino ) { printk ( KERN_ERR "hfs:<S2SV_blank>walked<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>dir\\n" ) ; err = - EIO ; goto out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {
<S2SV_ModStart> futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
<S2SV_ModStart> USB_DT_SECURITY , ( void * * ) & secd , sizeof ( * secd )
<S2SV_ModStart> nr = pagevec_count ( pvec ) ; int delta_munlocked = - nr <S2SV_ModStart> continue ; else __munlock_isolation_failed ( page ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> -> pages [ i ] = NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;
<S2SV_ModStart> ; port_subs_info_init ( & new_port -> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> ; new_port -> addr . port = num ; sprintf ( new_port -> name , "port-%d" , num ) ; <S2SV_ModStart> ; mutex_unlock ( & client -> ports_mutex ) ; <S2SV_ModEnd> return new_port ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( current -> active_mm != mm ) { smp_mb ( ) ; goto out ; } <S2SV_ModEnd> if ( ! current -> mm ) { leave_mm <S2SV_ModStart> ) { leave_mm ( smp_processor_id ( ) ) ; smp_mb ( ) ;
<S2SV_ModStart> mm ) { if ( current -> mm ) { __flush_tlb_one ( start ) ; } else { leave_mm ( smp_processor_id ( ) ) ; smp_mb ( ) ; } <S2SV_ModEnd> } if ( cpumask_any_but ( mm_cpumask ( mm )
<S2SV_ModStart> ] ; int err ; BT_DBG ( "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD
<S2SV_ModStart> ; if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
<S2SV_ModStart> int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
<S2SV_ModStart> < ds ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0
<S2SV_ModStart> t_prefer_loopback ) { trans = & rds_loop_transport ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ;
<S2SV_ModStart> iov_page ) ; out_iov = in_iov + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
<S2SV_ModStart> , GFP_KERNEL ) ; if ( pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> = kzalloc ( sizeof ( struct pipe_buffer ) * pipe_bufs , GFP_KERNEL ) ; } <S2SV_ModEnd> if ( pipe -> bufs ) { init_waitqueue_head ( <S2SV_ModStart> -> w_counter = 1 ; pipe -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( & pipe -> mutex ) ; <S2SV_ModStart> pipe -> mutex ) ; return pipe ; } free_uid ( user ) ;
<S2SV_ModStart> ( struct pipe_inode_info * pipe ) { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> ret = - EPERM ; goto out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> * sizeof ( struct pipe_buffer ) ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> * tp = tcp_sk ( sk ) ; u32 count , <S2SV_ModStart> HZ ; if ( now != challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; challenge_timestamp = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK )
<S2SV_ModStart> struct inode * inode ; struct path path ; uid_t check_ruid ; <S2SV_ModStart> ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid <S2SV_ModStart> "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" "known<S2SV_blank>incompatibilities\\n" ) ; goto out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }
<S2SV_ModStart> ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid <S2SV_ModStart> fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; * check_ruid = 0 <S2SV_ModStart> ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1
<S2SV_ModStart> private ; struct vm_area_struct * vma = v ; if ( ! IS_ERR ( vma ) )
<S2SV_ModStart> ( ref , struct ipmi_user , refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
<S2SV_ModStart> struct ipmi_user * user ) { _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put ( & user -> refcount ,
<S2SV_ModStart> * udev , struct usb_interface * intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_ModStart> alt = uas_find_uas_alt_setting ( intf ) ; if ( ! alt ) return - ENODEV ; return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> . expires += incr ; timer -> it_overrun += 1LL <S2SV_ModEnd> << i ; delta -= incr ; } }
<S2SV_ModStart> ! timr ) return - EINVAL ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer ( timr , flags ) ; return
<S2SV_ModStart> -> it_interval ) return ; timr -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer , timer -> base -> get_time
<S2SV_ModStart> REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += <S2SV_ModEnd> kc -> timer_forward ( timr , now ) ;
<S2SV_ModStart> kclock = kc ; new_timer -> it_overrun = - 1LL <S2SV_ModEnd> ; if ( event ) { rcu_read_lock ( )
<S2SV_ModStart> ) ; } # endif timr -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer , now , timr -> it_interval
<S2SV_ModStart> timr -> it_overrun ; timr -> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr -> it_requeue_pending ; info -> si_overrun <S2SV_ModStart> ; ++ timr -> it_requeue_pending ; info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer ( timr , flags ) ;
<S2SV_ModStart> : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return - EINVAL ; * vm_flags &= <S2SV_ModStart> : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return - EINVAL ; * vm_flags &=
<S2SV_ModStart> chan ; BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
<S2SV_ModStart> log_file ) { filep = d -> log_file ; d -> log_file = eventfp ;
<S2SV_ModStart> sk ; struct irda_sock * self ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> endif struct cred * new ; int ret ; p -> replacement_session_keyring = NULL ;
<S2SV_ModStart> ( ! unqueue_me ( & q ) ) goto out <S2SV_ModEnd> ; ret = - ETIMEDOUT ; if ( to <S2SV_ModStart> ( to && ! to -> task ) goto out <S2SV_ModEnd> ; if ( ! signal_pending ( current ) ) <S2SV_ModStart> ; if ( ! signal_pending ( current ) ) goto retry ; <S2SV_ModEnd> ret = - ERESTARTSYS ; if ( ! abs_time <S2SV_ModStart> - ERESTARTSYS ; if ( ! abs_time ) goto out <S2SV_ModEnd> ; restart = & current_thread_info ( ) -> restart_block <S2SV_ModStart> flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if ( to ) { hrtimer_cancel (
<S2SV_ModStart> futex_q * q ) { struct futex_hash_bucket * hb <S2SV_ModEnd> ; hb = hash_futex ( & q -> key
<S2SV_ModStart> { spin_unlock ( & hb -> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < sizeof ( tfrc ) ) return - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) )
<S2SV_ModStart> retval ; retval = xfs_attr_shortform_remove ( args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX
<S2SV_ModStart> ) return tmp ; } if ( in ) <S2SV_ModEnd> dev -> in_pipe = usb_rcvbulkpipe ( udev , in <S2SV_ModStart> in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in ) { dev -> iso_in =
<S2SV_ModStart> vs_ie = ( struct ieee_types_header * ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
<S2SV_ModStart> , len ) ; if ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> beacon . tail_len ) ; if ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> rate_ie + 1 , rate_ie -> len ) ; }
<S2SV_ModStart> ; if ( vendor_ie ) { wmm_ie = vendor_ie ; if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return
<S2SV_ModStart> if ( page ) put_page ( page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> pending_idx ] ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx , u8 status <S2SV_ModStart> make_tx_response ( vif , & pending_tx_info -> req , status <S2SV_ModEnd> ) ; index = pending_index ( netbk -> pending_prod
<S2SV_ModStart> u16 * ) skb -> data ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo = skb_shinfo ( skb ) ; <S2SV_ModStart> status ; if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( frag_get_pending_idx ( & shinfo -> frags <S2SV_ModStart> i ++ ) { int j , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ <S2SV_ModStart> ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; continue ; } xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err ) continue ; pending_idx = * <S2SV_ModStart> -> data ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> j ] ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> ; } else { xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> ; u8 * buf = dctx -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> * dst = dctx -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> , xsave , 0 , - 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> fpu ) ; if ( using_compacted_format ( ) ) { <S2SV_ModStart> fpu -> state . xsave , buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user ( & fpu -> state . <S2SV_ModStart> state . xsave , buf_fx , state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }
<S2SV_ModStart> ; devinfo . n_subdevs = dev -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . driver_name , dev -> driver -> <S2SV_ModStart> dev -> driver -> driver_name , COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo . board_name , dev -> board_name ,
<S2SV_ModStart> ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> __local_bh_enable ( unsigned int cnt ) { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> pin ) { spin_lock ( & pin_lock ) ; hlist_del_init ( & pin -> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin -> s_list ) ; spin_unlock (
<S2SV_ModStart> struct user_element * ue ; int idx , err <S2SV_ModEnd> ; if ( info -> count < 1 ) <S2SV_ModStart> , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM <S2SV_ModEnd> ; memcpy ( & kctl . id , &
<S2SV_ModStart> 2 ; } } else { uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp , valuelen ) ; nblks += dblocks
<S2SV_ModStart> ; args -> rmtblkcnt2 = args -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> ; args -> rmtblkcnt = args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
<S2SV_ModStart> -> rmtblkcnt2 = args -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen <S2SV_ModEnd> = 0 ; } retval = xfs_attr3_leaf_add ( blk <S2SV_ModStart> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2
<S2SV_ModStart> xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
<S2SV_ModStart> ; name_rmt -> valuelen = cpu_to_be32 ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf ( args -> trans , bp
<S2SV_ModStart> ; name_rmt -> valuelen = cpu_to_be32 ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf ( args -> trans , bp1
<S2SV_ModStart> , args -> namelen ) == 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( name_rmt -> valuelen ) ; args <S2SV_ModStart> = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if ( args -> flags & ATTR_KERNOVAL <S2SV_ModStart> flags & ATTR_KERNOVAL ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 ; } if ( args -> <S2SV_ModStart> 0 ; } if ( args -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR ( ERANGE ) ; } args <S2SV_ModStart> ( ERANGE ) ; } args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; args -> index = probe ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> <S2SV_ModEnd> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( <S2SV_ModStart> ( args -> dp -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; return XFS_ERROR ( EEXIST ) ; }
<S2SV_ModStart> ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args .
<S2SV_ModStart> * dst = args -> value ; int valuelen <S2SV_ModEnd> ; int nmap ; int error ; int blkcnt <S2SV_ModStart> ! ( args -> flags & ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
<S2SV_ModStart> ; blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen <S2SV_ModEnd> ) ; error = xfs_bmap_first_unused ( args -> trans <S2SV_ModStart> = args -> rmtblkcnt ; valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; while ( valuelen > 0 ) { struct
<S2SV_ModStart> entry ; size_t size ; int error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ea_idebug
<S2SV_ModStart> * bh = NULL ; int error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ea_idebug
<S2SV_ModStart> * s = & bs -> s ; struct mb2_cache_entry <S2SV_ModEnd> * ce = NULL ; int error = 0 <S2SV_ModStart> = NULL ; int error = 0 ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; # <S2SV_ModStart> ENOSPC ; if ( s -> base ) { <S2SV_ModEnd> BUFFER_TRACE ( bs -> bh , "get_write_access" ) ; <S2SV_ModStart> -> h_refcount == cpu_to_le32 ( 1 ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> ea_bdebug ( bs -> bh , "modifying<S2SV_blank>in-place" ) ; <S2SV_ModStart> b_data ; unlock_buffer ( bs -> bh ) ; <S2SV_ModEnd> ea_bdebug ( bs -> bh , "cloning" ) ; <S2SV_ModStart> ) goto cleanup_dquot ; lock_buffer ( new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> ; if ( error ) goto cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; ce = NULL ; } else <S2SV_ModStart> = 0 ; cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; brelse ( new_bh ) ; if
<S2SV_ModStart> * inode , struct ext4_xattr_header * header , struct mb2_cache_entry <S2SV_ModEnd> * * pce ) { __u32 hash = le32_to_cpu <S2SV_ModStart> = le32_to_cpu ( header -> h_hash ) ; struct mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if <S2SV_ModStart> , "looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]" , ( int ) hash ) ; ce = mb2_cache_entry_find_first ( ext4_mb_cache , <S2SV_ModEnd> hash ) ; while ( ce ) { struct <S2SV_ModStart> ( ce ) { struct buffer_head * bh ; <S2SV_ModEnd> bh = sb_bread ( inode -> i_sb , ce <S2SV_ModStart> ; } brelse ( bh ) ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ) ; } return NULL ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , struct buffer_head * bh ) { <S2SV_ModStart> ( BHDR ( bh ) -> h_hash ) ; int error ; error = mb2_cache_entry_create ( ext4_mb_cache , GFP_NOFS , hash , bh -> b_blocknr ) ; if ( error ) { if ( error == - EBUSY ) ea_bdebug ( bh , "already<S2SV_blank>in<S2SV_blank>cache" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh , "inserting<S2SV_blank>[%x]" , ( int ) <S2SV_ModStart> , "inserting<S2SV_blank>[%x]" , ( int ) hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> struct mb2_cache * ext4_xattr_create_cache ( void ) { return mb2_cache_create ( <S2SV_ModEnd> HASH_BUCKET_BITS ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) { if ( cache ) mb2_cache_destroy <S2SV_ModEnd> ( cache ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * inode , struct buffer_head * bh ) { int error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( bh , "get_write_access" ) ; error <S2SV_ModStart> -> h_refcount == cpu_to_le32 ( 1 ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; ea_bdebug ( bh , "refcount<S2SV_blank>now=0;<S2SV_blank>freeing" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh ( bh ) ; unlock_buffer ( <S2SV_ModStart> -> h_refcount , - 1 ) ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block (
<S2SV_ModStart> verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; <S2SV_ModEnd> return PTR_ERR ( map ) ; } insn [
<S2SV_ModStart> ; newnp -> opt = NULL ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> = np -> rxopt . all ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; int ret , i ; struct rb_node * <S2SV_ModStart> << ( i * 8 ) ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> } write_unlock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long tmp ; char * p = <S2SV_ModStart> node -> nd_set_attributes ) ) return - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> && cluster -> cl_local_node != node -> nd_num ) { ret = - EBUSY ; goto out ; } if ( tmp && ! cluster -> cl_has_local ) { ret = o2net_start_listening ( node ) ; if ( ret ) goto out ; } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long tmp ; char * p = <S2SV_ModStart> node -> nd_set_attributes ) ) return - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> } write_unlock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ;
<S2SV_ModStart> svm -> vcpu ) + 2 ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm -> vcpu , & msr )
<S2SV_ModStart> ; msr . host_initiated = false ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu , & msr ) != 0 )
<S2SV_ModStart> -> lsm [ lsm_rule ] . rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
<S2SV_ModStart> ; } mntget ( path -> mnt ) ; nd -> last_type = LAST_BIND ;
<S2SV_ModStart> goto error ; id = kcontrol -> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
<S2SV_ModStart> & oplock , & fileHandle , xid ) ; switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) <S2SV_ModEnd> { rc = 0 ; direntry -> d_time =
<S2SV_ModStart> tp -> packets_out - tp -> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
<S2SV_ModStart> = arch_mmap_rnd ( ) ; mm -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ; if ( mmap_is_legacy ( ) ) { mm
<S2SV_ModStart> ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ; task_lock ( p ) ; <S2SV_ModStart> ) ret = p -> io_context -> ioprio ; task_unlock ( p ) ;
<S2SV_ModStart> t_prefer_loopback ) { trans = & rds_loop_transport ; } <S2SV_ModEnd> } conn -> c_trans = trans ; ret =
<S2SV_ModStart> return bdev ; fail : ext3_msg ( sb , KERN_ERR ,
<S2SV_ModStart> options != ',' ) { ext3_msg ( sb , KERN_ERR ,
<S2SV_ModStart> DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
<S2SV_ModStart> free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) &&
<S2SV_ModStart> ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , "interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> ( & intf -> dev , "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; err = - EINVAL ;
<S2SV_ModStart> . tcpv_minrtt = ca -> base_rtt , } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> = ca -> sum_rtt ; do_div ( t , info . tcpv_rttcnt ) ; info . tcpv_rtt = t ; } <S2SV_ModEnd> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info
<S2SV_ModStart> retry ; } if ( flags & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags & FOLL_TOUCH ) { if (
<S2SV_ModStart> ) ret = - EBUSY ; } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl ) ; lock_page ( page )
<S2SV_ModStart> ( * page ) ) goto unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret = 0 ; unmap : pte_unmap
<S2SV_ModStart> = pte_page ( huge_ptep_get ( pte ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> unsigned long addr , int avoid_reserve ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> hstate_vma ( vma ) ; struct page * page <S2SV_ModEnd> ; long chg ; chg = vma_needs_reservation ( h <S2SV_ModStart> VM_FAULT_OOM ) ; if ( chg ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS <S2SV_ModStart> NUMA_NO_NODE ) ; if ( ! page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) ; return ERR_PTR ( - VM_FAULT_SIGBUS <S2SV_ModStart> } set_page_private ( page , ( unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation ( h , vma , addr
<S2SV_ModStart> int nid = page_to_nid ( page ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private ( page ) ; set_page_private ( <S2SV_ModStart> ) ; } spin_unlock ( & hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> chg < 0 ) return chg ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) ) return - ENOSPC ; ret <S2SV_ModStart> ) ; if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping <S2SV_ModEnd> -> private_list , from , to ) ; return
<S2SV_ModStart> inode -> i_mapping -> private_list , offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; spin_unlock ( & inode -> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg - freed ) ) ; hugetlb_acct_memory
<S2SV_ModStart> vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve ) ; } } } <S2SV_null> <S2SV_null>
<S2SV_ModStart> h , vma , address ) ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock ( & mapping -> i_mmap_mutex ) ;
<S2SV_ModStart> void pid_ns_release_proc ( struct pid_namespace * ns ) { kern_unmount <S2SV_ModEnd> ( ns -> proc_mnt ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> { switch ( type ) { case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw ) ; break ; case BPF_TYPE_MAP : raw = <S2SV_ModEnd> bpf_map_inc ( raw , true ) ; break ;
<S2SV_ModStart> ( inode -> i_private , * type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> ( IS_ERR ( map ) ) return map ; map =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> struct bpf_map * <S2SV_ModEnd> bpf_map_inc ( struct bpf_map * map , bool uref <S2SV_ModStart> struct bpf_map * map , bool uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec ( & map -> refcnt ) ; return ERR_PTR ( - EBUSY ) ; } <S2SV_ModEnd> if ( uref ) atomic_inc ( & map -> <S2SV_ModStart> ) atomic_inc ( & map -> usercnt ) ; return map ;
<S2SV_ModStart> ( IS_ERR ( prog ) ) return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput ( f ) ; return prog
<S2SV_ModStart> ( f ) ; return - E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_ModEnd> fdput ( f ) ; next_insn : insn ++
<S2SV_ModStart> ) ; else ci -> hcd = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
<S2SV_ModStart> ( ! dir_emit_dots ( file , ctx ) ) goto out <S2SV_ModEnd> ; pos = 2 ; for ( first_entry ( <S2SV_ModStart> sysctl_head_finish ( h ) ; break ; } } out :
<S2SV_ModStart> sk ; BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
<S2SV_ModStart> = new_dir -> i_sb -> s_max_links ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> ) return 0 ; error = may_delete ( old_dir
<S2SV_ModStart> [ dst_byte_offset ++ ] |= ( src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0 ; break ; } src_byte_offset ++
<S2SV_ModStart> response_data ; int rc = 0 ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16 params , byte_count ; cFYI (
<S2SV_ModStart> - ENOMEM ; ar2 -> udev = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> ] = usb_ifnum_to_if ( udev , 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> ar2 -> intf [ 1 ] -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> ( ar2 ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; ar2 -> channel_mask = channel_mask ; ar2 -> <S2SV_ModStart> -> channel_mask ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( udev , ar2 -> phys , <S2SV_ModStart> & ati_remote2_attr_group ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; r = ati_remote2_input_init ( ar2 ) ; if <S2SV_ModStart> ( ar2 ) ; if ( r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( interface , ar2 ) ; interface <S2SV_ModStart> interface -> needs_remote_wakeup = 1 ; return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 ) ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [
<S2SV_ModStart> * addr , int addr_len ) { struct sockaddr_rc sa <S2SV_ModEnd> ; struct sock * sk = sock -> sk <S2SV_ModStart> sock * sk = sock -> sk ; int len , err = 0 <S2SV_ModEnd> ; if ( ! addr || addr -> sa_family <S2SV_ModStart> -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> ( & rfcomm_sk_list . lock ) ; if ( sa . rc_channel && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <S2SV_ModEnd> rc_bdaddr ) ) { err = - EADDRINUSE ; <S2SV_ModStart> rfcomm_pi ( sk ) -> src , & sa . <S2SV_ModEnd> rc_bdaddr ) ; rfcomm_pi ( sk ) -> channel <S2SV_ModStart> ) ; rfcomm_pi ( sk ) -> channel = sa . rc_channel <S2SV_ModEnd> ; sk -> sk_state = BT_BOUND ; } write_unlock
<S2SV_ModStart> -> parent_slot ; cursor = shortcut -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> ; cursor = ptr ; } BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node = assoc_array_ptr_to_node ( cursor ) ;
<S2SV_ModStart> * client , struct ion_handle * handle ) { <S2SV_ModEnd> BUG_ON ( client != handle -> client ) ; <S2SV_ModStart> ; mutex_lock ( & client -> lock ) ; ion_free_nolock ( client , handle <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock ) <S2SV_ModStart> ; mutex_unlock ( & client -> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * ion_handle_get_by_id ( struct ion_client * client <S2SV_ModStart> ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock ) <S2SV_ModStart> ( & client -> lock ) ; return handle <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ion_handle_put ( struct ion_handle * handle ) { <S2SV_ModStart> ( & client -> lock ) ; ret = ion_handle_put_nolock ( handle <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock )
<S2SV_ModStart> case ION_IOC_FREE : { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , data . handle . handle ) <S2SV_ModStart> ) ; if ( IS_ERR ( handle ) ) { mutex_unlock ( & client -> lock ) ; return PTR_ERR ( handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break ; } case ION_IOC_SHARE : case
<S2SV_ModStart> insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; }
<S2SV_ModStart> { unsigned int bytes = PAGE_SIZE - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] )
<S2SV_ModStart> case MSR_MTRRdefType : case MSR_IA32_CR_PAT : return true ; <S2SV_ModEnd> } return false ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; read_lock ( & tasklist_lock ) ; if ( child -> ptrace && child -> parent == current ) { WARN_ON ( child -> state == __TASK_TRACED ) ; if ( ignore_state || ptrace_freeze_traced ( child ) ) ret = 0 <S2SV_ModEnd> ; } read_unlock ( & tasklist_lock ) ; if <S2SV_ModStart> ; if ( ! ret && ! ignore_state ) { if ( ! wait_task_inactive ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = - ESRCH ; } } <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> crypto_init_skcipher_ops_ablkcipher ( tfm ) ; skcipher -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher -> encrypt = alg -> encrypt ;
<S2SV_ModStart> , int reason , unsigned int esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> , handler [ reason ] , esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , regs , & info , 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> inode = d_inode ( fh -> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> ; fh_drop_write ( fh ) ; nfserr = fh_getattr <S2SV_ModStart> ( argp -> acl_default ) ; return nfserr ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh ) ; out_errno : nfserr =
<S2SV_ModStart> inode = d_inode ( fh -> fh_dentry ) ; <S2SV_ModEnd> error = fh_want_write ( fh ) ; if ( <S2SV_ModStart> ) ; if ( error ) goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh ) ; out_errno : nfserr =
<S2SV_ModStart> inode = d_inode ( dentry ) ; if ( <S2SV_ModEnd> S_ISDIR ( inode -> i_mode ) ) flags = <S2SV_ModStart> if ( host_error < 0 ) goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if ( host_error < 0 ) goto <S2SV_ModStart> ) ; if ( host_error < 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( S_ISDIR ( inode -> i_mode ) <S2SV_ModStart> ( inode -> i_mode ) ) { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl )
<S2SV_ModStart> truncate = 0 ; int ret = 0 ; char * p ; int len ; <S2SV_ModStart> . NM . flags ) ; break ; } len = rr -> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) { truncate = 1 ; break <S2SV_ModStart> ) { truncate = 1 ; break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> u . NM . name , <S2SV_ModStart> , rr -> u . NM . name , len ) ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ; case SIG ( 'R' , 'E'
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_cipher rcipher ; strncpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher . blocksize = alg -> cra_blocksize
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_comp rcomp ; strncpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS
<S2SV_ModStart> * ualg , struct sk_buff * skb ) { strncpy ( ualg -> cru_name , <S2SV_ModEnd> alg -> cra_name , sizeof ( ualg -> cru_name <S2SV_ModStart> , sizeof ( ualg -> cru_name ) ) ; strncpy ( ualg -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name <S2SV_ModStart> , sizeof ( ualg -> cru_driver_name ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name , module_name ( alg -> cra_module <S2SV_ModStart> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> cru_flags = alg -> cra_flags ; <S2SV_ModStart> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; strncpy ( rl . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL
<S2SV_ModStart> end ) { loff_t offset ; int error ; struct file * f ; <S2SV_ModStart> VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; f = vma -> vm_file ; if ( ! f || ! f -> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> host ) { return - EINVAL <S2SV_ModStart> loff_t ) vma -> vm_pgoff << PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> mm -> mmap_sem ) ; error = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - <S2SV_ModStart> FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - start ) ; fput ( f
<S2SV_ModStart> level = rfcomm_pi ( sk ) -> sec_level ; sec . key_size = 0 ;
<S2SV_ModStart> ) ; if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ; <S2SV_ModEnd> q -> root_blkg = blkg ; q -> root_rl
<S2SV_ModStart> index ) ; BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> = - ENOMEM ; interface = intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if (
<S2SV_ModStart> false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if ( r -> CRn == 14 <S2SV_ModStart> -> Op2 & 7 ) ; } else { return false <S2SV_ModEnd> ; } if ( ! pmu_counter_idx_valid ( vcpu ,
<S2SV_ModStart> . start ) return - EINVAL ; entries = kmalloc_array ( cmap -> len , sizeof ( * entries ) <S2SV_ModEnd> , GFP_KERNEL ) ; if ( ! entries )
<S2SV_ModStart> struct iov_iter i ; int ret ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; fail :
<S2SV_ModStart> ) ; if ( ret < 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev <S2SV_ModEnd> ) ; return ret ; } kvm_get_kvm ( kvm
<S2SV_ModStart> sockfd_put ( csock ) ; return err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
<S2SV_ModStart> += delta ; else if ( i > pos + delta && i + insn -> off + 1 <= pos + delta <S2SV_ModEnd> ) insn -> off -= delta ; } }
<S2SV_ModStart> NULL ; unsigned char * symlink ; int err <S2SV_ModEnd> ; unsigned char * p = kmap ( page <S2SV_ModStart> ; struct udf_inode_info * iinfo ; uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> , pos ) ; if ( ! bh ) { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> symlink = bh -> b_data ; } udf_pc_to_char ( <S2SV_ModStart> ; unlock_page ( page ) ; return 0 ; out_unlock_inode <S2SV_ModEnd> : up_read ( & iinfo -> i_data_sem ) ; <S2SV_ModStart> -> i_data_sem ) ; SetPageError ( page ) ; out_unmap :
<S2SV_ModStart> if ( ret >= 0 ) return ret ; fsnotify_put_group ( group ) ;
<S2SV_ModStart> - 0x10 ) >> 1 ; u64 redir_content ; if ( redir_index < IOAPIC_NUM_PINS ) <S2SV_ModEnd> redir_content = ioapic -> redirtbl [ redir_index ] . <S2SV_ModStart> = ioapic -> redirtbl [ redir_index ] . bits ; else redir_content = ~ 0ULL
<S2SV_ModStart> } shm_file = shp -> shm_file ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
<S2SV_ModStart> ( & key -> user -> nikeys ) ; <S2SV_ModEnd> if ( key -> type -> destroy ) key <S2SV_ModStart> destroy ) key -> type -> destroy ( key ) ; key_user_put ( key -> user
<S2SV_ModStart> -> d >> DstShift ) & OpMask ) ; <S2SV_ModEnd> if ( ctxt -> rip_relative ) ctxt -> memopp <S2SV_ModStart> . mem . ea += ctxt -> _eip ; done :
<S2SV_ModStart> if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( ) ; <S2SV_ModEnd> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0
<S2SV_ModStart> , * rskb , * cskb ; int err = 0 ; msg -> msg_namelen
<S2SV_ModStart> = - EINVAL ; return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; } } else if ( strcmp (
<S2SV_ModStart> ; } if ( num_clips && clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
<S2SV_ModStart> break ; case PTR_TO_STACK : pointer_desc = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
<S2SV_ModStart> ; } else if ( rc == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode -> i_op -> removexattr ( dentry <S2SV_ModStart> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> void ptrace_triggered ( struct perf_event * bp <S2SV_ModEnd> , struct perf_sample_data * data , struct pt_regs *
<S2SV_ModStart> struct serial_icounter_struct * icnt ) { struct serial_icounter_struct icount = { }
<S2SV_ModStart> -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n" , ret ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info ( s -> dev , "Registered<S2SV_blank>as<S2SV_blank>%s\\n" <S2SV_ModStart> : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem
<S2SV_ModStart> : ovl_cleanup ( wdir , newdentry ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { int ret = 0 , found = 0 <S2SV_ModEnd> ; const char * home = NULL ; if <S2SV_ModStart> 1 ; } free ( user_config ) ; } <S2SV_ModEnd> if ( found == 0 ) return - 1
<S2SV_ModStart> KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ; default : r = 0 ;
<S2SV_ModStart> unsigned int count ) { struct snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
<S2SV_ModStart> ) ; if ( err ) goto out ; err = ovl_copy_up ( dentry ) ; if ( ! err ) { upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_ModEnd> mutex_lock ( & upperdentry -> d_inode -> i_mutex ) <S2SV_ModStart> & upperdentry -> d_inode -> i_mutex ) ; } <S2SV_ModEnd> ovl_drop_write ( dentry ) ; out : return err
<S2SV_ModStart> dbg_hid ( "%s,<S2SV_blank>size:%d\\n" , __func__ , size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return false ; }
<S2SV_ModStart> querying_devices = false ; return ; } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )
<S2SV_ModStart> struct gendisk * disk , fmode_t mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( disk -> private_data ) ; mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey ( struct crypto_shash * tfm , const
<S2SV_ModStart> * value , void * data ) { int ret = pci_read_config_word ( dev , offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { struct xen_pcibk_dev_data * dev_data ; int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ) ; value &= ~ PCI_COMMAND_INVALIDATE ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
<S2SV_ModStart> oz_hcd_get_desc_cnf ( void * hport , u8 req_id , u8 status , const u8 * desc , u8 length , u16 offset , u16 <S2SV_ModEnd> total_size ) { struct oz_port * port = hport <S2SV_ModStart> return ; if ( status == 0 ) { unsigned int copy_len ; unsigned <S2SV_ModEnd> int required_size = urb -> transfer_buffer_length ; if (
<S2SV_ModStart> - EFAULT ; goto cleanup ; } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( dev -> max_fib_size - sizeof ( struct aac_fibhdr )
<S2SV_ModStart> ses -> server -> ops = & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { <S2SV_ModStart> ses -> server -> ops = & smb311_operations ; ses -> server -> vals = & smb311_values ; }
<S2SV_ModStart> ; spin_unlock_bh ( & socket_client -> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree ( socket_packet ) ; if ( error
<S2SV_ModStart> pmcraid_err ( "couldn\'t<S2SV_blank>build<S2SV_blank>passthrough<S2SV_blank>ioadls\\n" ) ; goto out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
<S2SV_ModStart> ) goto _error ; bprm -> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file = open_exec ( iname ) ; retval
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct io_context * ioc ; task_lock ( <S2SV_ModStart> ) { struct io_context * ioc ; task_lock ( task ) ; ioc = task -> io_context ; task -> io_context = NULL ; task_unlock ( task <S2SV_ModEnd> ) ; if ( atomic_dec_and_test ( & ioc ->
<S2SV_ModStart> , int format , const char __user * addr <S2SV_ModEnd> , int count , int pmgr_flag ) { int <S2SV_ModStart> return 0 ; if ( format != SYSEX_PATCH ) return - EINVAL ; if ( count < hdr_size ) return - EINVAL ; <S2SV_ModEnd> count -= hdr_size ; if ( copy_from_user ( & <S2SV_ModStart> count -= hdr_size ; if ( copy_from_user ( & sysex , addr , hdr_size ) ) return - EFAULT ; if ( ( unsigned ) count < ( unsigned ) sysex . len ) sysex . len = count ; <S2SV_ModEnd> left = sysex . len ; src_offs = 0
<S2SV_ModStart> , int format , const char __user * addr <S2SV_ModEnd> , int count , int pmgr_flag ) { struct <S2SV_ModStart> - EINVAL ; } if ( copy_from_user ( & ins , addr , sizeof ( ins ) <S2SV_ModEnd> ) ) return - EFAULT ; if ( ins
<S2SV_ModStart> ] -> load_patch ( dev , fmt , buf + p <S2SV_ModEnd> , c , 0 ) ; if ( err
<S2SV_ModStart> -> cmsg_flags & LLC_CMSG_PKTINFO ) { struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> | map . m_flags ; bh -> b_size = ( u64 )
<S2SV_ModStart> void smp_task_done ( struct sas_task * task ) { <S2SV_ModEnd> del_timer ( & task -> slow_task -> timer ) <S2SV_ModStart> del_timer ( & task -> slow_task -> timer ) <S2SV_ModEnd> ; complete ( & task -> slow_task -> completion
<S2SV_ModStart> ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) { task -> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( & task -> slow_task -> completion <S2SV_ModStart> ( & task -> slow_task -> completion ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;
<S2SV_ModStart> } ; int vnet_hdr_len = 0 ; int copylen = 0 <S2SV_ModStart> ( len < ETH_HLEN ) ) goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy = true ; if ( zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
<S2SV_ModStart> + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> & page [ i ] ) ; if ( num_pages != size <S2SV_ModEnd> ) { for ( i = 0 ; i
<S2SV_ModStart> ; if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period
<S2SV_ModStart> , struct mapped_device , kobj_holder . kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> -> flags ) || dm_deleting_md ( md ) ) { md = NULL ; goto out ; } dm_get ( md ) ; out : spin_unlock ( & _minor_lock <S2SV_ModEnd> ) ; return md ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> msq , ipc_rcu_free ) ; return retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> msq , msg_rcu_free ) ; return id ; } <S2SV_ModEnd> ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock
<S2SV_ModStart> size_t count ) { BUG_ON ( direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> struct pipe_inode_info * pipe = i -> pipe ; <S2SV_ModEnd> if ( unlikely ( i -> count < size <S2SV_ModStart> size ) ) size = i -> count ; if ( size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; if ( off ) left <S2SV_ModEnd> += off - pipe -> bufs [ idx ] <S2SV_ModStart> pipe -> bufs [ idx ] ; if ( left <= buf -> len ) break ; left <S2SV_ModEnd> -= buf -> len ; idx = next_idx ( <S2SV_ModStart> = next_idx ( idx , pipe ) ; } i -> idx = idx ; i -> iov_offset = buf -> offset + left ; } i -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> pid , int sig ) { struct siginfo info = { }
<S2SV_ModStart> if ( ! desc -> count ) break ; tp -> copied_seq = seq ; } tp -> copied_seq = seq ; <S2SV_ModEnd> tcp_rcv_space_adjust ( sk ) ; if ( copied >
<S2SV_ModStart> & bp ) ; if ( error ) { if ( bp && ( xfs_da_shrink_inode ( args , 0 , bp ) != 0 ) <S2SV_ModEnd> ) goto out ; xfs_idata_realloc ( dp , size
<S2SV_ModStart> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
<S2SV_ModStart> dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> void uwbd_start ( struct uwb_rc * rc ) { struct task_struct * <S2SV_ModEnd> task = kthread_run ( uwbd , rc , "uwbd" <S2SV_ModStart> uwbd , rc , "uwbd" ) ; if ( IS_ERR ( task ) ) { rc -> uwbd . task = NULL ; printk ( KERN_ERR "UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;<S2SV_blank>" "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; } else { rc -> uwbd . task = task ; <S2SV_ModEnd> rc -> uwbd . pid = rc -> uwbd <S2SV_ModStart> = rc -> uwbd . task -> pid ; }
<S2SV_ModStart> void uwbd_stop ( struct uwb_rc * rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; return - ENOMEM ;
<S2SV_ModStart> ( struct usb_serial * serial ) { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
<S2SV_ModStart> inode -> i_sb ) ; unsigned int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ( ident == TAG_IDENT_IE && ibh ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; struct indirectEntry * ie ; ie <S2SV_ModStart> ) ; if ( ie -> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , "too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy" "<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n" , UDF_MAX_ICB_NESTING ) ; make_bad_inode ( inode ) ; return ; } goto reread <S2SV_ModEnd> ; } } brelse ( ibh ) ; }
<S2SV_ModStart> match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> = ERR_PTR ( - EINVAL ) ; if ( <S2SV_ModEnd> ! index_key . type -> instantiate || ( !
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , . <S2SV_ModStart> KEYRING_SEARCH_DO_STATE_CHECK , } ; key_ref_t key ; int ret <S2SV_ModEnd> ; if ( type -> match_preparse ) { ret
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , .
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , .
<S2SV_ModStart> * ) ( unsigned long ) args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_err ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; va_end (
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_info ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> * new_data , * old_data = env -> insn_aux_data ; int i <S2SV_ModStart> - off - cnt + 1 ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
<S2SV_ModStart> env ) ; if ( ret == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> err ; regs = cur_regs ( env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> ( err ) return err ; insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
<S2SV_ModStart> outarg . namelen > FUSE_NAME_MAX ) goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + outarg . namelen + 1 ) goto err ;
<S2SV_ModStart> == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
<S2SV_ModStart> * * p , void * end , void * <S2SV_ModStart> EINVAL ; dout ( "ceph_x_decrypt<S2SV_blank>len<S2SV_blank>%d\\n" , len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> ( secret , & head , & head_len , *
<S2SV_ModStart> end ) { void * p = buf ; u8 reply_struct_v ; u32 num ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( & p , end , reply_struct_v <S2SV_ModStart> ( ac , secret , & p , end ) ; if ( ret ) return ret ; } return 0 ; bad : return - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> th ; int ret = 0 ; struct ceph_x_authorize_reply reply ; void * preply = & <S2SV_ModStart> -> session_key , & p , end , & preply <S2SV_ModEnd> , sizeof ( reply ) ) ; if (
<S2SV_ModStart> , void * * p , void * end <S2SV_ModEnd> ) { struct ceph_x_info * xi = ac -> <S2SV_ModStart> blob_struct_v ; struct ceph_x_ticket_handler * th ; void * dbuf = NULL ; void * <S2SV_ModStart> is_enc ; struct timespec validity ; struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> = ceph_x_decrypt ( secret , p , end , & dbuf , 0 <S2SV_ModEnd> ) ; if ( dlen <= 0 ) { <S2SV_ModStart> p , end , is_enc , bad ) ; <S2SV_ModEnd> if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) <S2SV_ModStart> ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if ( dlen < 0 ) { <S2SV_ModStart> { ret = dlen ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> p , end , dlen , bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> -> have_keys |= th -> service ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context ; } else { if (
<S2SV_ModStart> * port ; struct scatterlist sg [ 1 ] ; void * data ; int ret <S2SV_ModStart> if ( ! port ) return - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; sg_init_one ( sg , data , count ) ; ret = <S2SV_ModEnd> __send_to_port ( port , sg , 1 , count <S2SV_ModStart> ( port , sg , 1 , count , data , false ) ; kfree ( data ) ; return ret ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { err = - ENOTCONN ; break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> kvm_assigned_dev_kernel * match ; struct pci_dev * dev ; u8 header_type ; <S2SV_ModStart> r = - EINVAL ; goto out_free ; } pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ; if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) { r = - EPERM ; goto out_put ; } r = probe_sysfs_permissions ( dev ) ; if ( r ) goto out_put ;
<S2SV_ModStart> ) ; } if ( chg < 0 ) { ret = chg ; goto out_err ; } <S2SV_ModEnd> if ( hugepage_subpool_get_pages ( spool , chg ) ) <S2SV_ModStart> if ( hugepage_subpool_get_pages ( spool , chg ) ) { ret = - ENOSPC ; goto out_err ; } <S2SV_ModEnd> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_ModStart> ) { hugepage_subpool_put_pages ( spool , chg ) ; goto out_err <S2SV_ModEnd> ; } if ( ! vma || vma -> <S2SV_ModStart> , from , to ) ; return 0 ; out_err : resv_map_put ( vma ) ; return ret ;
<S2SV_ModStart> reservations -> regions , start , end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if ( reserve ) { hugetlb_acct_memory (
<S2SV_ModStart> = ( size - 4 ) / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n" , size ) ; return 0 ; } <S2SV_ModStart> = ( size - 6 ) / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n" , size ) ; return 0 ; }
<S2SV_ModStart> port -> serial ; struct cypress_private * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> , port , & priv -> tmp_termios ) ; usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result <S2SV_ModEnd> ) { dev_err ( & port -> dev , <S2SV_ModStart> ) { dev_err ( & port -> dev , <S2SV_ModEnd> "%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>submitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n" , __func__ , result ) ; cypress_set_dead (
<S2SV_ModStart> ( cookie ) ) ) return ; if ( <S2SV_ModEnd> status == nlm_lck_denied_grace_period ) { nlmsvc_insert_block ( block , <S2SV_ModStart> } else { nlmsvc_unlink_block ( block ) ; } <S2SV_ModEnd> nlmsvc_release_block ( block ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> ; } args -> vlen = v ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> p ) ; len -= PAGE_SIZE ; } return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! p ) return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * target , struct svc_cred * source ) { target -> cr_principal = kstrdup ( source -> cr_principal , GFP_KERNEL ) ; target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL ) ; if ( ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM <S2SV_ModEnd> ; target -> cr_flavor = source -> cr_flavor ;
<S2SV_ModStart> # endif if ( bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> ) ; if ( status ) goto out ;
<S2SV_ModStart> ntohl ( * p ++ ) ; p ++ ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> ; } args -> vlen = v ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u32 , args -> count , PAGE_SIZE ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! p ) return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( err < 0 ) goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
<S2SV_ModStart> , struct svc_export * exp ) { if ( ! d_inode ( dentry ) ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModEnd> ) return 1 ; if ( nfsd4_is_junction ( dentry <S2SV_ModStart> ( dentry ) ) return 1 ; if ( d_mountpoint ( dentry ) ) return 2 ; return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> unsigned long used ; int target ; long timeo ; msg -> msg_namelen = 0
<S2SV_ModStart> goto drop_recycle_buffer ; } if ( unlikely ( len + ring -> frameoffset
<S2SV_ModStart> ; p ++ ) { struct media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> . source -> entity != entity ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
<S2SV_ModStart> 0 ) ; sk -> sk_state = BT_CONFIG ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> { unsigned int cpu ; struct cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
<S2SV_ModStart> pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
<S2SV_ModStart> ) { abort_creds ( new ) ; return ret <S2SV_ModEnd> ; } return commit_creds ( new ) ; }
<S2SV_ModStart> keyring ; if ( new -> process_keyring ) return 0 <S2SV_ModEnd> ; keyring = keyring_alloc ( "_pid" , new ->
<S2SV_ModStart> ; if ( ! new ) return - ENOMEM <S2SV_ModEnd> ; ret = install_thread_keyring_to_cred ( new ) ; if
<S2SV_ModStart> cred * new ) { struct key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> ; if ( ses -> server -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> <S2SV_ModStart> -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE )
<S2SV_ModStart> NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> ; if ( ses -> server -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> <S2SV_ModStart> -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;
<S2SV_ModStart> srv_mutex ) ; if ( ses -> server -> <S2SV_ModEnd> ops -> generate_signingkey ) { rc = ses -> <S2SV_ModStart> -> server -> ops -> generate_signingkey ( ses ) <S2SV_ModEnd> ; if ( rc ) { cifs_dbg ( FYI <S2SV_ModStart> ( & ses -> server -> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } if ( ! ses -> server <S2SV_ModStart> = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> num_interrupt_in == 0 ) ) return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> pipe ; int j ; if ( serial -> num_bulk_out < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial -> port [ 0 ] ;
<S2SV_ModStart> rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if ( svm -> vcpu . guest_debug &
<S2SV_ModStart> . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR
<S2SV_ModStart> { ret = - EAGAIN ; break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> struct mount * tree ; namespace_lock ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
<S2SV_ModStart> ; list_del ( & mnt -> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }
<S2SV_ModStart> ( ! list_empty ( & tmp_list ) ) { bool disconnect ; <S2SV_ModStart> ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if ( mnt_has_parent ( p ) ) <S2SV_ModStart> ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } <S2SV_ModEnd> change_mnt_propagation ( p , MS_PRIVATE ) ; } }
<S2SV_ModStart> ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> ; int ret ; kenter ( "" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;
<S2SV_ModStart> } INIT_LIST_HEAD ( & extra_response -> er_list ) ; strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ; strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail ( & extra_response -> er_list ,
<S2SV_ModStart> ( iscsi_check_for_auth_key ( key ) > 0 ) { <S2SV_ModEnd> kfree ( tmpbuf ) ; return 1 ; }
<S2SV_ModStart> struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ; iv = timr -> it_interval ;
<S2SV_ModStart> timespec64_to_ktime ( new_setting -> it_value ) ; sigev_none = timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ; kc -> timer_arm ( timr ,
<S2SV_ModStart> struct task_struct * rtn = current -> group_leader ; switch ( event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ; if ( ! rtn || ! same_thread_group ( rtn , current ) ) return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if ( event -> sigev_signo <= 0 || event -> sigev_signo > SIGRTMAX ) return NULL ; case SIGEV_NONE : return task_pid ( rtn ) ; default : return NULL ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct ld_semaphore * sem ) { long tmp = <S2SV_ModEnd> atomic_long_cmpxchg ( & sem -> count , * old <S2SV_ModStart> -> count , * old , new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> init ) ops -> init ( dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> ) ; if ( ret < 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> destroy ( dev ) ; return ret ; } <S2SV_ModEnd> cd -> fd = ret ; return 0 ;
<S2SV_ModStart> mm ) ; rcu_read_lock ( ) ; if ( dumpable != SUID_DUMP_USER <S2SV_ModEnd> && ! ptrace_has_cap ( __task_cred ( task ) ->
<S2SV_ModStart> ( & group -> inotify_data . idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
<S2SV_ModStart> int , flags ) { struct fsnotify_group * group <S2SV_ModEnd> ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC <S2SV_ModStart> IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; group = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; if ( IS_ERR ( group ) <S2SV_ModStart> ) ; if ( IS_ERR ( group ) ) return PTR_ERR ( group <S2SV_ModEnd> ) ; ret = anon_inode_getfd ( "inotify" , & <S2SV_ModStart> , O_RDONLY | flags ) ; if ( ret < 0 ) fsnotify_put_group ( group <S2SV_ModEnd> ) ; return ret ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static struct fsnotify_group * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events ) { struct fsnotify_group * group <S2SV_ModStart> . last_wd = 0 ; group -> inotify_data . fa = NULL ; group -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct fsnotify_group * group = file -> private_data ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>group=%p\\n" , __func__ , group ) ; <S2SV_ModStart> ( group ) ; fsnotify_put_group ( group ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> , & seg_desc , base3 , seg ) ; if ( desc ) * desc = seg_desc ;
<S2SV_ModStart> , old_cs ; ulong old_eip ; int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( & sel , ctxt -> src <S2SV_ModStart> valptr + ctxt -> op_bytes , 2 ) ; rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ctxt -> op_bytes , 2 ) ; rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModEnd> ) ; if ( rc != X86EMUL_CONTINUE ) return <S2SV_ModStart> if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ctxt ) { int rc ; unsigned long eip , cs ; u16 old_cs <S2SV_ModEnd> ; int cpl = ctxt -> ops -> cpl <S2SV_ModStart> ctxt -> ops -> cpl ( ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; rc = emulate_pop ( ctxt , & eip <S2SV_ModEnd> , ctxt -> op_bytes ) ; if ( rc <S2SV_ModStart> ; if ( rc != X86EMUL_CONTINUE ) return rc <S2SV_ModEnd> ; rc = emulate_pop ( ctxt , & cs <S2SV_ModStart> ) > cpl ) return X86EMUL_UNHANDLEABLE ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , ( u16 ) cs , VCPU_SREG_CS <S2SV_ModStart> ( ctxt , ( u16 ) cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> return rc ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt , selector , seg , cpl , false , NULL
<S2SV_ModStart> tss -> ldt , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModStart> tss -> es , VCPU_SREG_ES , cpl , true , NULL <S2SV_ModStart> tss -> cs , VCPU_SREG_CS , cpl , true , NULL <S2SV_ModStart> tss -> ss , VCPU_SREG_SS , cpl , true , NULL <S2SV_ModStart> tss -> ds , VCPU_SREG_DS , cpl , true , NULL
<S2SV_ModStart> tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModStart> tss -> es , VCPU_SREG_ES , cpl , true , NULL <S2SV_ModStart> tss -> cs , VCPU_SREG_CS , cpl , true , NULL <S2SV_ModStart> tss -> ss , VCPU_SREG_SS , cpl , true , NULL <S2SV_ModStart> tss -> ds , VCPU_SREG_DS , cpl , true , NULL <S2SV_ModStart> tss -> fs , VCPU_SREG_FS , cpl , true , NULL <S2SV_ModStart> tss -> gs , VCPU_SREG_GS , cpl , true , NULL
<S2SV_ModStart> >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
<S2SV_ModStart> user_ns ) ; new_ns -> ucounts = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
<S2SV_ModStart> parent_path ) { HLIST_HEAD ( tree_list ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; struct hlist_node * n ; int err ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt ) ; if ( err ) goto out ; } <S2SV_ModStart> . first , struct mount , mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> cleanup_group_ids ( source_mnt , NULL ) ; out : ns -> pending_mounts = 0 ;
<S2SV_ModStart> head , n -> list . prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
<S2SV_ModStart> p ) { q -> mnt_ns = new_ns ; new_ns -> mounts ++ ;
<S2SV_ModStart> = new_ns ; new_ns -> root = mnt ; new_ns -> mounts ++ ;
<S2SV_ModStart> ( ! list_empty ( & tmp_list ) ) { struct mnt_namespace * ns ; <S2SV_ModStart> ; list_del_init ( & p -> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> p -> mnt_ns = NULL ; if ( how
<S2SV_ModStart> & child -> mnt_hash , list ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> file , ns , cap_setid , & new_map ) <S2SV_ModEnd> ) goto out ; ret = - EPERM ; <S2SV_ModStart> out ; e -> lower_first = lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> ( & sm_info -> sit_entry_set ) ; if ( <S2SV_ModEnd> ! f2fs_readonly ( sbi -> sb ) ) {
<S2SV_ModStart> SM_I ( sbi ) -> fcc_info = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> effective = true ; } skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
<S2SV_ModStart> vsock_sk ( sk ) ; err = 0 ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ; inst -> alg . decrypt = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) { struct pcrypt_instance_ctx * ctx = <S2SV_ModStart> * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst ) ; crypto_drop_aead ( & ctx ->
<S2SV_ModStart> & OpMask ) ; if ( ctxt -> rip_relative && likely ( ctxt -> memopp )
<S2SV_ModStart> ; unsigned long tmpl ; struct desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ( ) & ~ X86_CR0_TS ) ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; #
<S2SV_ModStart> return - EFAULT ; if ( info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; return - EPERM ; } <S2SV_ModEnd> info . si_signo = sig ; return kill_proc_info (
<S2SV_ModStart> return - EINVAL ; if ( info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; return - EPERM ; } <S2SV_ModEnd> info -> si_signo = sig ; return do_send_specific (
<S2SV_ModStart> ? PSW_MASK_RI : 0 ; if ( ( data ^ PSW_USER_BITS ) & ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return - EINVAL ; if ( ( data
<S2SV_ModStart> * inode , struct f2fs_extent * i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext ) ; if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> alg_sock * ask = alg_sk ( sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> = sizeof ( * ctx ) + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = sock_kmalloc ( sk , len , <S2SV_ModStart> -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL ) ; if ( ! ctx <S2SV_ModStart> ( ctx -> iv , 0 , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; skcipher_request_set_tfm ( & ctx -> req , skcipher ) ; skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; <S2SV_ModEnd> sk -> sk_destruct = skcipher_sock_destruct ; return 0 ;
<S2SV_ModStart> name , u32 type , u32 mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_ModStart> crypto_alloc_skcipher ( name , type , mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ;
<S2SV_ModStart> static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u8 * key , unsigned int keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher , key , keylen ) ; tfm -> has_key = ! err ; return err ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; struct hns_roce_ucontext * context ; struct hns_roce_ib_alloc_ucontext_resp resp = { }
<S2SV_ModStart> ( & loopback_queue ) ) != NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> frametype = skb -> data [ 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> ( rose_address * ) ( skb -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i
<S2SV_ModStart> ) ; } } else umount_tree ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; } unlock_mount_hash ( ) ; put_mountpoint (
<S2SV_ModStart> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || IS_MNT_LOCKED_AND_LAZY ( p ) <S2SV_ModEnd> ) ; pin_insert_group ( & p -> mnt_umount ,
<S2SV_ModStart> -> flags ) ) { rfcomm_dlc_accept ( d ) ; msg -> msg_namelen = 0
<S2SV_ModStart> } inode -> i_generation = iinfo -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> f = & hci_pi ( sk ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
<S2SV_ModStart> pathComponent * ) ( from + elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> : if ( pc -> lengthComponentIdent > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : if ( tolen == 0 ) <S2SV_ModStart> tolen -= 2 ; break ; case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> = '/' ; tolen -- ; break ; } <S2SV_ModEnd> } if ( p > to + 1 )
<S2SV_ModStart> id ) ; if ( uid_eq ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return true ; } else if ( <S2SV_ModStart> id ) ; if ( gid_eq ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return true ; } } if (
<S2SV_ModStart> ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> user_alloc ) ; if ( r ) goto out_free <S2SV_ModEnd> ; r = - ENOMEM ; slots = kmemdup <S2SV_ModStart> ( ! slots ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> ) ; kfree ( old_memslots ) ; return 0 ; out_slots : kfree ( slots )
<S2SV_ModStart> ( & current -> mm -> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
<S2SV_ModStart> rq_proc ) ; proc = rqstp -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> struct media_entity * ent ; struct media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;
<S2SV_ModStart> -> private_data ; struct ib_ucm_cmd_hdr hdr ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; int srcu_key ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
<S2SV_ModStart> = 0 ; void * dest ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> int uctxt_required = 1 ; int must_be_root = 0 ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES
<S2SV_ModStart> next ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> ) ; if ( ret ) goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> struct pstore * ps = get_info ( store ) <S2SV_ModEnd> ; sector_t size = get_dev_size ( dm_snap_cow ( store <S2SV_ModStart> ; e -> new_chunk = ps -> next_free ; ps -> next_free ++ ; skip_metadata ( ps ) <S2SV_ModEnd> ; atomic_inc ( & ps -> pending_count ) ;
<S2SV_ModStart> return r ; } ps -> current_area -- ; skip_metadata ( ps ) ;
<S2SV_ModStart> env , "invalid<S2SV_blank>variable<S2SV_blank>stack<S2SV_blank>read<S2SV_blank>R%d<S2SV_blank>var_off=%s\\n" , regno , tn_buf ) ; return - EACCES ;
<S2SV_ModStart> ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) <S2SV_ModEnd> ; } split_node : pr_devel ( "split<S2SV_blank>node\\n" ) ; <S2SV_ModStart> = assoc_array_node_to_ptr ( node ) ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n" <S2SV_ModEnd> , __func__ ) ; return true ; all_leaves_cluster_together :
<S2SV_ModStart> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; xfs_daddr_t eofs <S2SV_ModStart> ( xfs_off_t ) btp -> bt_smask ) ) ; eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , "%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>" , __func__ , blkno , eofs ) ; return NULL ; }
<S2SV_ModStart> struct flakey_c * fc = ti -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , <S2SV_ModEnd> dev -> mode , cmd , arg ) ;
<S2SV_ModStart> ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , <S2SV_ModEnd> dev -> mode , cmd , arg ) ;
<S2SV_ModStart> ( & m -> lock , flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
<S2SV_ModStart> salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_ModEnd> while ( walk . nbytes >= 64 ) {
<S2SV_ModStart> ret ; if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
<S2SV_ModStart> ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
<S2SV_ModStart> ) { struct task_struct * task = current ; <S2SV_ModEnd> BUG_ON ( ! ( task -> flags & PF_KTHREAD
<S2SV_ModStart> ) return handle_machine_check ( vcpu ) ; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1 ; if ( is_no_device ( intr_info
<S2SV_ModStart> ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( is_nmi <S2SV_ModEnd> ( intr_info ) ) return false ; else if
<S2SV_ModStart> exit_intr_info ) ) kvm_machine_check ( ) ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) { kvm_before_handle_nmi ( & vmx -> vcpu
<S2SV_ModStart> ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> static ssize_t pipe_write ( struct kiocb * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct file * filp = iocb -> <S2SV_ModStart> * pipe = filp -> private_data ; ssize_t ret = 0 ; int do_wakeup = 0 ; size_t total_len = iov_iter_count ( from ) ; ssize_t chars ; <S2SV_ModEnd> if ( unlikely ( total_len == 0 ) ) <S2SV_ModStart> ( unlikely ( total_len == 0 ) ) return <S2SV_ModEnd> 0 ; __pipe_lock ( pipe ) ; if ( <S2SV_ModStart> offset + chars <= PAGE_SIZE ) { int error <S2SV_ModEnd> = ops -> confirm ( pipe , buf ) <S2SV_ModStart> ) ; if ( error ) goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; goto out ; } do_wakeup = 1 ; buf -> len += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out ; } } for ( ; <S2SV_ModStart> struct page * page = pipe -> tmp_page ; int copied <S2SV_ModEnd> ; if ( ! page ) { page = <S2SV_ModStart> tmp_page = page ; } do_wakeup = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ; if ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT ; break ; } ret += copied <S2SV_ModEnd> ; buf -> page = page ; buf -> <S2SV_ModStart> -> offset = 0 ; buf -> len = copied <S2SV_ModEnd> ; buf -> flags = 0 ; if ( <S2SV_ModStart> ++ bufs ; pipe -> tmp_page = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ; } if ( bufs < pipe
<S2SV_ModStart> op , file , & opened ) ; goto out2 <S2SV_ModEnd> ; } error = path_init ( dfd , pathname <S2SV_ModStart> ; } out : path_cleanup ( nd ) ; out2 :
<S2SV_ModStart> = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_ivb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
<S2SV_ModStart> ppos ) { struct usb_yurex * dev ; int len <S2SV_ModEnd> = 0 ; char in_buffer [ 20 ] ; <S2SV_ModStart> ; if ( ! dev -> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave ( & dev -> lock , <S2SV_ModStart> ( & dev -> lock , flags ) ; len <S2SV_ModEnd> = snprintf ( in_buffer , 20 , "%lld\\n" , <S2SV_ModStart> ( & dev -> lock , flags ) ; <S2SV_ModEnd> mutex_unlock ( & dev -> io_mutex ) ; return <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0x00 , 0x00 , 0x00 , 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
<S2SV_ModStart> ret ; if ( rs -> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> 0 ) ; if ( ( ctxt -> mode != X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) && ( efer & EFER_LMA ) && ! <S2SV_ModStart> ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <S2SV_ModEnd> if ( ( msr_data & 0xfffc ) == 0x0 <S2SV_ModStart> ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModEnd> ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF <S2SV_ModStart> EFLG_IF ) ; cs_sel = ( u16 ) msr_data & <S2SV_ModEnd> ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <S2SV_ModStart> ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; if ( efer & EFER_LMA <S2SV_ModEnd> ) { cs . d = 0 ; cs <S2SV_ModStart> , & msr_data ) ; ctxt -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
<S2SV_ModStart> < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk ) ; if ( ctx ->
<S2SV_ModStart> long copied = 0 ; lock_sock ( sk ) <S2SV_ModEnd> ; for ( iov = msg -> msg_iov ,
<S2SV_ModStart> struct sock * sk = sock -> sk ; <S2SV_ModEnd> int copied , err ; if ( * debug <S2SV_ModStart> skb ) return err ; if ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name ; maddr -> family = AF_ISDN <S2SV_ModStart> . addr >> 8 ) & 0xFF ; } msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied = skb -> len + MISDN_HEADER_LEN
<S2SV_ModStart> { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; } copied = skb -> len <S2SV_ModStart> -> msg_name , & msg -> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram ( sk , skb ) ; return
<S2SV_ModStart> ( flags & MSG_OOB ) return - EOPNOTSUPP ; <S2SV_ModEnd> BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu" , sk , size ) ;
<S2SV_ModStart> ; if ( ! skb ) return err ; <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> -> flags ) ) { rfcomm_dlc_accept ( d ) <S2SV_ModEnd> ; return 0 ; } len = bt_sock_stream_recvmsg (
<S2SV_ModStart> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk ) ; return 0 ; }
<S2SV_ModStart> IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram ( sk , flags & ~
<S2SV_ModStart> timeo = sock_rcvtimeo ( sk , noblock ) ; <S2SV_ModEnd> do { int chunk ; struct sk_buff * skb
<S2SV_ModStart> cskb ; int err = 0 ; u32 offset <S2SV_ModEnd> ; if ( ( sk -> sk_state == IUCV_DISCONN
<S2SV_ModStart> unsigned long used ; int target ; long timeo <S2SV_ModEnd> ; lock_sock ( sk ) ; copied = -
<S2SV_ModStart> ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) <S2SV_ModEnd> ; lock_sock ( sk ) ; if ( sk
<S2SV_ModStart> ; if ( ! skb ) return rc ; <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp . type , "acomp" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher . type , "akcipher" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . type , "cipher" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . type , "compression" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp . type , "kpp" , sizeof (
<S2SV_ModStart> * ualg , struct sk_buff * skb ) { strncpy <S2SV_ModEnd> ( ualg -> cru_name , alg -> cra_name , <S2SV_ModStart> , sizeof ( ualg -> cru_name ) ) ; strncpy <S2SV_ModEnd> ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_ModStart> , sizeof ( ualg -> cru_driver_name ) ) ; strncpy <S2SV_ModEnd> ( ualg -> cru_module_name , module_name ( alg -> <S2SV_ModStart> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . type , "larval" , sizeof (
<S2SV_ModStart> sb ) ) return ERR_CAST ( sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;
<S2SV_ModStart> goto out ; } ret = - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
<S2SV_ModStart> const struct ieee80211_radiotap_vendor_namespaces * vns ) { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> _arg - ( unsigned long ) iterator -> _rtheader + sizeof ( uint32_t )
<S2SV_ModStart> load_sp0 ( tss , next ) ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> ) ) loadsegment ( ds , next -> ds <S2SV_ModEnd> ) ; if ( unlikely ( fsindex | next
<S2SV_ModStart> -> sk_bound_dev_if = ireq6 -> iif ; newinet -> inet_opt <S2SV_ModEnd> = NULL ; newnp -> rxopt . all =
<S2SV_ModStart> nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> struct timespec * tp ) { u64 nsec ; u32 <S2SV_ModEnd> rem ; nsec = rtc_time ( ) * sgi_clock_period <S2SV_ModStart> ; sgi_clock_offset . tv_sec = tp -> tv_sec - div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> it_value . tv_sec = 0 ; return ; } cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it . mmtimer . incr * sgi_clock_period <S2SV_ModStart> it . mmtimer . incr * sgi_clock_period ) ; cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> it . mmtimer . expires - <S2SV_ModStart> - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> sgi_timer_del ( timr ) ; when = timespec_to_ns ( & <S2SV_ModStart> new_setting -> it_value ) ; period = timespec_to_ns ( & <S2SV_ModStart> ( & n ) ; now = timespec_to_ns ( &
<S2SV_ModStart> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu . cpu , tp ) ; <S2SV_ModStart> cputime_to_timespec ( cpu . cpu , tp ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> long jiffies , struct timespec * value ) { u32 rem ; value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> long jiffies , struct timeval * value ) { u32 rem ; value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ; value -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( const s64 nsec ) { struct timespec ts ; s32 rem <S2SV_ModStart> 0 , 0 } ; ts . tv_sec = div_s64_rem ( nsec , NSEC_PER_SEC , & rem ) ; if ( unlikely ( rem < 0 ) ) { ts . tv_sec -- ; rem += NSEC_PER_SEC ; } ts . tv_nsec = rem <S2SV_ModEnd> ; return ts ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> timex * txc ) { long mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj ; int result ; if ( <S2SV_ModStart> ( s64 ) - MAXFREQ_NSEC ) ; time_offset = div_s64 ( time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset <<= SHIFT_UPDATE ; } } if
<S2SV_ModStart> * sizeof ( * di ) ; dl = kzalloc <S2SV_ModEnd> ( size , GFP_KERNEL ) ; if ( !
<S2SV_ModStart> ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size <S2SV_ModEnd> ) ) ) goto out ; if ( mem
<S2SV_ModStart> addr ) ) return - EFAULT ; r = __copy_from_user <S2SV_ModEnd> ( data , ( void __user * ) addr
<S2SV_ModStart> i ; count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
<S2SV_ModStart> 1 ; struct packet_offload * ptype ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
<S2SV_ModStart> 1 ; if ( NAPI_GRO_CB ( skb ) -> encap_mark <S2SV_ModEnd> || ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB <S2SV_ModStart> ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark <S2SV_ModEnd> = 1 ; rcu_read_lock ( ) ; uo_priv =
<S2SV_ModStart> this , * next ; DEFINE_WAKE_Q ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> ) ; struct fb_ops * fb ; unsigned long mmio_pgoff <S2SV_ModEnd> ; unsigned long start ; u32 len ; if <S2SV_ModStart> ; if ( ! info ) return - ENODEV <S2SV_ModEnd> ; fb = info -> fbops ; if ( <S2SV_ModStart> = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = <S2SV_ModStart> PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; <S2SV_ModEnd> start = info -> fix . mmio_start ; len <S2SV_ModStart> = info -> fix . mmio_start ; len = info -> fix . mmio_len <S2SV_ModEnd> ; } mutex_unlock ( & info -> mm_lock ) <S2SV_ModStart> } mutex_unlock ( & info -> mm_lock ) ; <S2SV_ModEnd> vma -> vm_page_prot = vm_get_page_prot ( vma -> vm_flags <S2SV_ModStart> vm_flags ) ; fb_pgprotect ( file , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; <S2SV_ModStart> ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; for ( idx = 0 ; idx < <S2SV_ModEnd> count ; idx ++ , id . index ++
<S2SV_ModStart> ; } if ( result > 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> ) ; snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ; return 0 ; } } up_read
<S2SV_ModStart> kcontrol , bool add_on_replace ) { struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; for ( idx = 0 ; idx < <S2SV_ModEnd> count ; idx ++ , id . index ++
<S2SV_ModStart> ) ; if ( err > 0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> ) ; snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ; return 0 ; } } else
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr <S2SV_ModStart> struct kvm_vcpu * vcpu , gpa_t vapic_addr ) { if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . <S2SV_ModStart> , & vcpu -> arch . apic_attention ) ; } else { <S2SV_ModEnd> __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . <S2SV_ModStart> , & vcpu -> arch . apic_attention ) ; } vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ;
<S2SV_ModStart> ( struct kvm_vcpu * vcpu ) { u32 data <S2SV_ModEnd> ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu <S2SV_ModStart> vcpu -> arch . apic_attention ) ) return ; kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr ( vcpu -> arch . apic
<S2SV_ModStart> kvm_lapic * apic = vcpu -> arch . apic <S2SV_ModEnd> ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if <S2SV_ModStart> 8 ) | ( max_irr << 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( th -> syn ) { if ( th -> fin ) goto discard ; if (
<S2SV_ModStart> ] = ( __u16 ) ei -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
<S2SV_ModStart> sa ; socklen_t salen ; char buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( sd , buf , sizeof ( buf ) - 1 <S2SV_ModStart> ) ; if ( len > 0 ) { <S2SV_ModEnd> if ( sa . sa_family != AF_INET ) return
<S2SV_ModStart> , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cb , * cr , * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = ( int ) img -> comps <S2SV_ModStart> << upb ) - 1 ; maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int * ) malloc ( sizeof ( <S2SV_ModStart> * ) malloc ( sizeof ( int ) * max ) ; d2 = b <S2SV_ModEnd> = ( int * ) malloc ( sizeof ( <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; if ( r == NULL || <S2SV_ModStart> NULL || b == NULL ) goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> for ( i = 0U ; i < ( loopmaxh & ~ ( size_t <S2SV_ModEnd> ) 1U ) ; i += 2U ) { <S2SV_ModStart> ) 1U ) ; i += 2U ) { size_t j ; <S2SV_ModStart> + maxw ; nb = b + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> for ( j = 0 ; j < ( loopmaxw & ~ ( size_t <S2SV_ModEnd> ) 1U ) ; j += 2U ) { <S2SV_ModStart> ; ++ cr ; } if ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb ( offset , upb , * <S2SV_ModStart> b += maxw ; } if ( i < loopmaxh ) { size_t j ; <S2SV_ModEnd> for ( j = 0U ; j < ( <S2SV_ModStart> 0U ; j < ( maxw & ~ ( size_t <S2SV_ModEnd> ) 1U ) ; j += 2U ) { <S2SV_ModStart> comps [ 2 ] . data = d2 ; <S2SV_ModEnd> img -> comps [ 1 ] . w = <S2SV_ModStart> img -> comps [ 1 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w <S2SV_ModEnd> ; img -> comps [ 1 ] . h <S2SV_ModStart> img -> comps [ 1 ] . h = img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 2 ] . <S2SV_ModEnd> dy = img -> comps [ 0 ] . <S2SV_ModStart> comps [ 0 ] . dy ; img -> color_space = OPJ_CLRSPC_SRGB ; return ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * y , * cb , * cr ; size_t maxw , maxh , max , offx , loopmaxw ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = ( int ) img -> comps <S2SV_ModStart> << upb ) - 1 ; maxw = ( size_t <S2SV_ModEnd> ) img -> comps [ 0 ] . w <S2SV_ModStart> [ 0 ] . w ; maxh = ( size_t <S2SV_ModEnd> ) img -> comps [ 0 ] . h <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; d1 = g = ( int <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; d2 = b = ( int <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; if ( r == NULL || <S2SV_ModStart> NULL || b == NULL ) goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> ; i < maxh ; ++ i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> for ( j = 0U ; j < ( loopmaxw & ~ ( size_t <S2SV_ModEnd> ) 1U ) ; j += 2U ) { <S2SV_ModStart> ; ++ cr ; } if ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb ( offset , upb , * <S2SV_ModStart> comps [ 2 ] . data = d2 ; <S2SV_ModEnd> img -> comps [ 1 ] . w = <S2SV_ModStart> img -> comps [ 1 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w <S2SV_ModEnd> ; img -> comps [ 1 ] . h <S2SV_ModStart> img -> comps [ 1 ] . h = img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 2 ] . <S2SV_ModEnd> dy = img -> comps [ 0 ] . <S2SV_ModStart> comps [ 0 ] . dy ; img -> color_space = OPJ_CLRSPC_SRGB ; return ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * y , * cb , * cr ; size_t <S2SV_ModEnd> maxw , maxh , max , i ; int <S2SV_ModStart> << upb ) - 1 ; maxw = ( size_t <S2SV_ModEnd> ) img -> comps [ 0 ] . w <S2SV_ModStart> [ 0 ] . w ; maxh = ( size_t <S2SV_ModEnd> ) img -> comps [ 0 ] . h <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; d1 = g = ( int <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; d2 = b = ( int <S2SV_ModStart> * ) malloc ( sizeof ( int ) * <S2SV_ModEnd> max ) ; if ( r == NULL || <S2SV_ModStart> comps [ 2 ] . data = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; return ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> comps [ 0 ] . h ; if ( ( image -> numcomps < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , "%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> max = w * h ; sC = 1.0F
<S2SV_ModStart> image_type = tga [ 2 ] ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga [ 5 ] ) ; cmap_entry_size <S2SV_ModStart> [ 7 ] ; # if 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga [ 8 ] ) ; y_origin <S2SV_ModStart> & tga [ 8 ] ) ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga [ 10 ] ) ; # <S2SV_ModStart> [ 10 ] ) ; # endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga [ 12 ] ) ; image_h <S2SV_ModStart> & tga [ 12 ] ) ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga [ 14 ] ) ; pixel_depth
<S2SV_ModStart> 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
<S2SV_ModStart> break ; } parameters -> csty |= 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> parameters -> prch_init [ i ] = 256 ; }
<S2SV_ModStart> tileno / p_cp -> tw ; * p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> tx0 + p * p_cp -> <S2SV_ModStart> p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ; * p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> tx0 + ( p + 1 <S2SV_ModStart> ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ; * p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> ty0 + q * p_cp -> <S2SV_ModStart> p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ; * p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> ty0 + ( q + 1 <S2SV_ModStart> ( q + 1 ) * p_cp -> tdy , <S2SV_ModEnd> p_image -> y1 ) ; * p_max_prec = 0
<S2SV_ModStart> , OPJ_UINT32 height ) { OPJ_UINT32 x , y , written <S2SV_ModStart> ; pix = pData ; x = y = written = <S2SV_ModStart> , pix ++ ) { * pix = c1 ; written ++ <S2SV_ModStart> OPJ_UINT8 ) c1_int ; * pix = c1 ; written ++ ; <S2SV_ModStart> { return OPJ_FALSE ; } } } } } if ( written != width * height ) { fprintf ( stderr , "warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_ModEnd> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if <S2SV_ModStart> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
<S2SV_ModStart> ) << 8 ) ; if ( header -> biBitCount == 0 ) { fprintf ( stderr , "Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n" , 0 ) ; return OPJ_FALSE ; } if ( header ->
<S2SV_ModStart> ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> * l_step_l , sizeof ( OPJ_INT16 ) ) ; }
<S2SV_ModStart> != 00 ) ; OPJ_UNUSED ( p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream <S2SV_ModEnd> ) ; if ( p_total_data_size < 12 ) {
<S2SV_ModStart> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 2 ) ; } return OPJ_FALSE ; }
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> 0U ) ) { numcmpts ++ ; } } if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 4 && Info_h . biCompression == 2 ) { if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 8U + 31U ) / 32U ) * 4U ; } if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL
<S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , <S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size ,
<S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size ,
<S2SV_ModStart> opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size <S2SV_ModStart> ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> SEEK_SET ) ; if ( fscanf ( f , "PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d" <S2SV_ModEnd> , temp , & endian1 , & endian2 ,
<S2SV_ModStart> include = ( OPJ_INT16 * ) opj_calloc ( ( size_t ) ( l_tcp -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l , sizeof ( OPJ_INT16 ) )
<S2SV_ModStart> ) ) ; sun . sun_family = AF_UNIX ; memcpy ( sun . sun_path <S2SV_ModEnd> , path , strlen ( path ) ) ; <S2SV_ModStart> , strlen ( path ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; <S2SV_ModEnd> if ( bind ( fd , ( const struct
<S2SV_ModStart> ) ) ; sun . sun_family = AF_UNIX ; memcpy ( sun . sun_path <S2SV_ModEnd> , address , strlen ( address ) ) ; <S2SV_ModStart> , strlen ( address ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; <S2SV_ModEnd> client -> control = socket ( AF_UNIX , SOCK_STREAM
<S2SV_ModStart> , int dir_len , char * ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( "invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( dir , dir_len , "" , 0 ) <S2SV_ModEnd> ; char * dst = ptr ; if ( <S2SV_ModStart> ( ! ptr ) free ( dst ) ; free ( src ) ; return NULL ; } free ( src ) ; <S2SV_ModEnd> return dst ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> name ) ; return 0 ; } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> <S2SV_null> void * _TIFFmalloc ( tmsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> tdata_t _TIFFmalloc ( tsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> <S2SV_null> void * _TIFFmalloc ( tmsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> , op0 , occ0 , s ) ) { return <S2SV_ModStart> ) ( tif , op0 , occ0 ) ; <S2SV_ModEnd> } else return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rowsize ; assert ( rowsize > 0 ) ; if ( ( occ0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorDecodeTile" , "%s" , "occ0%rowsize<S2SV_blank>!=<S2SV_blank>0" ) ; return 0 ; } <S2SV_ModEnd> assert ( sp -> decodepfunc != NULL ) ; <S2SV_ModStart> ) ; while ( occ0 > 0 ) { if ( ! <S2SV_ModStart> decodepfunc ) ( tif , op0 , rowsize ) ) return 0
<S2SV_ModStart> assert ( sp -> encoderow != NULL ) ; if ( ! <S2SV_ModStart> encodepfunc ) ( tif , bp , cc ) ) return 0
<S2SV_ModStart> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } <S2SV_ModEnd> while ( cc > 0 ) { ( *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpAcc ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> ( uint8 * ) _TIFFmalloc ( cc ) ; if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } if ( ! tmp ) return 0 <S2SV_ModEnd> ; while ( count > stride ) { REPEAT4 <S2SV_ModStart> # endif } } _TIFFfree ( tmp ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpDiff ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> ( uint8 * ) _TIFFmalloc ( cc ) ; if <S2SV_ModEnd> ( ( cc % ( bps * stride ) <S2SV_ModStart> ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } if ( ! tmp ) return 0 <S2SV_ModEnd> ; _TIFFmemcpy ( tmp , cp0 , cc ) <S2SV_ModStart> ] ) & 0xff ) ; cp -- ) return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if <S2SV_ModEnd> ( ( cc % ( 2 * stride ) <S2SV_ModStart> ( cc % ( 2 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc16" , "%s" , "cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if <S2SV_ModEnd> ( ( cc % ( 4 * stride ) <S2SV_ModStart> ( cc % ( 4 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc32" , "%s" , "cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc > stride ) { if ( <S2SV_ModStart> while ( cc > 0 ) ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if <S2SV_ModEnd> ( ( cc % ( 2 * stride ) <S2SV_ModStart> ( cc % ( 2 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if <S2SV_ModEnd> ( ( cc % ( 4 * stride ) <S2SV_ModStart> ( cc % ( 4 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff32" , "%s" , "(cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff8 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc > stride ) { cc -= <S2SV_ModStart> -= stride ) > 0 ) ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> 4 ; TIFFSwabArrayOfLong ( wp , wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ; TIFFSwabArrayOfShort ( wp , wc ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if ( ! horDiff32 ( tif , cp0 , cc ) ) return 0 ; TIFFSwabArrayOfLong ( wp , wc ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) rowsperstrip = td -> td_imagelength ; stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ; stripinplane = ( strip % stripsperplane
<S2SV_ModStart> TIFF * out ) { uint16 bitspersample , samplesperpixel = 1 ; uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK <S2SV_ModEnd> ; copyFunc cf ; uint32 width , length ;
<S2SV_ModStart> bufp = buf ; int32 bytes_read = 0 ; uint32 <S2SV_ModEnd> strip , nstrips = TIFFNumberOfStrips ( in ) ;
<S2SV_ModStart> struct dump_opts * dump ) { int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 bytes_read = 0 ; uint16 bps , <S2SV_ModStart> ; int32 bytes_read = 0 ; uint16 bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ; uint32 src_rowsize , dst_rowsize , rows_processed ,
<S2SV_ModStart> in , TIFF * out ) { uint16 bitspersample = 1
<S2SV_ModStart> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; _TIFFfree ( working_copy ) ;
<S2SV_ModStart> ( uint8 * ) cp0 ; uint8 * tmp <S2SV_ModEnd> ; if ( cc % ( bps * stride <S2SV_ModStart> "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> ( uint8 * ) cp0 ; uint8 * tmp <S2SV_ModEnd> ; if ( ( cc % ( bps * <S2SV_ModStart> "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> uint32 rows , uint32 cols , int outskew , int64 <S2SV_ModEnd> inskew ) { while ( rows -- > 0
<S2SV_ModStart> tif -> tif_rawdata , tif -> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; return ( 0 ) ; } <S2SV_ModEnd> tif -> tif_rawcc = 0 ; tif -> tif_rawcp
<S2SV_ModStart> , tsize_t * striplength , unsigned char * buffer , tsize_t buffersize <S2SV_ModStart> strip [ i ] ) { case 0xd8 : if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> 0xca : if ( no == 0 ) { if ( * bufferoffset + datalen + 2 + 6 > buffersize ) return ( 0 ) ; <S2SV_ModStart> i - 1 ] ) , datalen + 2 ) ; if ( * bufferoffset + 9 >= buffersize ) return ( 0 <S2SV_ModStart> ) ; v_samp = 1 ; h_samp = 1 ; if ( * bufferoffset + 11 + 3 * ( ncomp - 1 ) >= buffersize ) return ( 0 ) <S2SV_ModStart> } break ; case 0xc4 : case 0xdb : if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> 0xda : if ( no == 0 ) { if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> bufferoffset += datalen + 2 ; } else { if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> ) ) ; } i += datalen + 1 ; if ( * bufferoffset + * striplength - i > buffersize ) return ( 0 )
<S2SV_ModStart> ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , t2p -> tiff_datasize
<S2SV_ModStart> float xres = 0.0 , yres = 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = 0 ; uint16 bps = 0 , <S2SV_ModStart> = * read_ptr ; if ( ! read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; } <S2SV_ModStart> * ) _TIFFmalloc ( buffsize + 3 ) ; } <S2SV_ModStart> else { if ( prev_readsize < buffsize ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; }
<S2SV_ModStart> * spp ) + 7 ) / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( "reverseSamplesBytes" , "bytes_per_pixel<S2SV_blank>too<S2SV_blank>large" ) ; return ( 1 ) ; }
<S2SV_ModStart> rows ) ; return 0 ; } bufp += stripsize <S2SV_ModEnd> ; } return 1 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 <S2SV_ModStart> ( rowsperstrip >= td -> td_rowsperstrip ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips == 0 ) return ; <S2SV_ModEnd> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif <S2SV_ModStart> = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips <S2SV_ModEnd> , sizeof ( uint64 ) , "for<S2SV_blank>chopped<S2SV_blank>\\"StripByteCounts\\"<S2SV_blank>array" ) ; <S2SV_ModStart> = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips <S2SV_ModEnd> , sizeof ( uint64 ) , "for<S2SV_blank>chopped<S2SV_blank>\\"StripOffsets\\"<S2SV_blank>array" ) ; <S2SV_ModStart> } for ( strip = 0 ; strip < nstrips <S2SV_ModEnd> ; strip ++ ) { if ( stripbytes > <S2SV_ModStart> ] = stripbytes ; newoffsets [ strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += stripbytes ; bytecount -= stripbytes ; <S2SV_ModStart> } td -> td_stripsperimage = td -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip )
<S2SV_ModStart> td = & tif -> tif_dir ; uint32 nstrips <S2SV_ModEnd> ; nstrips = ( td -> td_rowsperstrip == (
<S2SV_ModStart> ; exit ( - 1 ) ; } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "readContigTilesIntoBuffer" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size." ) ; exit ( - 1 ) ; } tilebuf = _TIFFmalloc ( tile_buffsize + 3 <S2SV_ModEnd> ) ; if ( tilebuf == 0 ) return <S2SV_ModStart> ) ; if ( tilebuf == 0 ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] =
<S2SV_ModStart> jpt ) != 0 ) { if ( count > <S2SV_ModEnd> 4 ) { int retTIFFReadRawTile ; _TIFFmemcpy ( buffer
<S2SV_ModStart> } if ( oldcode == - 1 ) { if ( code >= clear ) { fprintf ( stderr , "bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n" , code , clear ) ; return 0 ; }
<S2SV_ModStart> ; } http_ProtoVer ( hp ) ; retval = htc_request_check_hdrs ( sp , hp ) ; return ( retval ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> . e ) { if ( ! vct_iscrlf ( <S2SV_ModEnd> r ) ) { r ++ ; continue ;
<S2SV_ModStart> q = p ; if ( ! vct_iscrlf ( <S2SV_ModEnd> p ) ) { for ( ; ! vct_iscrlf <S2SV_ModStart> ) ) { for ( ; ! vct_iscrlf ( <S2SV_ModEnd> p ) ; p ++ ) if ( !
<S2SV_ModStart> , 0 ) ; if ( ! vct_iscrlf ( & <S2SV_ModStart> & 0xff ) ; if ( ! vct_iscrlf ( &
<S2SV_ModStart> ) p ++ ; assert ( ! vct_iscrlf ( <S2SV_ModEnd> p ) ) ; * p ++ = '\\0' <S2SV_ModStart> ) p ++ ; assert ( ! vct_iscrlf ( <S2SV_ModEnd> p ) ) ; hh [ n ++ ] <S2SV_ModStart> ) ) p ++ ; if ( vct_iscrlf ( <S2SV_ModEnd> p ) ) { hh [ n ++ ] <S2SV_ModStart> ] = p ; while ( ! vct_iscrlf ( <S2SV_ModEnd> p ) ) p ++ ; q = p <S2SV_ModStart> n < MAX_HDR ) ; if ( vct_iscrlf ( <S2SV_ModEnd> p ) ) break ; hh [ n ++ <S2SV_ModStart> ( * p != '\\0' && ! vct_iscrlf ( <S2SV_ModEnd> p ) ) p ++ ; q = p
<S2SV_ModStart> , & ptr ) != VFP_OK ) break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if ( ! ValidateIOBufferSize ( Irp , sizeof <S2SV_ModStart> ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ; if ( NT_SUCCESS ( ntStatus ) ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & offset , NULL ) ; if ( <S2SV_ModStart> NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ntStatus ; Irp -> IoStatus . Information = 0 ; } TCfree ( readBuffer )
<S2SV_ModStart> num_properties = GETINT32 ( buf + idx ) ; assert ( ( num_properties + 1 ) != 0 ) ; <S2SV_ModStart> -> names [ i ] . len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> buf + idx ) ; idx += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> if ( a -> type == szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
<S2SV_ModStart> ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
<S2SV_ModStart> ; j < a -> num_values ; j ++ ) { if ( a -> type == szMAPI_BINARY <S2SV_ModStart> body [ j ] -> len ) ; } }
<S2SV_ModStart> mapi_attrs [ i ] ; if ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> = a -> num_values ; } else if ( a -> type == szMAPI_BINARY &&
<S2SV_ModStart> checked_xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; alloc_limit_assert ( "checked_xcalloc" , ( res <S2SV_ModEnd> ) ) ; return xcalloc ( num , size
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void * checked_xmalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; alloc_limit_assert ( "checked_xmalloc" , res ) ; return xmalloc ( num , <S2SV_ModEnd> size ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; ptr = malloc ( res <S2SV_ModEnd> ) ; if ( ptr ) { memset ( <S2SV_ModStart> ) { memset ( ptr , '\\0' , ( res <S2SV_ModEnd> ) ) ; } return ptr ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void * xmalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr = malloc ( res <S2SV_ModEnd> ) ; if ( ! ptr && ( size
<S2SV_ModStart> -> free ++ ] = buf ; } else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> else { free ( buf ) ; } } else { free ( buf ) ; }
<S2SV_ModStart> -> free ++ ] = obj ; } else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <S2SV_ModStart> else { free ( obj ) ; } } else { free ( obj ) ; }
<S2SV_ModStart> * send_buf ; static size_t send_buf_size ; uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> 2 ; send_buf = malloc ( send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; } <S2SV_ModEnd> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE )
<S2SV_ModStart> , "Connection" ) ; if ( connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
<S2SV_ModStart> strlen ( filename ) ; if ( length > 1 <S2SV_ModEnd> ) { if ( ( filename [ 0 ]
<S2SV_ModStart> * mask ) { char * mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char * dir_separator ; int length ; <S2SV_ModStart> struct tm * date_tmp ; mask2 = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; dir_separator = weechat_info_get ( "dir_separator" , <S2SV_ModStart> ; if ( ! dir_separator ) return NULL ; length = strlen ( mask ) + 256 + 1 ; mask2 <S2SV_ModEnd> = malloc ( length ) ; if ( ! <S2SV_ModStart> = malloc ( length ) ; if ( ! mask2 <S2SV_ModEnd> ) goto end ; seconds = time ( NULL <S2SV_ModStart> ; date_tmp = localtime ( & seconds ) ; mask2 [ 0 ] = '\\0' ; if ( strftime ( mask2 , length - 1 , mask , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , "\\01" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , "\\\\" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , "\\01" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModEnd> ; if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower <S2SV_ModStart> if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if ( weechat_logger_plugin -> debug ) { <S2SV_ModStart> weechat_buffer_get_string ( buffer , "name" ) , mask , mask7 <S2SV_ModEnd> ) ; } end : if ( mask2 ) <S2SV_ModStart> mask2 ) free ( mask2 ) ; if ( mask3 ) free ( mask3 ) ; if ( mask4 ) free ( mask4 ) ; if ( mask5 ) free ( mask5 ) ; if ( mask6 ) free ( mask6 ) ; return mask7 <S2SV_ModEnd> ; } c <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; guint32 pkt_len , rectype , dlt ; int wtap_encap ; struct eth_phdr eth ; void * phdr ; <S2SV_ModStart> next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ; wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new ( wtap_encap_dissector_table , wtap_encap , next_tvb , pinfo , tree , TRUE , phdr <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> len_remain , ampdu_len = 0 ; struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> tree , & phdr ) ; } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new ( wtap_encap_dissector_table , wtap_encap , next_tvb , pinfo , tree , TRUE , phdrp <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> guint caplen , len , frame_no ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , <S2SV_ModStart> wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree , TRUE , phdr
<S2SV_ModStart> , u3v_conv_info_t ) ; usb_conv_info -> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
<S2SV_ModStart> audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
<S2SV_ModStart> ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
<S2SV_ModStart> ) ) ; usb_conv_info -> class_data = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
<S2SV_ModStart> j + chan ] = TRUE ; c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf <S2SV_ModEnd> ; macinf -> lchid [ j + chan ] <S2SV_ModStart> -> lchid [ j + chan ] = c_t <S2SV_ModEnd> ; macinf -> content [ j + chan ] <S2SV_ModStart> [ j + chan ] = lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf -> mode [ j + chan <S2SV_ModStart> [ j + chan ] = lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; } } else { fake_lchid = make_fake_lchid
<S2SV_ModStart> + offset + 2 ) ; if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) <S2SV_ModEnd> ) { AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short" , AIRPDCAP_DEBUG_LEVEL_3
<S2SV_ModStart> offset ) + 1 ; } while ( offset > 0 && offset < end_offset ) { <S2SV_ModEnd> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo <S2SV_ModStart> tree , drep , NULL , hf_keybuffer ) ; }
<S2SV_ModStart> - ( offset % 2 ) ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb , offset ) ; if ( remaining
<S2SV_ModStart> ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } if ( ( key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) <S2SV_ModStart> key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) )
<S2SV_ModStart> EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr -> unary . child
<S2SV_ModStart> ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text (
<S2SV_ModStart> xkb_atom_text ( ctx , field ) ; if ( ! str ) return false ; if (
<S2SV_ModStart> ) != '>' && ! eol ( s ) && ! eof ( s )
<S2SV_ModStart> FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , "Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n" ) ; } else { <S2SV_ModStart> , xkb_file_type_to_string ( file -> file_type ) ) ; }
<S2SV_ModStart> ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> ; if ( ! key_aliases ) return false ; <S2SV_ModEnd> i = 0 ; darray_foreach ( alias , info <S2SV_ModStart> alias -> real ; i ++ ; } } }
<S2SV_ModStart> field ) ; * index_rtrn = NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( <S2SV_ModStart> * index_rtrn = expr -> array_ref . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
<S2SV_ModStart> syms ) ; FreeStmt ( ( ParseCommon * ) <S2SV_ModEnd> append ) ; return expr ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; exit ( 0 ) ; } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) { http_response_set_status ( res , 404 ,
<S2SV_ModStart> http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page ) && <S2SV_ModStart> , "page" ) ) != NULL ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ) ; http_response_send ( res ) ; return ; } <S2SV_ModStart> http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page ) && <S2SV_ModStart> = http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page )
<S2SV_ModStart> ( "Not<S2SV_blank>enough<S2SV_blank>magic." ) ; if ( len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct nbd_reply ) ) err ( "Request<S2SV_blank>too<S2SV_blank>big!"
<S2SV_ModStart> , NULL , NULL ) > 0 ) { <S2SV_ModEnd> DEBUG ( "accept,<S2SV_blank>" ) ; for ( i = <S2SV_ModStart> , & rset ) ) { continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { if ( ( net = accept ( serve -> socket <S2SV_ModEnd> , ( struct sockaddr * ) & addrin , <S2SV_ModStart> { err_nonfatal ( "accept:<S2SV_blank>%m" ) ; continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; } } } } } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * req = NULL ; struct printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 ; int isform = 0 ; <S2SV_ModStart> isspace ( * sb ) ) sb ++ ; sscanf ( sb , "%u" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else if ( i > 13 && <S2SV_ModStart> , "<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>" ) ; printstr ( & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"<S2SV_blank>enctype=\\"application/x-www-form-urlencoded\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" <S2SV_ModEnd> ) ; while ( fgets ( buf , 256 <S2SV_ModStart> ) ; break ; } case 'U' : { unsigned <S2SV_ModEnd> l = 0 ; int error = 0 ; <S2SV_ModStart> error = 0 ; if ( ! writable || ! contentlen || <S2SV_ModStart> ) { error = 1 ; } while ( l < contentlen && <S2SV_ModStart> CLIENT , ( unsigned char * ) buf , ( contentlen - l ) > LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModEnd> , '+' , conf . timeouts [ STRING_S ] <S2SV_ModStart> ) i = ( contentlen - l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf , "conffile=" , 9 ) ) <S2SV_ModStart> 1 ; } if ( ! error ) { buf [ i ] = 0 ; <S2SV_ModStart> buf + 9 ) ; } l += i <S2SV_ModEnd> ; } if ( writable && ! error )
<S2SV_ModStart> "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" <S2SV_ModStart> ( r , "poll" , & s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char * redirect_uri = oidc_get_redirect_uri ( r <S2SV_ModStart> , origin , client_id , session_state , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri , redirect_uri ) ; return oidc_util_html_send (
