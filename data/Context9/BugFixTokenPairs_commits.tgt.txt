<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , TPM2B * key , char * <S2SV_ModStart> UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr <S2SV_ModStart> ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> . size = 0 ; i = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> resultKey -> t . size < bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> ( tpm2bBits . b ) ; bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = string_bytes_concat_buffer ( resultKey , & ( <S2SV_ModStart> ) ) ; if ( ! res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; } else { rval = tpm_kdfa ( <S2SV_ModEnd> session -> authHash , & ( key . b
<S2SV_ModStart> WebKitWebFrame * frame ; JSGlobalContextRef context ; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string <S2SV_ModStart> ( frame ) ; globalobject = JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; <S2SV_ModStart> ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_ModEnd> JSStringRelease ( js_script ) ; } void ru <S2SV_null>
<S2SV_ModStart> Ustrcmp ( argrest , "Mr" ) == 0 ) if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> ( * argrest != 0 ) { uschar * hn ; if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i + 47 >= dctx
<S2SV_ModStart> ( ! proto_name ) return AVERROR_INVALIDDATA ; if ( av_strstart ( proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , "http" , NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name
<S2SV_ModStart> == 6 || c -> bpp == 8 ) && c -> format != CHUNKY
<S2SV_ModStart> ; s -> partitioned_frame = 0 ; s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> else { if ( ctx -> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> mb_height << frame -> interlaced_frame ) <S2SV_ModStart> ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size < ctx -> data_offset ) {
<S2SV_ModStart> s -> buf_ptr += len ; } else { uint64_t <S2SV_ModEnd> target_end = s -> end_off ? s -> end_off <S2SV_ModStart> ( ! s -> willclose || s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> off >= target_end ) return AVERROR_EOF <S2SV_ModStart> ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_ModStart> ) { av_log ( h , AV_LOG_ERROR , "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRIu64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\\n" , s -> off , target_end ) ;
<S2SV_ModStart> authstr = NULL , * proxyauthstr = NULL ; uint64_t <S2SV_ModEnd> off = s -> off ; int len = <S2SV_ModStart> , sizeof ( headers ) - len , "Range:<S2SV_blank>bytes=%" PRIu64 <S2SV_ModEnd> "-" , s -> off ) ; if ( <S2SV_ModStart> -> icy_data_read = 0 ; s -> filesize = UINT64_MAX <S2SV_ModEnd> ; s -> willclose = 0 ; s ->
<S2SV_ModStart> -> is_streamed = 1 ; s -> filesize = UINT64_MAX <S2SV_ModEnd> ; s -> location = av_strdup ( uri )
<S2SV_ModStart> int err = 0 ; s -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for ( ; ; ) { if (
<S2SV_ModStart> return err ; } if ( s -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { if ( ! s -> chunksize ) <S2SV_ModStart> ! * line ) ; s -> chunksize = strtoull <S2SV_ModEnd> ( line , NULL , 16 ) ; av_log <S2SV_ModStart> line , NULL , 16 ) ; av_log ( h , AV_LOG_TRACE , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\'\\n" , s -> chunksize ) ; if ( <S2SV_ModStart> ( ! s -> chunksize ) return 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , "Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%" PRIu64 "\\n" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> is_streamed || s -> reconnect_streamed ) ) ) { uint64_t <S2SV_ModEnd> target = h -> is_streamed ? 0 : s <S2SV_ModStart> ) ; av_log ( h , AV_LOG_INFO , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "<S2SV_blank>error=%s.\\n" , s -> off , av_err2str ( read_ret <S2SV_ModStart> ) { av_log ( h , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> ".\\n" , target ) ; return read_ret ; }
<S2SV_ModStart> ; URLContext * old_hd = s -> hd ; uint64_t <S2SV_ModEnd> old_off = s -> off ; uint8_t old_buf [ <S2SV_ModStart> ; else if ( ( s -> filesize == UINT64_MAX <S2SV_ModEnd> && whence == SEEK_END ) ) return AVERROR (
<S2SV_ModStart> { p += 6 ; s -> off = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; if <S2SV_ModStart> slash ) > 0 ) s -> filesize = strtoull <S2SV_ModEnd> ( slash + 1 , NULL , 10 )
<S2SV_ModStart> tag , "Content-Length" ) && s -> filesize == UINT64_MAX ) { s -> filesize = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; } <S2SV_ModStart> , 7 ) ) { s -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , & s -> <S2SV_ModEnd> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , <S2SV_ModStart> , "Icy-MetaInt" ) ) { s -> icy_metaint = strtoull <S2SV_ModEnd> ( p , NULL , 10 ) ; }
<S2SV_ModStart> { HTTPContext * s = h -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s -> icy_metaint - s -> icy_data_read <S2SV_ModStart> remaining = s -> icy_metaint - s -> icy_data_read <S2SV_ModEnd> ; if ( ! remaining ) { uint8_t ch
<S2SV_ModStart> } else if ( startcode == VOS_STARTCODE ) { int profile , level ; mpeg4_decode_profile_level ( s , gb , & profile , & level ) ; if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( level > 0 && <S2SV_ModEnd> level < 9 ) ) { s -> studio_profile <S2SV_ModStart> ( s , gb , 0 ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> low_delay ; if ( s -> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
<S2SV_ModStart> mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits ( gb , 4 ) ; <S2SV_ModStart> profile = get_bits ( gb , 4 ) ; * <S2SV_ModEnd> level = get_bits ( gb , 4 ) ; <S2SV_ModStart> get_bits ( gb , 4 ) ; if ( * profile == 0 && * level == 8 ) { * <S2SV_ModEnd> level = 0 ; } return 0 ; }
<S2SV_ModStart> , size_bmp ) ; if ( size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i >= dctx -> remaining
<S2SV_ModStart> trk -> sample_size ; else samples_in_chunk = 1 ; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> ( i = 0 ; i <= w - ( int )
<S2SV_ModStart> ( i = 0 ; i <= w - ( int )
<S2SV_ModStart> ) ; uint32_t vsize = avio_rb32 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> if ( ret < 0 ) return ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> sh . first_slice_in_pic_flag ) { if ( s -> <S2SV_ModEnd> max_ra == INT_MAX ) { if ( s ->
<S2SV_ModStart> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> if ( f -> version < 2 ) { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart> get_symbol ( c , state , 0 ) ; <S2SV_ModEnd> chroma_planes = get_rac ( c , state ) ; <S2SV_ModStart> chroma_planes = get_rac ( c , state ) ; <S2SV_ModEnd> chroma_h_shift = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; <S2SV_ModEnd> chroma_v_shift = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency <S2SV_ModEnd> ; f -> plane_count = 2 + f ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb <S2SV_ModStart> ; if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < 64 ; i ++ ) { get_bits ( gb , 8 ) ; } } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> for ( i = 0 ; i < 64 <S2SV_ModStart> } if ( get_bits1 ( gb ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; } } next_start_code_studio ( gb ) ; return 0 ;
<S2SV_ModStart> = ( state >> 32 ) & 0xFFFFFFFF ; int remaining ; if ( cid <= 0 ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( <S2SV_ModStart> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; if ( remaining <= 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w <S2SV_ModStart> w , dctx -> h ) ; if ( remaining <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size - i + 47 >= dctx
<S2SV_ModStart> VP8Frame * av_uninit ( curframe ) , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> ; int64_t cur_offset = avio_tell ( pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> = bytestream2_get_be16u ( & s -> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> prev_pkt [ channel_id ] . timestamp ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> i < st -> duration ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> i , 0 , 0 , AVINDEX_KEYFRAME ) ; }
<S2SV_ModStart> priv_data ; int ret , i ; int just_opened = 0 ; int reload_count <S2SV_ModStart> reload_interval = default_reload_interval ( v ) ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
<S2SV_ModStart> ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 <S2SV_ModEnd> ) { av_log ( s -> avctx , AV_LOG_ERROR
<S2SV_ModStart> if ( s -> width != avctx -> width || <S2SV_ModEnd> s -> height != avctx -> height ) {
<S2SV_ModStart> * reslevel -> num_precincts_y ; precno ++ ) { if ( band -> prec ) { <S2SV_ModStart> ; av_freep ( & prec -> cblk ) ; }
<S2SV_ModStart> reslevel -> log2_prec_height ) ; reslevel -> band = av_calloc <S2SV_ModEnd> ( reslevel -> nbands , sizeof ( * reslevel <S2SV_ModStart> ] , dy ) ; band -> prec = av_calloc <S2SV_ModEnd> ( reslevel -> num_precincts_x * ( uint64_t ) reslevel
<S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> [ i ] = avio_rl32 ( pb ) ; } <S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> [ i ] = avio_rl32 ( pb ) ; } <S2SV_ModStart> 0 ; i < frame_count ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] = avio_rl32 ( pb ) & 0xFFFF ; }
<S2SV_ModStart> pes_header_data_length = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> ; int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
<S2SV_ModStart> AV_LOG_ERROR , "cblk<S2SV_blank>size<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> return AVERROR_INVALIDDATA ; } if ( c -> nreslevels <= s -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , "reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode = c -> nreslevels - s
<S2SV_ModStart> { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample <S2SV_ModStart> + c -> one_state [ i ] ; } <S2SV_ModEnd> colorspace = get_symbol ( c , state , 0 <S2SV_ModStart> get_symbol ( c , state , 0 ) ; bits_per_raw_sample = f -> version > 0 ? get_symbol ( c , state , 0 ) : f -> avctx -> bits_per_raw_sample ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModEnd> = get_symbol ( c , state , 0 ) <S2SV_ModStart> get_symbol ( c , state , 0 ) ; chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency = get_rac ( c , state ) ; <S2SV_ModEnd> if ( f -> plane_count ) { if ( <S2SV_ModStart> if ( f -> plane_count ) { if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;
<S2SV_ModStart> avctx -> bits_per_raw_sample == 9 ) { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c -> idct_put = ff_simple_idct_put_int32_10bit ; else {
<S2SV_ModStart> av_cold void ff_mpv_idct_init ( MpegEncContext * s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> int i , ch , ret ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> } if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> < 3930 ) blockstodecode = s -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if ( ! s -> decoded_buffer )
<S2SV_ModStart> cur_pic . f || s -> cur_pic . field_picture <S2SV_ModEnd> ) return 0 ; return 1 ; } <S2SV_null>
<S2SV_ModStart> s -> bitstream_buffer_size == 0 ) ; frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> avctx -> bits_per_raw_sample > 8 ) { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return avctx -> pix_fmt ; } if
<S2SV_ModStart> low_delay ; if ( s -> studio_profile ) { <S2SV_ModEnd> if ( ! s -> avctx -> bits_per_raw_sample )
<S2SV_ModStart> 0 ; i < table_entries_used ; i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] = avio_rl32 ( pb ) + size ; }
<S2SV_ModStart> "sprop-parameter-sets" ) ) { int ret ; if ( * value == 0 ||
<S2SV_ModStart> * entry ; char color_name [ 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> ; av_freep ( & x -> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> data ; const uint8_t * end , * ptr <S2SV_ModEnd> ; int ncolors , cpp , ret , i <S2SV_ModStart> * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf + avpkt -> size ; while ( end - ptr > 9 && memcmp ( ptr , "/*<S2SV_blank>XPM<S2SV_blank>*/" , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log ( avctx , AV_LOG_ERROR , "missing<S2SV_blank>signature\\n" <S2SV_ModStart> i < cpp ; i ++ ) size *= 95 <S2SV_ModEnd> ; if ( ncolors <= 0 || ncolors > <S2SV_ModStart> mod_strcspn ( ptr , "," ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ptr , "\\"" ) + 1 ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; index = ptr ; ptr <S2SV_ModStart> mod_strcspn ( ptr , "," ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> * p -> linesize [ 0 ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> += mod_strcspn ( ptr , "\\"" ) + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA <S2SV_ModStart> -> width ; j ++ ) { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; if ( ( ret =
<S2SV_ModStart> ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 <S2SV_ModStart> , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; return AVERROR_INVALIDDATA ; } } } <S2SV_ModStart> ff_asf_guid ) ) ) { chunksize = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> ; } if ( buf -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
<S2SV_ModStart> ) ) + code ; idx += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> group >= 13 && group <= 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } else if ( group == 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> static void mpeg4_encode_gop_header ( MpegEncContext * s ) { int64_t <S2SV_ModEnd> hours , minutes , seconds ; int64_t time ;
<S2SV_ModStart> c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY
<S2SV_ModStart> in ) ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) hblur ( out -> data <S2SV_ModStart> temp ) ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) vblur ( out -> data
<S2SV_ModStart> 0 ; plane < 4 && in -> data [ plane ] && in -> linesize
<S2SV_ModStart> 0 ; plane < 4 && src -> data [ plane ] && src -> linesize
<S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> < 4 && in -> data [ p ] && in -> linesize [ p ]
<S2SV_ModStart> = 0 ; for ( plane = 0 ; plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] <S2SV_ModEnd> ; plane ++ ) { h = plane ==
<S2SV_ModStart> < 4 && in -> data [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> < 4 && out -> data [ i ] && out -> linesize [ i ]
<S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> 0 ; plane < 4 && frame -> data [ plane ] && frame -> linesize <S2SV_ModStart> < 4 && frame -> data [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> 0 ; plane < 4 && in -> data [ plane ] && in -> linesize
<S2SV_ModStart> = s -> pb ; AVStream * st ; int ret ; <S2SV_ModStart> s , AV_LOG_DEBUG , "HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; ret = <S2SV_ModStart> ] , & header_key_part [ 3 ] ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> { if ( frame_end - frame < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA ; frame [ 0 ] =
<S2SV_ModStart> = picture -> data [ plane ] + y / s -> cdy [ compno ] <S2SV_ModStart> s -> image_offset_x ; dst = line + x / s -> cdx [ compno ] <S2SV_ModStart> ) picture -> data [ plane ] + y / s -> cdy [ compno ] <S2SV_ModStart> -> image_offset_x ; dst = linel + ( x / s -> cdx [ compno ]
<S2SV_ModStart> , uint8_t * dst , int dst_size ) { GetByteContext gb ; if ( data >= data_end ) return - 1 ; bytestream2_init ( & gb , data , data_end - data ) ; return amf_get_field_value2 ( & gb , name , dst , dst_size ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rdp -> nego -> transport -> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
<S2SV_ModStart> ; rdpGdi * gdi = context -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> ; bitmap -> format = gdi -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; bitmap -> length = size <S2SV_ModEnd> ; bitmap -> data = ( BYTE * )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> if ( fields -> Len > 0 ) { const UINT64 offset = ( UINT64 ) fields -> BufferOffset + ( UINT64 ) fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length ( s ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> bitmapUpdate -> number > bitmapUpdate -> count ) { UINT32 count = bitmapUpdate -> number * 2 ; BITMAP_DATA * <S2SV_ModEnd> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate
<S2SV_ModStart> ) ; length -= sizeof ( wmac ) ; if ( ! <S2SV_ModStart> ( s -> p , length , rdp ) ) return FALSE
<S2SV_ModStart> , int length , rdpRdp * rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
<S2SV_ModStart> * server ; IceListenObj listener ; } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection ( ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> pixels ; register ssize_t i ; size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) <S2SV_ModEnd> ; pixels = ( PixelChannels * * ) AcquireQuantumMemory <S2SV_ModStart> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows <S2SV_ModEnd> , sizeof ( * pixels ) ) ; if <S2SV_ModStart> ( ( PixelChannels * * ) NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 ; i < ( ssize_t ) rows <S2SV_ModEnd> ; i ++ ) { register ssize_t j ;
<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image ) ; { Image * p <S2SV_ModStart> ) ) { p = p -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
<S2SV_ModStart> ) { image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> columns = ( size_t ) floor <S2SV_ModStart> 0 ) image -> rows = ( size_t ) floor <S2SV_ModStart> 0 ) image -> rows = ( size_t ) floor
<S2SV_ModStart> viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image -> columns + 7UL ) >> <S2SV_ModStart> image -> rows ; } else { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels , viff_info . number_data_bands ) != MagickFalse
<S2SV_ModStart> , size ; void * memory ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count , quantum ) != MagickFalse ) return
<S2SV_ModStart> size_t quantum ) { size_t extent ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count , quantum ) != MagickFalse ) return
<S2SV_ModStart> ) ( ( MagickOffsetType ) length ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , <S2SV_ModStart> layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "UnexpectedEndOfFile" , image -> filename <S2SV_ModEnd> ) ; } } length = ( MagickSizeType )
<S2SV_ModStart> void ) { return "DPC" # if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) "<S2SV_blank>Debug" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) "<S2SV_blank>Cipher" <S2SV_ModEnd> # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" <S2SV_ModStart> # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) "<S2SV_blank>Modules" <S2SV_ModStart> # if defined ( MAGICKCORE_OPENMP_SUPPORT ) "<S2SV_blank>OpenMP" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) "<S2SV_blank>Zero-configuration" # endif
<S2SV_ModStart> , & q , 10 ) ; if ( ( p == q ) || ( size < 16 ) || ( size > 256 ) <S2SV_ModEnd> ) return ( ( Image * ) NULL )
<S2SV_ModStart> = icon_file . directory [ i ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if ( imbuf == NULL ) { <S2SV_ModStart> ( void ) ResetMagickMemory ( imbuf , background_color_index , ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if ( dmbuf == ( unsigned char <S2SV_ModStart> ( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) <S2SV_ModStart> ( dmbuf + dmsx * y , imbuf + ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if ( dmbuf == ( unsigned char <S2SV_ModStart> ( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) <S2SV_ModStart> ( dmbuf + dmsx * y , imbuf + ( size_t ) <S2SV_ModStart> ) { ( void ) ResetMagickMemory ( imbuf + ( size_t ) <S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) == NULL ) { imbuf = (
<S2SV_ModStart> assert ( image -> signature == MagickCoreSignature ) ; pixel = 0 ;
<S2SV_ModStart> } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( CheckMemoryOverflow <S2SV_ModEnd> ( ( image -> columns + 7UL ) >> <S2SV_ModStart> ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModEnd> max_packets = ( size_t ) ( number_pixels * viff_info <S2SV_ModStart> ) ( number_pixels * viff_info . number_data_bands ) ; }
<S2SV_ModStart> size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if (
<S2SV_ModStart> char * p ; size_t bytes_per_line , extent , height , <S2SV_ModStart> length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; <S2SV_ModEnd> height = sun_info . height ; if ( ( <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> unsigned char * ) RelinquishMagickMemory ( sun_data ) ; <S2SV_ModEnd> p = sun_pixels ; if ( sun_info . depth
<S2SV_ModStart> unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> unsigned char * ) RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
<S2SV_ModStart> . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> hex_digits ) ; if ( c < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ = ( unsigned char ) c <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ = ( unsigned char ) c
<S2SV_ModStart> == MagickFalse ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> ; pixel = ScaleShortToQuantum ( nibble ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t bit , number_bits ; number_bits = image <S2SV_ModStart> ; bit < number_bits ; bit ++ ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( ( ( unsigned char ) pixel ) <S2SV_ModStart> ) != 0 ? 0 : 255 , q , exception <S2SV_ModEnd> ) ; q += GetPixelChannels ( image ) ; <S2SV_ModStart> GetPixelChannels ( image ) ; x ++ ; } if ( x != image -> columns ) x -- ; continue ; } } <S2SV_ModEnd> return ( SyncAuthenticPixels ( image , exception ) )
<S2SV_ModStart> size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , <S2SV_ModStart> ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModStart> = image -> columns * image -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof (
<S2SV_ModStart> = ( unsigned char * ) AcquireQuantumMemory ( pixels_length + image -> rows
<S2SV_ModStart> ( ssize_t ) length ; j ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ( * compact_pixels ) ; break ; } } <S2SV_ModEnd> compact_pixels ++ ; } } return ( i )
<S2SV_ModStart> OptionError , "InvalidGeometry" , "`%s\'" , option ) ; page_geometry = DestroyString ( page_geometry ) ;
<S2SV_ModStart> ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof ( * pixels ) ) ; if <S2SV_ModStart> = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels = ( unsigned char * ) GetVirtualMemoryBlob
<S2SV_ModStart> ( unsigned char * ) AcquireQuantumMemory ( packets + 257UL <S2SV_ModEnd> , image -> rows * sizeof ( * pixels
<S2SV_ModStart> x < ( ssize_t ) number_pixels ; x += 4 <S2SV_ModEnd> ) { for ( i = 0 ; i
<S2SV_ModStart> ( CoderEvent , GetMagickModule ( ) , "enter" ) ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if <S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" ) ; <S2SV_ModEnd> status = PersistPixelCache ( image , cache_filename , MagickTrue
<S2SV_ModStart> } switch ( sun_info . maptype ) { case RMT_NONE : break ; case
<S2SV_ModStart> = width ; image -> rows = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> + 1 ) < max_value ; depth ++ ) <S2SV_ModEnd> ; image -> depth = depth ; status =
<S2SV_ModStart> ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> if ( tga_info . colormap_type != 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> ) { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> datum ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( depth <S2SV_ModEnd> ) ; i ++ ) scale [ i ] <S2SV_ModStart> scale != ( Quantum * ) NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red = scale [ pixel . red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green = scale [ pixel . green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
<S2SV_ModStart> image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) <S2SV_ModEnd> ) ; else return ( image -> columns *
<S2SV_ModStart> ) image -> columns ; x ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> ( k >= MaxHashTable ) k -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if ( hash_code [ k ] > 0
<S2SV_ModStart> ! sun_info . length ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; number_pixels = ( MagickSizeType ) image -> <S2SV_ModStart> sun_info . width ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 <S2SV_ModStart> depth + 15 ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line >>= 4 ; sun_pixels = ( <S2SV_ModStart> length , sun_pixels , bytes_per_line * height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
<S2SV_ModStart> = ReadBlobByte ( image ) ) != EOF ) if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; ( void ) fclose ( file ) ;
<S2SV_ModStart> , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } ( void ) fclose ( file )
<S2SV_ModStart> ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } } ( void ) fclose ( file
<S2SV_ModStart> ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break <S2SV_ModEnd> ; } ( void ) fclose ( file )
<S2SV_ModStart> , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; unsigned char background_color [ 256 ] <S2SV_ModStart> number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_ModStart> number_planes ) + x * number_planes + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } p = pixels + offset ; <S2SV_ModEnd> for ( i = 0 ; i < (
<S2SV_ModStart> ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;
<S2SV_ModStart> ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) <S2SV_ModEnd> , sizeof ( * sun_data ) ) ; if <S2SV_ModStart> { size_t height ; height = sun_info . height <S2SV_ModEnd> ; if ( ( height == 0 ) ||
<S2SV_ModStart> 1 ? 65535 : 256 ; } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> if ( count != ( ssize_t ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } <S2SV_ModEnd> ( void ) ImportQuantumPixels ( image , ( CacheView
<S2SV_ModStart> page . height , MagickFalse , exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> -> matte = MagickFalse ; channel_image = mask ; }
<S2SV_ModStart> image -> number_meta_channels = StringToUnsignedLong ( options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) return ( DestroyImageList ( image ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> ; do { image -> page . x = ( ssize_t ) <S2SV_ModStart> image ) ; image -> page . y = ( ssize_t ) <S2SV_ModStart> 22 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> colormap = ( unsigned char * ) NULL ; <S2SV_ModStart> < ( ssize_t ) map_length ; x ++ ) { <S2SV_ModStart> ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> if ( ( image_info -> ping != MagickFalse ) <S2SV_ModStart> 0 ; opcode = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> x = 0 ; y += operand ; break <S2SV_ModStart> : { operand = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> x += operand ; break ; } case ByteDataOp <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image -> rows - y - 1 <S2SV_ModStart> * number_planes ) + x * number_planes + plane ) <S2SV_ModStart> if ( ( offset < 0 ) || ( ( offset + operand * number_planes ) > ( ssize_t ) <S2SV_ModEnd> pixel_info_length ) ) { if ( number_colormaps != 0 <S2SV_ModStart> = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode & 0x40 ) { operand = ReadBlobLSBSignedShort ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModEnd> pixel = ( unsigned char ) ReadBlobByte ( image <S2SV_ModStart> ( image ) ; operand ++ ; offset = ( ssize_t ) ( <S2SV_ModStart> * number_planes ) + x * number_planes + plane ) <S2SV_ModStart> if ( ( offset < 0 ) || ( ( offset + operand * number_planes ) > ( ssize_t ) <S2SV_ModEnd> pixel_info_length ) ) { if ( number_colormaps != 0 <S2SV_ModStart> ; } opcode = ReadBlobByte ( image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) ( * p & mask ) <S2SV_ModEnd> , & index , exception ) == MagickFalse ) <S2SV_ModStart> ) { if ( IsValidColormapIndex ( image , ( ssize_t <S2SV_ModEnd> ) ( x * map_length + ( * p <S2SV_ModStart> ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) <S2SV_ModStart> red ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) <S2SV_ModStart> green ) ; if ( IsValidColormapIndex ( image , ( ssize_t )
<S2SV_ModStart> exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> != 1 ) continue ; length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> MATLAB_HDR . identific , "MATLAB" , 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> filepos = TellBlob ( image ) ; while (
<S2SV_ModStart> , "MultidimensionalMatricesAreNotSupported" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_ModEnd> if ( image == ( Image * ) NULL <S2SV_ModStart> else AppendImageToList ( & image , screen ) ; status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> * p ; size_t bytes_per_line , extent , height <S2SV_ModEnd> ; ssize_t count , y ; SUNInfo sun_info ; <S2SV_ModStart> if ( image -> storage_class == PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ <S2SV_ModEnd> ; if ( SyncAuthenticPixels ( image , exception ) <S2SV_ModStart> 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( y = 0 ; y <
<S2SV_ModStart> iris_info . sans = ReadBlobMSBLong ( image ) ; count = <S2SV_ModEnd> ReadBlob ( image , sizeof ( iris_info . name <S2SV_ModStart> , ( unsigned char * ) iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" <S2SV_ModStart> . filler ) , iris_info . filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) <S2SV_ModEnd> ; image -> columns = iris_info . columns ; <S2SV_ModStart> 1 ? 65535 : 256 ; } if ( <S2SV_ModEnd> ( image_info -> ping != MagickFalse ) && (
<S2SV_ModStart> ) { FILE * input , * output ; MagickBooleanType status ; <S2SV_ModStart> ] ) ; return ( MagickFalse ) ; } status = MagickTrue ; <S2SV_ModStart> argc - 1 ) ; i ++ ) { <S2SV_ModEnd> input = fopen_utf8 ( argv [ i ] , <S2SV_ModStart> EOF ; c = fgetc ( input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; ( void ) fclose ( input ) ; ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; return ( status <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> c != '\\n' ) && ( c != '\\0' ) && ( c != EOF <S2SV_ModStart> [ 6 ] , white_point [ 2 ] ; if ( <S2SV_ModEnd> sscanf ( value , "%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g" , & chromaticity [ <S2SV_ModStart> 0 ] , & white_point [ 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity . red_primary . x = chromaticity <S2SV_ModStart> white_point . y = white_point [ 1 ] ; } <S2SV_ModStart> == 0 ) { int height , width ; if ( <S2SV_ModEnd> sscanf ( value , "%d<S2SV_blank>+X<S2SV_blank>%d" , & height , <S2SV_ModStart> , "%d<S2SV_blank>+X<S2SV_blank>%d" , & height , & width ) == 2 ) { <S2SV_ModEnd> image -> columns = ( size_t ) width ; <S2SV_ModStart> image -> rows = ( size_t ) height ; }
<S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ~
<S2SV_ModStart> * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> ) NULL ) goto FINISH_UNL ; ( void ) strncpy <S2SV_ModEnd> ( clone_info -> magick , magic_info -> name ,
<S2SV_ModStart> ; xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof ( * xcfdata ) ) ; if
<S2SV_ModStart> exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * pixels ; register ssize_t i ; <S2SV_ModStart> * * pixels ; register ssize_t i ; size_t columns , <S2SV_ModStart> 0 , number_threads * sizeof ( * pixels ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns <S2SV_ModStart> i ] = ( PixelChannels * ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof ( * * pixels ) ) <S2SV_ModStart> j = 0 ; j < ( ssize_t ) <S2SV_ModEnd> columns ; j ++ ) { register ssize_t k
<S2SV_ModStart> UndefinedGravity ? metrics . ascent : 0.0 ) ; ( void ) CloneString ( & draw_info -> geometry , <S2SV_ModEnd> geometry ) ; status = AnnotateImage ( image ,
<S2SV_ModStart> UndefinedGravity ? metrics . ascent : 0.0 ) ; ( void ) CloneString ( & draw_info -> geometry , <S2SV_ModEnd> geometry ) ; status = AnnotateImage ( image ,
<S2SV_ModStart> case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( <S2SV_ModStart> ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> : { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> ) { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ReadBlobMSBLong ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length > <S2SV_ModStart> ) { length = ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> ( code >> 7 ) & 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> image -> columns - 1 ) ; x += 4 <S2SV_ModEnd> ) { index = ConstrainColormapIndex ( image , (
<S2SV_ModStart> , name [ MaxTextExtent ] ; Image * image ; int c <S2SV_ModStart> byte , bytes_per_line , height , length , padding <S2SV_ModEnd> , version , width ; assert ( image_info != <S2SV_ModStart> ) ; ( i += 2 ) ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) break <S2SV_ModEnd> ; * p ++ = ( unsigned char ) <S2SV_ModStart> ; * p ++ = ( unsigned char ) c <S2SV_ModEnd> ; if ( ( padding == 0 ) || <S2SV_ModStart> * p ++ = ( unsigned char ) ( c <S2SV_ModEnd> >> 8 ) ; } else for ( i <S2SV_ModStart> value = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) break ; * p ++ = ( unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) <S2SV_ModEnd> ; } p = data ; for ( y <S2SV_ModStart> if ( bit == 0 ) byte = ( unsigned int <S2SV_ModEnd> ) ( * p ++ ) ; SetPixelIndex (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( Image * image , short int <S2SV_ModStart> ; if ( c == EOF ) return ( - 1 <S2SV_ModEnd> ) ; } while ( ( c == '<S2SV_blank>' <S2SV_ModStart> ; if ( c == EOF ) return ( - 1 ) ; } return ( ( int ) <S2SV_ModEnd> value ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) <S2SV_ModEnd> ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> length = image -> rows * ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 ) ; if ( ( ( sun_info
<S2SV_ModStart> < 24 ) { size_t one ; image -> <S2SV_ModEnd> colors = sun_info . maplength ; one = 1 <S2SV_ModStart> -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } switch ( sun_info . maptype ) { case RMT_EQUAL_RGB : { unsigned char * sun_colormap <S2SV_ModEnd> ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory
<S2SV_ModStart> char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1
<S2SV_ModStart> pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) <S2SV_ModEnd> , bytes_per_pixel * sizeof ( * pixels ) )
<S2SV_ModStart> char * ) AcquireQuantumMemory ( ( size_t ) count + 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static MagickBooleanType InsertRow ( Image * image , ssize_t bpp <S2SV_ModEnd> , unsigned char * p , ssize_t y , <S2SV_ModStart> , ssize_t y , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) ; switch ( bpp ) { case 1 : { <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> 8 ; bit ++ ) { index = ( <S2SV_ModEnd> ( * p ) & ( 0x80 >> bit <S2SV_ModStart> ( * p ) & ( 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 : 0x00 ) ; SetPixelIndex ( <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> for ( bit = 0 ; bit < ( ssize_t ) ( <S2SV_ModStart> ) ; bit ++ ) { index = ( <S2SV_ModEnd> ( * p ) & ( 0x80 >> bit <S2SV_ModStart> ( * p ) & ( 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 : 0x00 ) ; SetPixelIndex ( <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } break ; } case 2 : { for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_ModEnd> index , q ) ; q += GetPixelChannels ( <S2SV_ModStart> index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) <S2SV_ModEnd> ; } if ( ( image -> columns % <S2SV_ModStart> image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } break ; } case 8 : { for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x = 0 ; x < ( <S2SV_ModStart> ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( BImgBuff == NULL ) goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> clone_info -> magick , magic_info -> name , MaxTextExtent - 1
<S2SV_ModStart> } ( void ) CloseBlob ( image ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )
<S2SV_ModStart> + w . w ; a = 1.0f / MagickMax ( w . x , MagickMax <S2SV_ModEnd> ( w . y , w . z )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static MagickBooleanType ConstructOrdering ( const size_t , const DDSVector4 * , const DDSVector3 , DDSVector4 * , DDSVector4 * , unsigned char * , size_t ) , <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = QueueAuthenticPixels ( image , x , y , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> width - x ) <S2SV_ModStart> 4 , dds_info -> width - x ) , MagickMin <S2SV_ModEnd> ( 4 , dds_info -> height - y ) <S2SV_ModStart> ) == MagickFalse ) return MagickFalse ; } } return ( SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> exception ) == MagickFalse ) return MagickFalse ; } return ( SkipRGBMipmaps ( image , dds_info , 4 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> exception ) == MagickFalse ) return MagickFalse ; } return ( SkipRGBMipmaps ( image , dds_info , 3 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> DDSVector3 * value ) { value -> x = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> x ) ) ; <S2SV_ModStart> -> x ) ) ; value -> y = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> y ) ) ; <S2SV_ModStart> -> y ) ) ; value -> z = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> z ) ) ;
<S2SV_ModStart> DDSVector4 * value ) { value -> x = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> x ) ) ; <S2SV_ModStart> -> x ) ) ; value -> y = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> y ) ) ; <S2SV_ModStart> -> y ) ) ; value -> z = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> z ) ) ; <S2SV_ModStart> -> z ) ) ; value -> w = MagickMin ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , value -> w ) ) ;
<S2SV_ModStart> * entry ) + 2 ) ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ) ReadPropertySignedLong ( endian , q + 4 ) ; if ( components < 0 ) break
<S2SV_ModStart> i ; unsigned char buffer [ 4 ] ; unsigned int <S2SV_ModEnd> value ; if ( * length < 4 ) <S2SV_ModStart> unsigned char ) c ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 ] << 16 ; value |= <S2SV_ModStart> buffer [ 1 ] << 16 ; value |= ( unsigned int ) <S2SV_ModStart> buffer [ 2 ] << 8 ; value |= ( unsigned int ) <S2SV_ModStart> buffer [ 3 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> c ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 1 ] ; quantum . unsigned_value = <S2SV_ModStart> buffer [ 1 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned int ) buffer [ 3 ] << 24 ; value |= ( unsigned int ) buffer [ 2 ] << 16 ; value |= ( unsigned int ) buffer [ 1 ] << 8 ; value |= ( unsigned int ) buffer [ 0 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; } <S2SV_ModStart> ) ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 1 ] << 16 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ; value |= ( unsigned int ) buffer [ 3 ] ; quantum . unsigned_value = value & 0xffffffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned short ) buffer [ 1 ] << 8 ; value |= ( unsigned short ) buffer [ 0 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; } <S2SV_ModStart> ) ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) buffer [ 1 ] ; quantum . unsigned_value = value & 0xffff <S2SV_ModEnd> ; return ( quantum . signed_value ) ; }
<S2SV_ModStart> LSBEndian ) { value = ( unsigned int ) buffer [ 3 ] << 24 ; value |= ( unsigned int ) buffer [ 2 ] << 16 ; value |= ( unsigned int ) buffer [ 1 ] << 8 ; value |= ( unsigned int ) buffer [ 0 ] ; return ( value & 0xffffffff <S2SV_ModEnd> ) ; } value = ( unsigned int ) <S2SV_ModStart> ) ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 1 ] << 16 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ; value |= ( unsigned int ) buffer [ 3 ] ; return ( value & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> LSBEndian ) { value = ( unsigned short ) buffer [ 1 ] << 8 ; value |= ( unsigned short ) buffer [ 0 ] ; return ( value & 0xffff <S2SV_ModEnd> ) ; } value = ( unsigned short ) <S2SV_ModStart> ) ; } value = ( unsigned short ) buffer [ 0 ] << 8 ; value |= ( unsigned short ) buffer [ 1 ] ; return ( value & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < ( ( ssize_t ) image -> columns - 3 <S2SV_ModEnd> ) ; x += 4 ) { index = <S2SV_ModStart> -> colormap + ( ssize_t ) index ) ; q ++ ; p <S2SV_ModEnd> ++ ; } if ( ( image -> columns <S2SV_ModStart> if ( ( image -> columns % 4 ) > <S2SV_ModEnd> 1 ) { index = ConstrainColormapIndex ( image , <S2SV_ModStart> if ( ( image -> columns % 4 ) > <S2SV_ModEnd> 2 ) { index = ConstrainColormapIndex ( image ,
<S2SV_ModStart> ; image -> columns = image -> rows = 1 <S2SV_ModEnd> ; image -> colors = 0 ; break ; <S2SV_ModStart> ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) <S2SV_ModEnd> ; break ; } case 1 : { if
<S2SV_ModStart> number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) <S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob ( image , 2 , magick
<S2SV_ModStart> ; ssize_t count , y ; unsigned char * last_row <S2SV_ModEnd> , * one_row , * ptr ; unsigned short <S2SV_ModStart> NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; last_row <S2SV_ModEnd> = ( unsigned char * ) NULL ; if <S2SV_ModStart> NULL ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned char * ) AcquireQuantumMemory ( MagickMax <S2SV_ModStart> * image -> columns ) , sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned char * ) NULL ) ThrowReaderException <S2SV_ModStart> ; else one_row [ i + bit ] = last_row <S2SV_ModEnd> [ i + bit ] ; } } ( <S2SV_ModStart> ] ; } } ( void ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , bytes_per_row ) ; } } ptr <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; <S2SV_ModStart> one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if ( EOFBlob ( image ) !=
<S2SV_ModStart> info , & length ) ; if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
<S2SV_ModStart> . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception <S2SV_ModEnd> ) , q ) ; q += GetPixelChannels (
<S2SV_ModStart> image ) ; return ( image ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> , "MATLAB" , 6 ) ) { MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
<S2SV_ModStart> ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_ModEnd> if ( EOFBlob ( image ) != MagickFalse )
<S2SV_ModStart> ( chroma_image == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } <S2SV_ModEnd> if ( ( image_info -> ping != MagickFalse ) <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; if ( status == MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ( resize_image == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } <S2SV_ModEnd> for ( y = 0 ; y < ( <S2SV_ModStart> ) == ( Image * ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
<S2SV_ModStart> ( size_t ) ( ldblk ) , sizeof ( double <S2SV_ModEnd> ) ) ; if ( BImgBuff == NULL )
<S2SV_ModStart> ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModEnd> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap <S2SV_ModStart> ( volume ) num_images = dds_info . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> blend_dest = ReadBlobLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } if (
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ] . lines_per_image ; if ( image_info -> ping != MagickFalse <S2SV_ModStart> ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_ModEnd> if ( ( clone_info = CloneImageInfo ( image_info )
<S2SV_ModStart> ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ) image -> rows = geometry . height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) )
<S2SV_ModStart> ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ( size_t ) ( level * cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = 240 ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ldblk = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> filepos = TellBlob ( image ) ; while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> ) { Frames = 1 ; if ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break ; if ( SeekBlob ( image , <S2SV_ModStart> MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= <S2SV_ModEnd> GetBlobSize ( image ) ) goto MATLAB_KO ; filepos <S2SV_ModStart> . SizeY - i - 1 ) ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; } } <S2SV_ModEnd> Finish : ( void ) CloseBlob ( image )
<S2SV_ModStart> * ) NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image = SyncNextImageInList ( image ) ;
<S2SV_ModStart> ) == ( Image * ) NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image = SyncNextImageInList ( image ) ;
<S2SV_ModStart> ) image -> columns ; x ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> ( k >= MaxHashTable ) k -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if ( hash_code [ k ] > 0
<S2SV_ModStart> if ( BImgBuff == NULL ) goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * pixels ; register ssize_t i , <S2SV_ModStart> pixels ; register ssize_t i , j ; size_t columns , <S2SV_ModStart> number_threads * sizeof ( * pixels ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 ; i < ( ssize_t ) <S2SV_ModStart> i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof ( * * pixels ) ) <S2SV_ModStart> j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels [ i ] [ j ]
<S2SV_ModStart> OptionError , "InvalidGeometry" , "`%s\'" , option ) ; geometry = DestroyString ( geometry ) ;
<S2SV_ModStart> register ssize_t i , j ; size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) <S2SV_ModEnd> ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory <S2SV_ModStart> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( rows <S2SV_ModEnd> , sizeof ( * pixels ) ) ; if <S2SV_ModStart> ( ( MagickPixelPacket * * ) NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 ; i < ( ssize_t ) rows <S2SV_ModEnd> ; i ++ ) { pixels [ i ]
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PHP_FUNCTION ( radius_get_vendor_attr ) { const void * data , * raw ; int len ; u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModEnd> ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC <S2SV_ModStart> ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & raw <S2SV_ModEnd> , & len ) == FAILURE ) { return <S2SV_ModStart> len ) == FAILURE ) { return ; } if ( rad_get_vendor_attr ( & vendor , & type , & data , & data_len , raw , len ) <S2SV_ModEnd> == - 1 ) { RETURN_FALSE ; } else <S2SV_ModStart> return_value ) ; add_assoc_long ( return_value , "attr" , type <S2SV_ModEnd> ) ; add_assoc_long ( return_value , "vendor" , vendor <S2SV_ModStart> , "data" , ( char * ) data , data_len <S2SV_ModEnd> , 1 ) ; return ; } } <S2SV_null>
<S2SV_ModStart> array = NULL ; struct unfold_elm * ue ; if ( tree_root == NULL ) return 0 <S2SV_ModEnd> ; fprintf ( stdout , "<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>" ) ; fflush
<S2SV_ModStart> argc , char * argv [ ] ) { int ret_value = 0 ; <S2SV_ModStart> ; else fprintf ( stdout , "\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n" ) ; ret_value = write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled." , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>" <S2SV_ModEnd> , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( )
<S2SV_ModStart> = 0 ; size_t offset ; M_fs_error_t res ; <S2SV_ModEnd> res = M_fs_file_open ( & fd_old , path_old ,
<S2SV_ModStart> unsigned long long ) program_start ) ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> ( ) == ERROR ) { exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; } logit ( NSLOG_PROCESS_INFO , TRUE ,
<S2SV_ModStart> if ( res != TEE_SUCCESS ) return res ; res = utee_param_to_param ( utc , param , callee_params ) ; if ( res != TEE_SUCCESS ) return res <S2SV_ModEnd> ; } if ( called_sess && is_pseudo_ta_ctx ( called_sess
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * p , struct utee_params * up <S2SV_ModStart> vals [ n * 2 + 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> TEE_PARAM_TYPE_GET ( types , n ) ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> u [ n ] . mem <S2SV_ModStart> n ] . mem . size = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> n ] ) ) ; break ; } } return TEE_SUCCESS ;
<S2SV_ModStart> * sud ) { size_t size , len ; <S2SV_ModEnd> WCHAR * data = NULL ; DWORD bytes , <S2SV_ModStart> ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; goto err <S2SV_ModEnd> ; } size = bytes / sizeof ( * <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } data = malloc ( bytes ) ; <S2SV_ModStart> ; ReturnLastError ( pipe , L"malloc" ) ; goto err <S2SV_ModEnd> ; } read = ReadPipeAsync ( pipe , data <S2SV_ModStart> ; ReturnLastError ( pipe , L"ReadPipeAsync" ) ; goto err <S2SV_ModEnd> ; } if ( data [ size - 1 <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> directory = data ; len <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> options = sud -> directory <S2SV_ModStart> L"GetStartupData" , 1 , & exit_event ) ; goto err <S2SV_ModEnd> ; } sud -> std_input = sud -> options <S2SV_ModStart> -> std_input = sud -> options + len ; return TRUE ; err : sud -> directory = NULL ; free ( data ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE <S2SV_ModEnd> ) ; strcpy ( t1_line_array , t1_buf_array ) ;
<S2SV_ModStart> * me , const char * s ) { HTChunk * target = NULL ; <S2SV_ModStart> { case HTML_COMMENT : break ; case HTML_TITLE : target = & me -> title ; break ; case HTML_STYLE : target = & me -> style_block ; break ; case HTML_SCRIPT : target = & me -> script <S2SV_ModEnd> ; break ; case HTML_PRE : case HTML_LISTING : <S2SV_ModStart> , s ) ; break ; case HTML_OBJECT : target = & me -> object ; break ; case HTML_TEXTAREA : target = & me -> textarea <S2SV_ModEnd> ; break ; case HTML_SELECT : case HTML_OPTION : <S2SV_ModStart> ; break ; case HTML_SELECT : case HTML_OPTION : target = & me -> option ; break ; case HTML_MATH : target = & me -> math <S2SV_ModEnd> ; break ; default : if ( ! me <S2SV_ModStart> text , c ) ; } } } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , "BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }
<S2SV_ModStart> 2 , module_object , "integer_array[%i]" , 2 ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> user_pwd ) ; unlink ( core_basename ) ; } # if 0 <S2SV_ModStart> ; } close ( src_fd ) ; } } # endif
<S2SV_ModStart> pid ) ; dd_create_basic_files ( dd , fsuid , <S2SV_ModEnd> NULL ) ; char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name"
<S2SV_ModStart> = xasprintf ( "/proc/self/fd/%d" , build_ids_fd ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR "/abrt-tmp-debuginfo.XXXXXX" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory" ) ; log_info ( "Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; { const char * verbs [ ] <S2SV_ModStart> args [ i ++ ] = repo ; } args [ i ++ ] = "--tmpdir" ; args [ i ++ ] = tmp_directory ; <S2SV_ModStart> path_env ) ; umask ( 0022 ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( "fork" ) ; if ( pid == 0 ) { <S2SV_ModStart> ) ; error_msg_and_die ( "Can\'t<S2SV_blank>execute<S2SV_blank>%s" , EXECUTABLE ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( "waitpid" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( "Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( "Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( "Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d" , WTERMSIG ( status ) ) ; error_msg_and_die ( "Child<S2SV_blank>exit<S2SV_blank>failed" ) ;
<S2SV_ModStart> * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid <S2SV_ModStart> ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; }
<S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( source_filename + source_base_ofs , "limits" <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( source_filename + source_base_ofs , "cgroup" <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; <S2SV_ModStart> ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid <S2SV_ModEnd> ) ; free ( dest_filename ) ; dd_save_text (
<S2SV_ModStart> struct dump_dir * dd = dd_create ( path , g_settings_privatereports ? 0 :
<S2SV_ModStart> dirname , g_settings_dump_location ) ; return 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( "abrt" ) ; if ( ! gr ) { error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; return 403 ; } } else
<S2SV_ModStart> "ShortenedReporting" ) ; } else g_settings_shortenedreporting = 0 ; value = get_map_string_item_or_NULL ( settings , "PrivateReports" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , "PrivateReports" ) ; }
<S2SV_ModStart> DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> { FILE * fp = fopen ( dest_filename , "wx" <S2SV_ModEnd> ) ; if ( ! fp ) return false
<S2SV_ModStart> void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; ACPI_OPERAND_OBJECT * Prev ; ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModEnd> ; Next = AcpiGbl_ModuleCodeList ; while ( Next ) <S2SV_ModStart> = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex (
<S2SV_ModStart> . nokeyerr ) ; if ( o == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> apr_table_setn ( r -> notes , "ssl-renegotiate-forbidden" , "verify-client" ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify
<S2SV_ModStart> { apr_socket_t * sock ; apr_status_t rv ; int do_read = 1 ; int <S2SV_ModStart> ; sock = ap_get_conn_socket ( r -> connection ) ; while ( do_read ) { do_read = 0 <S2SV_ModStart> ( sock , frame , & plen ) ; do_read = 1 ; } <S2SV_ModEnd> } } } return 0 ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , f -> r , APLOGNO ( 02555 ) "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>" "using<S2SV_blank>read-until-close" <S2SV_ModEnd> , tenc ) ; tenc = NULL ; } <S2SV_ModStart> , APLOGNO ( 01587 ) "Invalid<S2SV_blank>Content-Length" ) ; return APR_EINVAL <S2SV_ModEnd> ; } if ( ctx -> limit && ctx <S2SV_ModStart> = ap_pass_brigade ( f -> c -> output_filters , bb ) ; apr_brigade_cleanup ( <S2SV_ModStart> BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv = ap_get_brigade ( f -> next <S2SV_ModStart> if ( ctx -> state == BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } break ; } case BODY_NONE : <S2SV_ModStart> rv ; } break ; } default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) "Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } } } while ( again ) ;
<S2SV_ModStart> ) ; if ( ctx -> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> == LF ) { ctx -> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ( ! apr_isxdigit ( c ) ) { return APR_EINVAL <S2SV_ModEnd> ; } else { ctx -> state = BODY_CHUNK_PART <S2SV_ModStart> = 0 ; ctx -> chunkbits = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 ; ctx -> chunk_used = 0 <S2SV_ModStart> chunk_used = 0 ; } if ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx -> state = BODY_CHUNK_EXT ; } <S2SV_ModStart> -> state = BODY_CHUNK_EXT ; } else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART ) { int xvalue <S2SV_ModEnd> ; if ( ! ctx -> remaining && c <S2SV_ModStart> c == '0' ) { i ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> - 'a' + 0xa ; } else { return APR_EINVAL <S2SV_ModEnd> ; } ctx -> remaining = ( ctx -> <S2SV_ModStart> ctx -> remaining << 4 ) | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining < 0 ) { return APR_ENOSPC <S2SV_ModStart> remaining < 0 ) { return APR_ENOSPC ; } } else { return APR_EGENERAL ;
<S2SV_ModStart> = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } attr = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> ( job ) ; apply_printer_defaults ( printer , job <S2SV_ModEnd> ) ; if ( con -> username [ 0
<S2SV_ModStart> _cups_strcasecmp ( con -> clientname , "localhost." ) || <S2SV_ModEnd> ! strcmp ( con -> clientname , "127.0.0.1" )
<S2SV_ModStart> append_char ( s , c ) ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer , s -> str , XMLRPC_BUFSIZE )
<S2SV_ModStart> { service_named_unbind_command ( "chanserv" , & cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table ) ;
<S2SV_ModStart> { service_named_bind_command ( "chanserv" , & cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
<S2SV_ModStart> flags ) ; return ; } else if ( anope_flags_compat && <S2SV_ModStart> target ) ; return ; } else if ( anope_flags_compat && <S2SV_ModStart> name ) ; return ; } else if ( anope_flags_compat &&
<S2SV_ModStart> ; if ( ( '%' == in ) && ( alloc > 2 ) &&
<S2SV_ModStart> xfer -> filename , xfer -> size ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> ) ; if ( bee -> ui -> ft_in_start && bu
<S2SV_ModStart> , r -> req . tag , r -> qiov . size ) ; n = r -> qiov . size <S2SV_ModEnd> / 512 ; r -> sector += n ; <S2SV_ModStart> scsi_req_data ( & r -> req , r -> qiov . size <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> r , - EINVAL ) ; return ; } <S2SV_ModEnd> if ( s -> tray_open ) { scsi_read_complete ( <S2SV_ModStart> scsi_read_complete ( r , - ENOMEDIUM ) ; } n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ; if ( r -> req . aiocb <S2SV_ModEnd> == NULL ) { scsi_read_complete ( r , -
<S2SV_ModStart> , qdev , r -> req . dev ) <S2SV_ModEnd> ; uint32_t n ; if ( r -> req <S2SV_ModStart> { return ; } } n = r -> qiov . size <S2SV_ModEnd> / 512 ; r -> sector += n ; <S2SV_ModStart> -> req , GOOD ) ; } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( "Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n" , r -> req . <S2SV_ModStart> ( "Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n" , r -> req . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data ( & r -> req , <S2SV_ModStart> ) ; scsi_req_data ( & r -> req , r -> qiov . size <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; return ; } n = r -> qiov . size <S2SV_ModEnd> / 512 ; if ( n ) { if <S2SV_ModStart> scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_ModEnd> bdrv_acct_start ( s -> bs , & r ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int scsi_disk_emulate_command ( SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; uint8_t * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch ( req -> cmd . buf [
<S2SV_ModStart> ; case SCSI_REQ_STATUS_RETRY_FLUSH : ret = scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if ( ret == 0 ) {
<S2SV_ModStart> DO_UPCAST ( SCSIDiskReq , req , req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> qemu_vfree ( r -> iov . iov_base ) ; }
<S2SV_ModStart> static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> = MIN ( r -> sector_count * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external ( & r -> qiov ,
<S2SV_ModStart> qdev , d ) ; SCSIRequest * req ; <S2SV_ModEnd> req = scsi_req_alloc ( & scsi_disk_reqops , & s <S2SV_ModStart> qdev , tag , lun , hba_private ) ; <S2SV_ModEnd> return req ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> dev ) ; int32_t len ; uint8_t command ; <S2SV_ModEnd> int rc ; command = buf [ 0 ] <S2SV_ModStart> int rc ; command = buf [ 0 ] <S2SV_ModEnd> ; DPRINTF ( "Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x" , req -> lun , <S2SV_ModStart> : case VERIFY_10 : rc = scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if ( rc < 0 ) {
<S2SV_ModStart> { if ( string -> space == 0 ) { string -> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) string -> space * 2 ; if ( more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n" , G_STRLOC , new_len ) ; } } string -> space = more_space <S2SV_ModEnd> ; } } string -> glyphs = g_realloc (
<S2SV_ModStart> * re ; const char * text ; int result ; int <S2SV_ModStart> -> last ; opts |= REG_NOTBOL ; } } result = <S2SV_ModEnd> js_regexec ( re -> prog , text , & <S2SV_ModStart> prog , text , & m , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> re , const char * text ) { int result ; int <S2SV_ModStart> -> last ; opts |= REG_NOTBOL ; } } result = <S2SV_ModEnd> js_regexec ( re -> prog , text , & <S2SV_ModStart> prog , text , & m , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> while ( a <= e ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , a , & m ,
<S2SV_ModStart> js_toregexp ( J , 1 ) ; if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , source , & m , <S2SV_ModStart> ; else goto end ; } if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog , source , & m ,
<S2SV_ModStart> J , - 1 ) ; if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog , text , & m ,
<S2SV_ModStart> if ( e == text ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , text , & m , <S2SV_ModStart> while ( a < e ) { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog , a , & m ,
<S2SV_ModStart> emit ( J , F , OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> ( js_State * J ) { char buf [ 100 <S2SV_ModEnd> ] ; js_Object * self = js_toobject ( J <S2SV_ModStart> static const char digits [ ] = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_ModEnd> double number = self -> u . number ;
<S2SV_ModStart> w , double n ) { char buf [ 50 <S2SV_ModEnd> ] , * e ; sprintf ( buf ,
<S2SV_ModStart> unsigned char quitOption = 0 ; Browser_Window * window ; char * window_size_string = NULL <S2SV_ModStart> [ ] = { ECORE_GETOPT_VALUE_STR ( evas_engine_name ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> ewk_context_favicon_database_directory_set ( context , NULL ) ; if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if (
<S2SV_ModStart> url ) ; evas_object_resize ( app_data -> window , window_width , window_height <S2SV_ModEnd> ) ; evas_object_show ( app_data -> window ) ;
<S2SV_ModStart> -> bitcnt - bit_start ) ; if ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> ( char * ) buffer ) + pkg_length ; buffer_size -= ( size_t ) pkg_length ;
<S2SV_ModStart> ( oid_list_todo_num == 0 ) { DEBUG ( "snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree" ) ; snmp_free_pdu ( req <S2SV_ModStart> snmp_free_pdu ( res ) ; res = NULL ; <S2SV_ModEnd> sfree ( errstr ) ; csnmp_host_close_session ( host ) <S2SV_ModStart> res ) ; res = NULL ; if ( <S2SV_ModEnd> status == 0 ) csnmp_dispatch_table ( host , data
<S2SV_ModStart> ptr ) { if ( '%' == * ptr && ptr [ 1 ]
<S2SV_ModStart> ( ) ; errors += test_string_formatting ( ) ; errors += test_float_formatting ( ) ;
<S2SV_ModStart> data ) ; if ( data -> multi_easy ) { curl_multi_cleanup ( data -> multi_easy ) ; data -> multi_easy = NULL ; } <S2SV_ModEnd> Curl_llist_destroy ( & data -> state . timeoutlist ,
<S2SV_ModStart> ; scratch = newscratch = malloc ( 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; if ( ! newscratch ) { failf <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!" ) ; return CURLE_OUT_OF_MEMORY ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
<S2SV_ModStart> ptr += cut + 1 ; len -= cut + 1
<S2SV_ModStart> ) ; if ( ( ulen > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || ( plen > ( SIZE_T_MAX / 2
<S2SV_ModStart> num_chans = config -> num_channels ; int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> , "RF64" , 4 ) , got_ds64 = 0 , format_chunk = 0 <S2SV_ModStart> ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> WaveHeader ; int format_chunk = 0 ; uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 <S2SV_ModStart> if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 <S2SV_ModStart> . ckID , "DSD<S2SV_blank>" , 4 ) ) { if ( ! config -> num_channels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> 1 ) & ~ 1L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> "chan" , 4 ) ) { CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( caf_chunk_header . mChunkSize < sizeof ( <S2SV_ModStart> caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_ModStart> ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> meta_bc == 4 ) { if ( * dp != ( csum & 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( csum >> 8 ) & 0xff <S2SV_ModStart> ( csum >> 8 ) & 0xff ) || dp [ 2 ] <S2SV_ModEnd> != ( ( csum >> 16 ) & 0xff <S2SV_ModStart> ( csum >> 16 ) & 0xff ) || dp [ 3 ] <S2SV_ModEnd> != ( ( csum >> 24 ) & 0xff <S2SV_ModStart> ^= csum >> 16 ; if ( * dp != ( csum & 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( csum >> 8 ) & 0xff
<S2SV_ModStart> , chansSpecified , chanMask = 0 ; uint32_t sampleRate = 0 <S2SV_ModStart> ) ) { if ( ! config -> num_channels || ! config -> sample_rate
<S2SV_ModStart> || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; <S2SV_ModStart> && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) { error_line ( "%s" , WavpackGetErrorMessage (
<S2SV_ModStart> { int do_rf64 = 0 , write_junk = 1 , table_length = 0 <S2SV_ModStart> datahdr , fmthdr ; RiffChunkHeader riffhdr ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ( ds64hdr ) + sizeof ( ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk ) ; strncpy ( fmthdr . <S2SV_ModStart> ; ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> dataSize64 = total_data_bytes ; ds64_chunk . sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> . ckSize = ( uint32_t ) total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , "dmmy" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> || bcount != sizeof ( ds64_chunk ) ) ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk && ( ! DoWriteFile ( outfile ,
<S2SV_ModStart> wpc , WavpackConfig * config ) { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> ; } WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> ) ) { uint32_t mEditCount ; if ( ! desc_chunk || !
<S2SV_ModStart> -> use_ssl ? net_connect_ip_ssl ( ip , port , server -> connrec -> address ,
<S2SV_ModStart> if ( lex -> tk == LEX_ID ) { espruino_snprintf ( str , len , "ID:%s" , jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } else if ( lex -> tk <S2SV_ModStart> if ( lex -> tk == LEX_STR ) { espruino_snprintf ( str , len , "String:\'%s\'" , jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } else jslTokenAsString ( lex -> tk
<S2SV_ModStart> ; } assert ( len >= 10 ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; # endif # endif } else { strcpy ( result , "undefined" <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> len , int radix , int fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> 0.0000001 ; if ( isnan ( val ) ) strcpy ( str , "NaN" <S2SV_ModEnd> ) ; else if ( ! isfinite ( val <S2SV_ModStart> ) ) { if ( val < 0 ) strcpy ( str , "-Infinity" ) ; else strcpy ( str , "Infinity" <S2SV_ModEnd> ) ; } else { if ( val <
<S2SV_ModStart> . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else { jsExceptionHere ( JSET_ERROR , "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; } <S2SV_ModEnd> } JsVar * colorv = jsvObjectGetChild ( options ,
<S2SV_ModStart> gfx -> data . bpp ) : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> STACK_BASE - ( size_t ) & ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ; # else return 1000000 ; #
<S2SV_ModStart> , char * str , size_t len ) { assert ( len > 28 ) ; <S2SV_ModStart> } switch ( token ) { case LEX_EOF : strcpy ( str , "EOF" ) ; return ; case LEX_ID : strcpy ( str , "ID" ) ; return ; case LEX_INT : strcpy ( str , "INT" ) ; return ; case LEX_FLOAT : strcpy ( str , "FLOAT" ) ; return ; case LEX_STR : strcpy ( str , "STRING" ) ; return ; case LEX_UNFINISHED_STR : strcpy ( str , "UNFINISHED<S2SV_blank>STRING" ) ; return ; case LEX_TEMPLATE_LITERAL : strcpy ( str , "TEMPLATE<S2SV_blank>LITERAL" ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" ) ; return ; case LEX_REGEX : strcpy ( str , "REGEX" ) ; return ; case LEX_UNFINISHED_REGEX : strcpy ( str , "UNFINISHED<S2SV_blank>REGEX" ) ; return ; case LEX_UNFINISHED_COMMENT : strcpy ( str , "UNFINISHED<S2SV_blank>COMMENT" <S2SV_ModEnd> ) ; return ; } if ( token >= <S2SV_ModStart> ; } assert ( n == 0 ) ; strcpy ( str , & tokenNames [ p ] ) ; return ; } espruino_snprintf ( str , len <S2SV_ModEnd> , "?[%d]" , token ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( first ) { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if ( <S2SV_ModStart> else { if ( first ) { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if (
<S2SV_ModStart> ) , u1_nal_ref_idc , ps_dec ) ; if ( <S2SV_ModEnd> i_status != OK ) { return i_status ; }
<S2SV_ModStart> > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
<S2SV_ModStart> = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> , u1_frm ) ; if ( ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT ( "SPS:<S2SV_blank>mb_adaptive_frame_field_flag" , ps_seq -> u1_mb_aff_flag )
<S2SV_ModStart> ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }
<S2SV_ModStart> , 8 ) ; while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> , 8 ) ; while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
<S2SV_ModStart> ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> ] = silk_max_int ( NLSF_Q15 [ i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> ) ; NLSF_Q15 [ L - 1 ] =
<S2SV_ModStart> , d27u8 , d28u8 , d29u8 , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <S2SV_ModEnd> d28u32 = vld1_lane_u32 ( ( const uint32_t * ) <S2SV_ModStart> d4u8 , d5u8 ) ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> vld1q_u8 ( src_ptr ) ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> ; src_ptr += src_pixels_per_line ; d0u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_ModStart> [ 0 ] ) ; d1u8 = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset ] [ 1 ] ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp8_rtcd ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> br -> count ; int shift = VP8_BD_VALUE_SIZE - CHAR_BIT - ( count + CHAR_BIT <S2SV_ModEnd> ) ; size_t bytes_left = br -> user_buffer_end - <S2SV_ModStart> ( br -> decrypt_cb ) { size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br -> decrypt_cb ( br -> decrypt_state ,
<S2SV_ModStart> unsigned char * source , unsigned int source_sz , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void * decrypt_state ) { br ->
<S2SV_ModStart> MODE_INFO * mi , MB_MODE_INFO * mbmi ) { ( void ) mbmi ;
<S2SV_ModStart> x , i ) ; } } intra_pred_var = vpx_get_mb_ss <S2SV_ModEnd> ( x -> src_diff ) ; return intra_pred_var ;
<S2SV_ModStart> ( mv_row | mv_col ) & 7 ) { vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( uptr , pre_stride , mv_col & 7 , <S2SV_ModStart> , upred_ptr , uv_stride , & sse2 ) ; vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( vptr , pre_stride , mv_col & 7 , <S2SV_ModStart> ) ; sse2 += sse1 ; } else { vpx_variance8x8 <S2SV_ModEnd> ( uptr , pre_stride , upred_ptr , uv_stride , <S2SV_ModStart> , upred_ptr , uv_stride , & sse2 ) ; vpx_variance8x8 <S2SV_ModEnd> ( vptr , pre_stride , vpred_ptr , uv_stride ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_above_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO
<S2SV_ModStart> ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane ,
<S2SV_ModStart> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd <S2SV_ModStart> << ( tx_size << 1 ) ; int i = 0 , r , c ; const int max_blocks_wide = num_4x4_w + ( xd -> mb_to_right_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_right_edge >> ( 5 + pd -> <S2SV_ModStart> ( 5 + pd -> subsampling_x ) ) ; const int max_blocks_high = num_4x4_h + ( xd -> mb_to_bottom_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> mb_to_bottom_edge >> ( 5 + pd -> <S2SV_ModStart> ( 5 + pd -> subsampling_y ) ) ; const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> ; for ( r = 0 ; r < <S2SV_ModStart> ; for ( r = 0 ; r < max_blocks_high <S2SV_ModEnd> ; r += ( 1 << tx_size ) ) <S2SV_ModStart> { for ( c = 0 ; c < max_blocks_wide <S2SV_ModEnd> ; c += ( 1 << tx_size ) ) <S2SV_ModStart> c += ( 1 << tx_size ) ) { <S2SV_ModEnd> visit ( plane , i , plane_bsize , tx_size <S2SV_ModStart> , arg ) ; i += step ; } i += extra_step <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO
<S2SV_ModStart> [ i ] = 0 ; } else { memset <S2SV_ModEnd> ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) <S2SV_ModStart> [ i ] = 0 ; } else { memset <S2SV_ModEnd> ( l , has_eob , sizeof ( ENTROPY_CONTEXT )
<S2SV_ModStart> subsampling_y = i ? ss_y : 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; nmv_context * fc = & cm -> fc -> <S2SV_ModEnd> nmvc ; const nmv_context * pre_fc = & cm <S2SV_ModStart> counts = & cm -> counts . mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree , pre_fc -> joints , counts -> <S2SV_ModStart> comps [ i ] ; comp -> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> sign , c -> sign ) <S2SV_ModStart> pre_comp -> sign , c -> sign ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree , pre_comp -> classes , c -> <S2SV_ModStart> c -> classes , comp -> classes ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree , pre_comp -> class0 , c -> <S2SV_ModStart> j ) comp -> bits [ j ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> bits [ j ] , c <S2SV_ModStart> 0 ; j < CLASS0_SIZE ; ++ j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] <S2SV_ModStart> , comp -> class0_fp [ j ] ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree , pre_comp -> fp , c -> <S2SV_ModStart> if ( allow_hp ) { comp -> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> class0_hp , c -> class0_hp ) <S2SV_ModStart> c -> class0_hp ) ; comp -> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp -> hp , c -> hp )
<S2SV_ModStart> ( VP9_COMMON * cm ) { cm -> fc -> <S2SV_ModEnd> nmvc = default_nmv_context ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> int16_t vp9_ac_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return ac_qlookup [ clamp ( qindex + delta , <S2SV_ModStart> + delta , 0 , MAXQ ) ] ; case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> <S2SV_null> int16_t vp9_dc_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return dc_qlookup [ clamp ( qindex + delta , <S2SV_ModStart> + delta , 0 , MAXQ ) ] ; case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> int segment_id , int base_qindex ) { if ( segfeature_active <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_ALT_Q ) ) { <S2SV_ModStart> , SEG_LVL_ALT_Q ) ) { const int data = get_segdata <S2SV_ModEnd> ( seg , segment_id , SEG_LVL_ALT_Q ) ; const
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_rtcd ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> other_h , int this_w , int this_h ) { # endif if ( ! valid_ref_frame_size <S2SV_ModEnd> ( other_w , other_h , this_w , this_h ) <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> ; } else { sf -> predict [ 0 <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> ; } } else { if ( sf -> <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> ; } else { sf -> predict [ 0 <S2SV_ModStart> 0 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> min_log2_tile_cols , int * max_log2_tile_cols ) { const int sb64_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; * min_log2_tile_cols = get_min_log2_tile_cols ( sb64_cols ) ; * max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> cm , int row , int col ) { vp9_tile_set_row ( tile , cm , row ) ; vp9_tile_set_col ( tile , cm , col <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_term_subexp ( vpx_reader * r ) { if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 4 ) ; if ( ! <S2SV_ModStart> ( r , 4 ) ; if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 4 ) + 16 ; if <S2SV_ModStart> , 4 ) + 16 ; if ( ! vpx_read_bit ( r ) ) return vpx_read_literal <S2SV_ModEnd> ( r , 5 ) + 32 ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int decode_uniform ( vpx_reader <S2SV_ModEnd> * r ) { const int l = 8 <S2SV_ModStart> l ) - 191 ; const int v = vpx_read_literal <S2SV_ModEnd> ( r , l - 1 ) ; return <S2SV_ModStart> : ( v << 1 ) - m + vpx_read_bit <S2SV_ModEnd> ( r ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> > 2 * m ) return v ; return ( v & 1 ) ? m - ( ( v + 1 ) >> 1 ) : m + ( v >> 1 ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int m ) { static int inv_map_table [ MAX_PROB ] = { 7 , 20 , 33 , 46 , 59 , 72 , 85 , 98 , 111 , 124 , 137 , 150 , 163 , 176 , 189 , 202 , 215 , 228 , 241 , 254 , 1 , 2 , 3 , 4 , 5 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 253 } ; assert ( v < ( int ) ( sizeof ( inv_map_table ) / sizeof ( inv_map_table [ 0 ] ) ) <S2SV_ModEnd> ) ; v = inv_map_table [ v ] ; <S2SV_ModStart> MAX_PROB ) { return 1 + inv_recenter_nonneg ( v <S2SV_ModEnd> , m ) ; } else { return MAX_PROB <S2SV_ModStart> } else { return MAX_PROB - inv_recenter_nonneg ( v <S2SV_ModEnd> , MAX_PROB - 1 - m ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_diff_update_prob ( vpx_reader * r , vpx_prob * p ) { if ( vpx_read <S2SV_ModEnd> ( r , DIFF_UPDATE_PROB ) ) { const int <S2SV_ModStart> decode_term_subexp ( r ) ; * p = ( vpx_prob <S2SV_ModEnd> ) inv_remap_prob ( delp , * p ) ;
<S2SV_ModStart> <S2SV_null> static void cost ( int * costs , vpx_tree tree , const vpx_prob <S2SV_ModEnd> * probs , int i , int c ) <S2SV_ModStart> , int i , int c ) { const vpx_prob <S2SV_ModEnd> prob = probs [ i / 2 ] ; <S2SV_ModStart> + vp9_cost_bit ( prob , b ) ; const vpx_tree_index <S2SV_ModEnd> ii = tree [ i + b ] ;
<S2SV_ModStart> <S2SV_null> void vp9_cost_tokens ( int * costs , const vpx_prob * probs , vpx_tree <S2SV_ModEnd> tree ) { cost ( costs , tree ,
<S2SV_ModStart> <S2SV_null> void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vpx_tree <S2SV_ModEnd> tree ) { assert ( tree [ 0 ]
<S2SV_ModStart> , SPEED_FEATURES * sf , int speed ) { const int boosted = frame_is_boosted ( cpi ) ; sf -> adaptive_rd_thresh = 1 <S2SV_ModEnd> ; sf -> allow_skip_recode = 1 ; if ( <S2SV_ModStart> 1 ; if ( speed >= 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; } sf -> less_rectangular_check = 1 ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; sf -> mv . auto_mv_step_size = 1 ; sf -> adaptive_rd_thresh = 2 ; sf -> mv . subpel_iters_per_step = 1 ; sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 ; } if ( speed >= 2 ) { sf -> tx_size_search_method = frame_is_boosted ( cpi ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf <S2SV_ModStart> ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } if ( speed >= 3 ) { <S2SV_ModStart> ; } if ( speed >= 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> <S2SV_ModStart> ; sf -> mode_skip_start = 6 ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 ; } if ( speed >= 4 <S2SV_ModStart> ; sf -> tx_size_search_method = USE_LARGESTALL ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE ; sf -> adaptive_rd_thresh = 4 ; if ( cm -> frame_type != KEY_FRAME ) sf -> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ; sf <S2SV_ModStart> ; sf -> disable_filter_search_var_thresh = 200 ; sf -> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModEnd> ; } if ( speed >= 5 ) { <S2SV_ModStart> >= 5 ) { int i ; sf -> optimize_coefficients = 0 ; sf -> mv . <S2SV_ModEnd> search_method = HEX ; sf -> disable_filter_search_var_thresh = 500 <S2SV_ModStart> ) { sf -> intra_y_mode_mask [ i ] = INTRA_DC ; sf -> intra_uv_mode_mask [ i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void set_rt_speed_feature ( VP9_COMP * cpi , SPEED_FEATURES * sf , int speed , vp9e_tune_content content ) { VP9_COMMON * const cm = & cpi -> common ; const int is_keyframe = cm -> frame_type == KEY_FRAME ; const int frames_since_key = is_keyframe ? 0 : cpi -> rc . frames_since_key ; <S2SV_ModEnd> sf -> static_segmentation = 0 ; sf -> adaptive_rd_thresh <S2SV_ModStart> ; sf -> adaptive_rd_thresh = 1 ; sf -> use_fast_coef_costing = 1 ; if ( speed >= <S2SV_ModEnd> 1 ) { sf -> use_square_partition_only = ! frame_is_intra_only <S2SV_ModStart> frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; <S2SV_ModEnd> sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search <S2SV_ModStart> ; sf -> adaptive_pred_interp_filter = 1 ; sf -> mv . <S2SV_ModStart> ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V <S2SV_ModEnd> ; } if ( speed >= 2 ) { <S2SV_ModStart> if ( speed >= 2 ) { sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf <S2SV_ModStart> | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC && cpi -> svc . number_spatial_layers == 1 ) ? 1 : 0 <S2SV_ModEnd> ; sf -> disable_filter_search_var_thresh = 50 ; sf -> <S2SV_ModStart> ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; sf -> lf_motion_threshold = LOW_MOTION_THRESHOLD <S2SV_ModEnd> ; sf -> adjust_partitioning_from_last_frame = 1 ; sf -> <S2SV_ModStart> ; sf -> last_partitioning_redo_frequency = 3 ; sf -> <S2SV_ModEnd> use_lp32x32fdct = 1 ; sf -> mode_skip_start = 11 <S2SV_ModStart> -> mode_skip_start = 11 ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V <S2SV_ModEnd> ; } if ( speed >= 3 ) { <S2SV_ModStart> ; sf -> disable_filter_search_var_thresh = 100 ; sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate = 1 ; sf -> skip_encode_sb = 1 <S2SV_ModStart> ; sf -> skip_encode_sb = 1 ; sf -> mv . subpel_iters_per_step = 1 ; sf -> <S2SV_ModEnd> adaptive_rd_thresh = 4 ; sf -> mode_skip_start = 6 <S2SV_ModStart> disable_split_mask = DISABLE_ALL_SPLIT ; sf -> lpf_pick = LPF_PICK_FROM_Q <S2SV_ModEnd> ; } if ( speed >= 4 ) { <S2SV_ModStart> != cm -> frame_type || ( 0 == ( frames_since_key <S2SV_ModEnd> + 1 ) % sf -> last_partitioning_redo_frequency ) ; <S2SV_ModStart> ) % sf -> last_partitioning_redo_frequency ) ; sf -> mv . <S2SV_ModStart> INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ i ] = INTRA_DC <S2SV_ModEnd> ; } sf -> intra_y_mode_mask [ TX_32X32 ] = <S2SV_ModStart> ; } sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC <S2SV_ModEnd> ; sf -> frame_parameter_update = 0 ; sf -> <S2SV_ModStart> ; sf -> frame_parameter_update = 0 ; sf -> mv . search_method = FAST_HEX ; sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEAR_NEW ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST <S2SV_ModEnd> ; sf -> max_intra_bsize = BLOCK_32X32 ; sf -> <S2SV_ModStart> if ( speed >= 5 ) { sf -> use_quant_fp = ! is_keyframe ; sf -> auto_min_max_partition_size = is_keyframe ? RELAXED_NEIGHBORING_MIN_MAX : STRICT_NEIGHBORING_MIN_MAX ; sf -> default_max_partition_size = BLOCK_32X32 ; sf -> default_min_partition_size = BLOCK_8X8 ; sf -> force_frame_boost = is_keyframe || ( frames_since_key <S2SV_ModEnd> % ( sf -> last_partitioning_redo_frequency << 1 ) == <S2SV_ModStart> ) == 1 ) ; sf -> max_delta_qindex = is_keyframe <S2SV_ModEnd> ? 20 : 15 ; sf -> partition_search_type = <S2SV_ModStart> ; sf -> use_nonrd_pick_mode = 1 ; sf -> allow_skip_recode = 0 ; sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> adaptive_rd_thresh = 2 ; sf -> reuse_inter_pred_sby = 1 ; sf -> partition_search_breakout_rate_thr = 200 ; sf -> coeff_prob_appx_step = 4 ; sf -> use_fast_coef_updates = is_keyframe ? TWO_LOOP : ONE_LOOP_REDUCED ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH ; sf -> tx_size_search_method = is_keyframe ? USE_LARGESTALL : USE_TX_8X8 ; sf -> simple_model_rd_from_var = 1 ; if ( ! is_keyframe ) { int i ; if ( content == VP9E_CONTENT_SCREEN ) { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_TM_H_V ; } else { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) if ( i >= BLOCK_16X16 ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC ; else sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_H_V ; } } <S2SV_ModEnd> } if ( speed >= 6 ) { sf <S2SV_ModStart> speed >= 6 ) { sf -> partition_search_type = VAR_BASED_PARTITION <S2SV_ModEnd> ; sf -> use_nonrd_pick_mode = 1 ; sf -> <S2SV_ModStart> ; sf -> use_nonrd_pick_mode = 1 ; sf -> mv . search_method = NSTEP ; sf -> mv . reduce_first_step_size = 1 ; sf -> skip_encode_sb = 0 <S2SV_ModEnd> ; } if ( speed >= 7 ) { <S2SV_ModStart> ; } if ( speed >= 7 ) { sf -> adaptive_rd_thresh = 3 ; sf -> mv . search_method = FAST_DIAMOND ; sf -> mv . fullpel_search_step_param = 10 ; if ( cpi -> svc . number_temporal_layers > 2 && cpi -> svc . temporal_layer_id == 0 ) { sf -> mv . search_method = NSTEP ; sf -> mv . fullpel_search_step_param = 6 ; } } if ( speed >= 8 ) { sf -> adaptive_rd_thresh = 4 ; sf -> mv . subpel_force_stop = 2 ; sf -> lpf_pick = LPF_PICK_MINIMAL_LPF <S2SV_ModEnd> ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_term_subexp ( vpx_writer <S2SV_ModEnd> * w , int word ) { if ( <S2SV_ModStart> ( w , word , 16 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word , 4 ) ; } <S2SV_ModStart> ( w , word , 32 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word - 16 , 4 ) <S2SV_ModStart> ( w , word , 64 ) ) { vpx_write_literal <S2SV_ModEnd> ( w , word - 32 , 5 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void encode_uniform ( vpx_writer <S2SV_ModEnd> * w , int v ) { const int <S2SV_ModStart> 191 ; if ( v < m ) { vpx_write_literal <S2SV_ModEnd> ( w , v , l - 1 ) <S2SV_ModStart> , l - 1 ) ; } else { vpx_write_literal <S2SV_ModEnd> ( w , m + ( ( v - <S2SV_ModStart> >> 1 ) , l - 1 ) ; vpx_write_literal <S2SV_ModEnd> ( w , ( v - m ) &
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int prob_diff_update_cost ( vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) { int delp = remap_prob ( newp
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_cond_prob_diff_update ( vpx_writer * w , vpx_prob <S2SV_ModEnd> * oldp , const unsigned int ct [ 2 <S2SV_ModStart> unsigned int ct [ 2 ] ) { const vpx_prob upd = DIFF_UPDATE_PROB ; vpx_prob <S2SV_ModEnd> newp = get_binary_prob ( ct [ 0 ] , <S2SV_ModStart> ) ; if ( savings > 0 ) { vpx_write <S2SV_ModEnd> ( w , 1 , upd ) ; vp9_write_prob_diff_update <S2SV_ModStart> ; * oldp = newp ; } else { vpx_write <S2SV_ModEnd> ( w , 0 , upd ) ; }
<S2SV_ModStart> int vp9_prob_diff_update_savings_search ( const unsigned int * ct , vpx_prob oldp , vpx_prob * bestp , vpx_prob <S2SV_ModEnd> upd ) { const int old_b = cost_branch256 ( <S2SV_ModStart> , oldp ) ; int bestsavings = 0 ; vpx_prob <S2SV_ModEnd> newp , bestnewp = oldp ; const int step
<S2SV_ModStart> vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , const vpx_prob * oldp , vpx_prob * bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , old_b , new_b , update_b , savings <S2SV_ModStart> savings , bestsavings , step ; int newp ; vpx_prob <S2SV_ModEnd> bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ <S2SV_ModStart> ] ; vp9_model_to_full_probs ( oldp , oldplist ) ; memcpy ( newplist , oldp , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES ) ; for ( i = <S2SV_ModStart> 0 ; bestnewp = oldp [ PIVOT_NODE ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> oldp [ PIVOT_NODE ] ; newp += step ) <S2SV_ModStart> = savings ; bestnewp = newp ; } } } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return bestsavings ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_write_prob_diff_update ( vpx_writer * w , vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) { const int delp = remap_prob (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static INLINE int write_bit_gte ( vpx_writer <S2SV_ModEnd> * w , int word , int test ) <S2SV_ModStart> w , int word , int test ) { vpx_write_literal <S2SV_ModEnd> ( w , word >= test , 1 )
<S2SV_ModStart> static unsigned int convert_distribution ( unsigned int i , vpx_tree <S2SV_ModEnd> tree , unsigned int branch_ct [ ] [ 2
<S2SV_ModStart> void tree2tok ( struct vp9_token * tokens , const vpx_tree_index <S2SV_ModEnd> * tree , int i , int v , <S2SV_ModStart> += v ; ++ l ; do { const vpx_tree_index <S2SV_ModEnd> j = tree [ i ++ ] ; if
<S2SV_ModStart> void vp9_tokens_from_tree ( struct vp9_token * tokens , const vpx_tree_index <S2SV_ModEnd> * tree ) { tree2tok ( tokens , tree
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned int branch_ct [ ] [ 2
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> cospi_8_64 ) ; const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> cospi_16_64 ) ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> sinpi_2_9 ) ; const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> cospi_16_64 ) ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 16 ] ; const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p08_m24 = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> ) ; const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - <S2SV_ModStart> ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p24_p08 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModEnd> u [ 0 ] = _mm_add_epi32 ( v [ <S2SV_ModStart> 1 ] ) ; s [ 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> , t [ 2 ] ) ; s [ 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ <S2SV_ModEnd> 6 ] ) ; u [ 0 ] =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> in ) { const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> in ) { const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> dest_pitch , dest_width ) ; if ( interpolation ) memcpy <S2SV_ModEnd> ( temp_area , temp_area + source_band_height * dest_pitch , <S2SV_ModStart> , hratio , dest_width ) ; } else { memcpy <S2SV_ModEnd> ( temp_area + i * dest_pitch , temp_area + <S2SV_ModStart> , dest_pitch , vratio , dest_band_height ) ; } memcpy <S2SV_ModEnd> ( temp_area , temp_area + source_band_height * dest_pitch ,
<S2SV_ModStart> , const struct VpxRational * framerate , vpx_img_fmt_t fmt , unsigned int bit_depth ) { const char * color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> color = fmt == VPX_IMG_FMT_444A ? "C444alpha\\n" : fmt <S2SV_ModStart> : fmt == VPX_IMG_FMT_I422 ? "C422\\n" : "C420jpeg\\n" ; break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p9<S2SV_blank>XYSCSS=444P9\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p9<S2SV_blank>XYSCSS=422P9\\n" : "C420p9<S2SV_blank>XYSCSS=420P9\\n" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p10<S2SV_blank>XYSCSS=444P10\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p10<S2SV_blank>XYSCSS=422P10\\n" : "C420p10<S2SV_blank>XYSCSS=420P10\\n" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p12<S2SV_blank>XYSCSS=444P12\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p12<S2SV_blank>XYSCSS=422P12\\n" : "C420p12<S2SV_blank>XYSCSS=420P12\\n" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p14<S2SV_blank>XYSCSS=444P14\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p14<S2SV_blank>XYSCSS=422P14\\n" : "C420p14<S2SV_blank>XYSCSS=420P14\\n" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p16<S2SV_blank>XYSCSS=444P16\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p16<S2SV_blank>XYSCSS=422P16\\n" : "C420p16<S2SV_blank>XYSCSS=420P16\\n" ; break ; default : color = NULL ; assert ( 0 ) ; }
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> < 0 ) { ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256" ) ;
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> else { pWTIntFrame -> numSamples = numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( "b/26366256" ) ; pWTIntFrame -> numSamples = 0 ; }
<S2SV_ModStart> EAS_U32 value ) { if ( * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( "b/34031018,<S2SV_blank>stackPtr(%d)" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , "34031018" ) ; return EAS_ERROR_FILE_FORMAT ; } <S2SV_ModEnd> * pStackPtr = * pStackPtr + 1 ; pStack
<S2SV_ModStart> , ptblPos , wvplPos , wvplSize ) ; } if ( dls . pDLS ) { <S2SV_ModStart> 0 ) ; dls . artCount = 1 ; }
<S2SV_ModStart> default : break ; } } if ( dataSize < 0 || dataSize
<S2SV_ModStart> map_trigger * trigger ; struct map_zone * zone ; size_t tilemap_size ; <S2SV_ModStart> s_map -> layers [ layer ] . height ; tilemap_size = <S2SV_ModEnd> x_size * y_size * sizeof ( struct map_tile ) <S2SV_ModStart> x_size * y_size * sizeof ( struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
<S2SV_ModStart> ) ; if ( extra_length > available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> { memcpy ( cp , qp -> d_memory , original_length <S2SV_ModEnd> ) ; qp -> d_read = cp + (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.64<S2SV_blank>2014/07/24<S2SV_blank>19:35:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.190<S2SV_blank>2014/06/03<S2SV_blank>19:01:34<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.61<S2SV_blank>2014/06/04<S2SV_blank>17:23:19<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.60<S2SV_blank>2014/05/21<S2SV_blank>13:04:38<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.171<S2SV_blank>2014/01/08<S2SV_blank>22:02:06<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>apprentice.c,v<S2SV_blank>1.210<S2SV_blank>2014/05/14<S2SV_blank>23:15:42<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.196<S2SV_blank>2014/11/07<S2SV_blank>15:24:14<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>funcs.c,v<S2SV_blank>1.81<S2SV_blank>2015/05/28<S2SV_blank>19:26:59<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.55<S2SV_blank>2014/02/27<S2SV_blank>23:26:17<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>readcdf.c,v<S2SV_blank>1.40<S2SV_blank>2014/03/06<S2SV_blank>15:23:33<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>funcs.c,v<S2SV_blank>1.73<S2SV_blank>2014/09/10<S2SV_blank>18:41:51<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.197<S2SV_blank>2014/11/11<S2SV_blank>17:48:23<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>softmagic.c,v<S2SV_blank>1.188<S2SV_blank>2014/05/14<S2SV_blank>23:15:42<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.62<S2SV_blank>2014/06/04<S2SV_blank>17:26:07<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.56<S2SV_blank>2014/05/05<S2SV_blank>16:11:21<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>apprentice.c,v<S2SV_blank>1.227<S2SV_blank>2014/11/28<S2SV_blank>02:46:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>file.c,v<S2SV_blank>1.159<S2SV_blank>2014/11/28<S2SV_blank>02:46:39<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>magic.c,v<S2SV_blank>1.90<S2SV_blank>2014/12/04<S2SV_blank>15:56:46<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.59<S2SV_blank>2014/05/14<S2SV_blank>23:22:48<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void AddSubPST ( SplineChar * sc , struct lookup_subtable <S2SV_ModStart> -> possub ; sc -> possub = pst ; } Sp <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> enum fchooserret CMapFilter ( GGadget * g , GDirEntry <S2SV_ModStart> filename ) ; } return ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVAllSelected ( FontView * fv ) { int <S2SV_ModStart> = true ; } return ( any ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVAnyCharSelected ( FontView * fv ) { int <S2SV_ModStart> ) ; } } return ( val ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontViewBase * FVAny ( void ) { return ( <S2SV_ModStart> ) { return ( FontViewBase * ) fv_list ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVChangeChar ( FontView * fv , int i ) <S2SV_ModStart> i ) ; FVShowInfo ( fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVChangeDisplayFont ( FontView * fv , BDFFont * <S2SV_ModStart> mbh + fv -> infoh ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVChar ( FontView * fv , GEvent * event <S2SV_ModStart> ) FVChangeChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> GFont * FVCheckFont ( FontView * fv , int <S2SV_ModStart> ( fv -> fontset [ type ] ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVCopyInnards ( FontView * fv , GRect * <S2SV_ModStart> fvorig -> colcnt ) / fv -> colcnt ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVCreateInnards ( FontView * fv , GRect * <S2SV_ModStart> 1 ; FVChangeDisplayFont ( fv , bdf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVDelay ( FontView * fv , void ( * <S2SV_ModStart> 0 , ( void * ) func ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVDoTransform ( FontView * fv ) { enum <S2SV_ModStart> FVTransFunc , getorigin , flags , cvt_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVDrawInfo ( FontView * fv , GWindow pixmap , <S2SV_ModStart> ( pixmap , & old ) ; return ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVEncodingMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map -> enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVExpose ( FontView * fv , GWindow pixmap <S2SV_ModStart> ) ; GDrawSetDither ( NULL , true ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVExtraEncSlots ( FontView * fv , int encmax <S2SV_ModStart> -> rowltot , fv -> rowcnt ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> SplineChar * FVFindACharInDisplay ( FontView * fv ) { <S2SV_ModStart> sc ) ; } return ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVForceEncodingMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map -> enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> lineChar <S2SV_ModEnd> * FVMakeChar ( FontView * fv , int enc <S2SV_ModStart> ) ; } else return ( base_sc ) ; } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddEncodingName ( GWindow UNUSED ( gw ) , <S2SV_ModStart> "Invalid<S2SV_blank>Encoding" ) ) ; free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddExtrema ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAddUnencoded ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , cnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAnchorPairs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoCounter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoCounter ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoHintSubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoHintSubs ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoHint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoHint ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoInstr ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVAutoInstr ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutoWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVAutoWidth2 ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuAutotrace ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GDrawSetCursor ( fv -> v , ct ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBDFInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBaseHoriz ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , false ) ; SFBaseSort ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBaseVert ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , true ) ; SFBaseSort ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBitmaps ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( mi -> mid == MID_AvailBitmaps ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBlendToNew ( GWindow gw , struct gmenuitem * <S2SV_ModStart> MMChangeBlend ( mm , fv , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildAccent ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildComposite ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuBuildDuplicate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } # i <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCIDFontInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . active_layer , - 1 , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCanonicalContours ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCanonicalStart ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCenter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , mi -> mid == MID_Center ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeChar ( GWindow gw , struct gmenuitem * <S2SV_ModStart> _FVMenuChangeChar ( fv , mi -> mid ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeGlyph ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_generic ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeLayer ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mi -> mid ; FV_LayerChanged ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeMMBlend ( GWindow gw , struct gmenuitem * <S2SV_ModStart> MMChangeBlend ( mm , fv , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeSupplement ( GWindow gw , struct gmenuitem * <S2SV_ModStart> = supple ; FontViewSetTitle ( fv ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuChangeXHeight ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ChangeXHeightDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCharInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . map , pos ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCleanup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GDrawGetUserData ( gw ) , - 1 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearBackground ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClearBackground ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearHints ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClearHints ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearInstrs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClearInstrs ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClearSpecialData ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClearSpecialData ( ( FontViewBase * ) fv ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClear ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVClear ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuClose ( GWindow gw , struct gmenuitem * <S2SV_ModStart> container ) ; else _FVMenuClose ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCluster ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) GDrawGetUserData ( gw ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompact ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) FVScrollToChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompareFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FontCompareDlg ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCompareL2L ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCompareLayerToLayer ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCondense ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; CondenseExtendDlg ( fv , NULL ) ; } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuContextualHelp ( GWindow UNUSED ( base ) , <S2SV_ModStart> e ) ) { help ( "fontview.html" ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuConvert2CID ( GWindow gw , struct gmenuitem * <S2SV_ModStart> SFRestoreNearTop ( fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuConvertByCMap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , NULL ) ; free ( cmapfilename ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyFgBg ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVCopyFgtoBg ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyFrom ( GWindow UNUSED ( gw ) , <S2SV_ModStart> == MID_DisplayedFont ) ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyL2L ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCopyLayerToLayer ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyLookupData ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_lookups ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_reference ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopyWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_CopyLBearing ? ut_lbearing : ut_rbearing ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCopy ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , ct_fullcopy ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCorrectDir ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVCorrectDir ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCorrectRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVCorrectReferences ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCreateMM ( GWindow UNUSED ( gw ) , <S2SV_ModStart> e ) ) { MMWizard ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuCut ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVClear ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDefineGroups ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; DefineGroups ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDeltas ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; DeltaSuggestionDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDeselectAll ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVDeselectAll ( fv ) ; } en <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDetachAndRemoveGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVDetachAndRemoveGlyphs ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDetachGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVDetachGlyphs ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDisplayByGroups ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; DisplayGroups ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDisplaySubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuDontAutoHint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVDontAutoHint ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEditInstrs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , index ) ; SCEditInstructions ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEditTable ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , 'v' , 't' , '<S2SV_blank>' ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuEmbolden ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; EmboldenDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuExecute ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ScriptDlg ( fv , NULL ) ; } # e <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuExit ( GWindow UNUSED ( base ) , <S2SV_ModStart> e ) ) { _MenuExit ( NULL ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFindProblems ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FindProblems ( fv , NULL , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFindRpl ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; SVCreate ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFlattenByCMap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf ) ; free ( cmapname ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFlatten ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) return ; SFFlatten ( & cidmaster ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuFontInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> is_modal ) return ; FontMenuFontInfo ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuForceEncode ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FontViewReformatOne ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerateFamily ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_macfamily ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerateTTC ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_ttc ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGenerate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; _FVMenuGenerate ( fv , gf_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphLabel ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , false ) ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsBoth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsSplines ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGlyphsWhite ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuGotoChar ( GWindow gw , struct gmenuitem * <S2SV_ModStart> pos ) ; FVShowInfo ( fv ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuHistograms ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_VStemHist ? hist_vstem : hist_blues ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuImport ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) fv , bdf ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInsertBlank ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( FontViewBase * ) fv , sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInsertFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , new ) ; CIDMasterAsDes ( new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInterpFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVInterpolateFonts ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuInvertSelection ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVInvertSelection ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuItalic ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ItalicDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuJoin ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVJoin ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuJustify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> b . cidmaster ; JustifyDlg ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKPCloseup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKernByClasses ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuKernPairs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . sf , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLigatures ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . sf , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLoadEncoding ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( e ) ) { LoadEncodingFile ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuLoadNamelist ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( old ) ; fclose ( new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMATHInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMMInfo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; MMWizard ( mm ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMMValid ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; MMValid ( mm , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMagnify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> show ) ; } free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMakeFromFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . map ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMakeNamelist ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , file ) ; fclose ( file ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMassRename ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVMassGlyphRename ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMergeFonts ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVMergeFonts ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuMergeKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . map ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuNLTransform ( GWindow gw , struct gmenuitem * <S2SV_ModStart> return ; NonLinearDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuNameGlyphs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewReformatAll ( fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOblique ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; ObliqueDlg ( fv , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenBitmap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) BitmapViewCreatePick ( i , fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenMetrics ( GWindow gw , struct gmenuitem * <S2SV_ModStart> show ? NULL : fv -> show ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpenOutline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( sc , fv , i ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOpen ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuOpen ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOutline ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuOverlap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_Intersection ? over_intersect : over_findinter ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPOV ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FontViewBase * ) fv , & pov_data ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPasteAfter ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b , 2 , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPasteInto ( GWindow gw , struct gmenuitem * <S2SV_ModStart> * ) fv , true , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPaste ( GWindow gw , struct gmenuitem * <S2SV_ModStart> * ) fv , false , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuPrint ( GWindow gw , struct gmenuitem * <S2SV_ModStart> PrintFFDlg ( fv , NULL , NULL ) ; } # i <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRedo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRedo ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuReencode ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) FVScrollToChar ( fv , enc ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveEncoding ( GWindow UNUSED ( gw ) , <S2SV_ModStart> ( e ) ) { RemoveEncoding ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveFontFromCID ( GWindow gw , struct gmenuitem * <S2SV_ModStart> . sf ) ; SplineFontFree ( sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVRemoveKerns ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveUndoes ( GWindow gw , struct gmenuitem * <S2SV_ModStart> selected , fv -> b . map ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveUnused ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRemoveUnused ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRemoveVKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVRemoveVKerns ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRenameByNamelist ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuReplaceWithRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; FVReplaceOutlineWithReference ( fv , .001 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevertBackup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVRevertBackup ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevertGlyph ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVRevertGlyph ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRevert ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVRevert ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRmInstrTables ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( fv -> b . sf ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRound2Hundredths ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , 100.0 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuRound2Int ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , 1.0 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSameGlyphAs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSaveAs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuSaveAs ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSave ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; _FVMenuSave ( fv ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectAll ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVSelectAll ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectAutohintable ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByName ( GWindow _gw , struct gmenuitem * <S2SV_ModStart> 0 ; } } GDrawDestroyWindow ( gw ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByPST ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVSelectByPST ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectByScript ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( fv , SelMergeType ( e ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectChanged ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectColor ( GWindow gw , struct gmenuitem * <S2SV_ModStart> , col , SelMergeType ( e ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectHintingNeeded ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSelectWorthOutputting ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetColor ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; } FVSetColor ( fv , col ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetExtremumBound ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; } } free ( ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSetWidth ( GWindow gw , struct gmenuitem * <S2SV_ModStart> mid == MID_SetBearings ? wt_bearings : wt_vwidth ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShadow ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowAtt ( GWindow gw , struct gmenuitem * <S2SV_ModStart> sf , fv -> b . active_layer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowBitmap ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata ; FV_ChangeDisplayBitmap ( fv , bdf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowDependentRefs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; SCRefBy ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowDependentSubs ( GWindow gw , struct gmenuitem * <S2SV_ModStart> NULL ) return ; SCSubBy ( sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowMetrics ( GWindow fvgw , struct gmenuitem * <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuShowSubFont ( GWindow gw , struct gmenuitem * <S2SV_ModStart> userdata ; FVShowSubFont ( fv , new ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSimplifyMore ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSimplify ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) GDrawGetUserData ( gw ) , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSize ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ] -> display_size = - dspsize ; } } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSmallCaps ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_smallcaps ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuStroke ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVStroke ( fv ) ; } # <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuSubSup ( GWindow gw , struct gmenuitem * <S2SV_ModStart> GlyphChangeDlg ( fv , NULL , gc_subsuper ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuTransform ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ( gw ) ; FVDoTransform ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUndoFontLevel ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ) ; SFUndoRemoveAndFree ( sf , undo ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUndo ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVUndo ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuUnlinkRef ( GWindow gw , struct gmenuitem * <S2SV_ModStart> FVUnlinkRef ( ( FontViewBase * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuVKernByClasses ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuVKernFromHKern ( GWindow gw , struct gmenuitem * <S2SV_ModStart> ; FVVKernFromHKern ( & fv -> b ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuValidate ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv -> b . active_layer , ff_none ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuWSize ( GWindow gw , struct gmenuitem * <S2SV_ModStart> default_fv_row_count = v ; SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMenuWireframe ( GWindow gw , struct gmenuitem * <S2SV_ModStart> fv , NULL , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVMouse ( FontView * fv , GEvent * <S2SV_ModStart> et_mouseup ) SVAttachFV ( fv , 2 ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVRefreshChar ( FontView * fv , int gid ) <S2SV_ModStart> fv , enc , true ) ; } } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVRegenChar ( FontView * fv , SplineChar * sc <S2SV_ModStart> FVRegenChar ( fv , dlist -> sc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVResize ( FontView * fv , GEvent * <S2SV_ModStart> -> colcnt ; SavePrefs ( true ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVScrollToChar ( FontView * fv , int i ) <S2SV_ModStart> v , NULL , false ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVScrollToGID ( FontView * fv , int gid <S2SV_ModStart> . map -> backmap [ gid ] ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVScroll ( GGadget * g , GEvent * <S2SV_ModStart> cbh ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVSelCount ( FontView * fv ) { int <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FVSelectByName ( FontView * fv , char * <S2SV_ModStart> sel_index = 1 ; return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSelectByScript ( FontView * fv , int merge <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSelectColor ( FontView * fv , uint32 col <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSetColor ( FontView * fv , uint32 col <S2SV_ModStart> fv -> v , NULL , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVSetUIToMatch ( FontView * destfv , FontView * srcfv <S2SV_ModStart> new ) ; BDFFontFree ( old ) ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic void FVShowInfo ( FontView * fv ) ; v <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVShowSubFont ( FontView * fv , SplineFont * <S2SV_ModStart> fv -> v , NULL , true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVSimplify ( FontView * fv , int type <S2SV_ModStart> ( FontViewBase * ) fv , smpl ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVTimer ( FontView * fv , GEvent * <S2SV_ModStart> userdata ) ; func ( fv ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FVTitleUpdate ( FontViewBase * fv ) { FontViewSetTitle ( <S2SV_ModStart> FontViewSetTitle ( ( FontView * ) fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FVWindowMenuBuild ( GWindow gw , struct gmenuitem * <S2SV_ModStart> = ErrorWindowExists ( ) ; break ; } } } GM <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_BiggerGlyphCache ( FontView * fv , int gidcnt <S2SV_ModStart> gidcnt , fv -> b . sf ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ChangeDisplayBitmap ( FontView * fv , BDFFont * <S2SV_ModStart> b . sf -> display_size = 1 ; } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ChangeGID ( FontView * fv , int gid <S2SV_ModStart> . map -> backmap [ gid ] ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_LayerChanged ( FontView * fv ) { extern <S2SV_ModStart> filled -> pixelsize ; BDFFontFree ( old ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ReattachCVs ( SplineFont * old , SplineFont * <S2SV_ModStart> } } GDrawProcessPendingEvents ( NULL ) ; } } } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FV_ShowFilled ( FontView * fv ) { fv <S2SV_ModStart> ; fv -> b . active_bitmap = NULL ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FontIsActive ( SplineFont * sf ) { FontView <S2SV_ModStart> ( true ) ; return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> ntView <S2SV_ModEnd> * FontNew ( void ) { return ( FontView_Create <S2SV_ModStart> ( SplineFontNew ( ) , false ) ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> SplineFont * FontOfFilename ( const char * filename ) <S2SV_ModStart> sf ) ; } return ( NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id FontViewFinishNonStatic ( ) { FontViewFinish ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewFinish ( ) { if ( ! fontview_ready <S2SV_ModStart> ( mblist ) ; mbFreeGetText ( fvpopupmenu ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewInit ( void ) { if ( fontview_ready <S2SV_ModStart> fvpopupmenu ) ; atexit ( & FontViewFinishNonStatic ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewOpenKids ( FontView * fv ) { int <S2SV_ModStart> while ( k < sf -> subfontcnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> FontViewRemove ( FontView * fv ) { if ( <S2SV_ModStart> } FontViewFree ( & fv -> b ) ; } ex <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewSetTitle ( FontView * fv ) { unichar_t <S2SV_ModStart> ( title ) ; free ( ititle ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontViewSetTitles ( SplineFont * sf ) { FontView <S2SV_ModStart> . nextsame ) ) FontViewSetTitle ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int FontViewWinInfo ( FontView * fv , int * <S2SV_ModStart> fv -> rowoff * fv -> colcnt ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontView * FontView_Append ( FontView * fv ) { <S2SV_ModStart> ) fv ; } return ( fv ) ; } Fo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_Close ( FontView * fv ) { if <S2SV_ModStart> gw ) ; else FontViewRemove ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> FontView * FontView_Create ( SplineFont * sf , int <S2SV_ModStart> fv ) ; } return ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_Free ( FontView * fv ) { int <S2SV_ModStart> ) ; # endif free ( fv ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_ReformatAll ( SplineFont * sf ) { BDFFont <S2SV_ModStart> -> gw , NULL , false ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FontView_ReformatOne ( FontView * fv ) { FontView <S2SV_ModStart> GDrawSetCursor ( fv -> v , ct_pointer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int GS_Cancel ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int GS_OK ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> ar <S2SV_ModEnd> * GetPostScriptFontName ( char * dir , int mult <S2SV_ModStart> ( ret ) ; return ( temp ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> unichar_t * AskSetting ( struct macsettingname * temp , <S2SV_ModStart> ) ; return ( sd . ret ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ChangeSetting ( GGadget * list , int index <S2SV_ModStart> list , index , ustr , NULL ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void CheckObsoletePrefs ( void ) { if ( alwaysgenapple <S2SV_ModStart> != 0 ) old_sfnt_flags = old_ttf_flags | old_otf_flags ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int DefaultEncoding ( void ) { const char * <S2SV_ModStart> ( e_iso8859_1 ) ; return ( enc ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void DefaultXUID ( void ) { int r1 , <S2SV_ModStart> ) ; xuid = copy ( buffer ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void FileChooserPrefsChanged ( void * pointless ) { SavePrefs <S2SV_ModStart> * pointless ) { SavePrefs ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> GListAddStr ( GGadget * list , unichar_t * str <S2SV_ModStart> GGadgetSetList ( list , replace , false ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> GListReplaceStr ( GGadget * list , int index , <S2SV_ModStart> GGadgetSetList ( list , replace , false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void GetFileChooserPrefs ( void ) { unichar_t * * <S2SV_ModStart> gfc_bookmarks ) ; gfc_bookmarks = NULL ; } } } # d <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ParseMacMapping ( char * pt , struct macsettingname <S2SV_ModStart> ( end [ 3 ] & 0xff ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ParseNewMacFeature ( FILE * p , char * <S2SV_ModStart> MacFeatListFree ( user_mac_feature_map ) ; user_mac_feature_map = default_mac_feature_map ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_DefaultMapping ( GGadget * g , GEvent * <S2SV_ModStart> ti ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_DelMapping ( GGadget * g , GEvent * <S2SV_ModStart> false ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_EditMapping ( GGadget * g , GEvent * <S2SV_ModStart> flist ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> GTextInfo * Pref_MappingList ( int use_user ) { struct <S2SV_ModStart> buf ) ; } return ( ti ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_MappingSel ( GGadget * g , GEvent * <S2SV_ModStart> flist ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Pref_NewMapping ( GGadget * g , GEvent * <S2SV_ModStart> NULL ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsInit ( void ) { static int done <S2SV_ModStart> ( visible_prefs_list [ i ] . tab_name ) ; } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int PrefsUI_GetPrefs ( char * name , Val * <S2SV_ModStart> ) ; } } return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_LoadPrefs_FromFile ( char * filename ) { FILE <S2SV_ModStart> ; } } fclose ( p ) ; } } vo <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_LoadPrefs ( void ) { char * prefs <S2SV_ModStart> ProcessFileChooserPrefs ( ) ; GDrawEnableCairo ( prefs_usecairo ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_SavePrefs ( int not_if_script ) { char * <S2SV_ModStart> , default_mac_feature_map ) ; fclose ( p ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void PrefsUI_SetDefaults ( void ) { DefaultXUID ( ) <S2SV_ModStart> ( ) ; local_encoding = DefaultEncoding ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int PrefsUI_SetPrefs ( char * name , Val * <S2SV_ModStart> ) ; } } return ( false ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> char * PrefsUI_getFontForgeShareDir ( void ) { return getShareDir <S2SV_ModStart> ( void ) { return getShareDir ( ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_BrowseFile ( GGadget * g , GEvent * <S2SV_ModStart> ret ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_Cancel ( GGadget * g , GEvent * <S2SV_ModStart> = true ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> id <S2SV_ModEnd> Prefs_LoadDefaultPreferences ( void ) { char filename [ PATH_MAX <S2SV_ModStart> , sharedir ) ; PrefsUI_LoadPrefs_FromFile ( filename ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_Ok ( GGadget * g , GEvent * <S2SV_ModStart> ; } } } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> int Prefs_ScriptBrowse ( GGadget * g , GEvent * <S2SV_ModStart> ret ) ; } return ( true ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> atic <S2SV_ModEnd> void ProcessFileChooserPrefs ( void ) { unichar_t * * <S2SV_ModStart> ; } GFileChooserSetPrefsChangedCallback ( NULL , FileChooserPrefsChanged ) ; } st <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> ) ; } } fclose ( file ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> # if defined ( CHECK_MEMORY_USAGE ) static u32 numBytes <S2SV_ModStart> static u32 numBytes = 0 ; numBytes += size * num <S2SV_ModStart> ) ) ; # endif return malloc ( size * num
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) , 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( "can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes" , size , num ) ; android_errorWriteLog ( 0x534e4554 , "27855419" ) ; return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size , 1
<S2SV_ModStart> ( maxFrameNum ) ; ASSERT ( dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( "b/28533562" ) ; android_errorWriteLog ( 0x534e4554 , "28533562" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
<S2SV_ModStart> pStorage -> sps [ pStorage -> activeSpsId ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { pStorage -> picSizeInMbs = <S2SV_ModEnd> pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps <S2SV_ModStart> -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; }
<S2SV_ModStart> DownmixLib_Create ( const effect_uuid_t * uuid , int32_t sessionId __unused , int32_t ioId __unused <S2SV_ModEnd> , effect_handle_t * pHandle ) { int ret ;
<S2SV_ModStart> case EFFECT_CMD_INIT : if ( pReplyData == NULL || replySize == NULL || <S2SV_ModStart> || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize <S2SV_ModStart> ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize <S2SV_ModStart> int32_t ) ) ) || pReplyData == NULL || replySize == NULL || <S2SV_ModStart> case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || <S2SV_ModStart> ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || replySize
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int Downmix_Reset ( downmix_object_t * pDownmixer __unused , bool init __unused <S2SV_ModEnd> ) { return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * cmd = ( effect_param_t * ) pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , "63662938" ) ; return - EINVAL ; }
<S2SV_ModStart> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len <S2SV_ModEnd> ) ; return r ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> + len - ( nlen + 1 ) ; memcpy ( m , name , nlen + 1 <S2SV_ModEnd> ) ; for ( p = path ; p
<S2SV_ModStart> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> static void record_recent_object ( struct object * obj , const char * name <S2SV_ModEnd> , void * data ) { sha1_array_append ( &
<S2SV_ModStart> static void show_object ( struct object * obj , const char * name , void * data ) { <S2SV_ModEnd> add_preferred_base_object ( name ) ; add_object_entry ( obj -> <S2SV_ModStart> 0 ) ; obj -> flags |= OBJECT_ADDED ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void finish_object ( struct object * obj <S2SV_ModEnd> , const char * name , void * cb_data
<S2SV_ModStart> static void show_object ( struct object * obj , const char * name <S2SV_ModEnd> , void * cb_data ) { struct rev_list_info * <S2SV_ModStart> * info = cb_data ; finish_object ( obj , name <S2SV_ModEnd> , cb_data ) ; if ( info -> flags <S2SV_ModStart> ) return ; show_object_with_name ( stdout , obj , name <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> object * obj = & blob -> object ; size_t pathlen ; <S2SV_ModStart> ) return ; obj -> flags |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; show ( obj , path -> buf , cb_data ) ; strbuf_setlen ( path , pathlen ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } obj -> flags |= SEEN ; strbuf_addstr ( base , name ) ; show ( obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if ( base -> len ) strbuf_addch
<S2SV_ModStart> -> flags |= SEEN ; show_object ( obj , <S2SV_ModEnd> name , data ) ; continue ; } if <S2SV_ModStart> ( struct blob * ) obj , show_object , & base <S2SV_ModEnd> , path , data ) ; continue ; }
<S2SV_ModStart> static void show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap *
<S2SV_ModStart> static void show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap * <S2SV_ModStart> hash ) ; if ( bitmap_pos < 0 ) <S2SV_ModEnd> bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_ModStart> bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_ModEnd> bitmap_set ( base , bitmap_pos ) ; } <S2SV_null>
<S2SV_ModStart> static void test_show_object ( struct object * object , const char * name <S2SV_ModEnd> , void * data ) { struct bitmap_test_data *
<S2SV_ModStart> mark_object ( & c -> object , NULL , <S2SV_ModEnd> data ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> static void mark_object ( struct object * obj <S2SV_ModEnd> , const char * name , void * data
<S2SV_ModStart> FILE * out , struct object * obj , const char * name ) { const <S2SV_ModEnd> char * p ; fprintf ( out , "%s<S2SV_blank>" <S2SV_ModStart> ) ; fputc ( '\\n' , out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.46<S2SV_blank>2011/09/16<S2SV_blank>21:23:59<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> FILE_RCSID ( "@(#)$File:<S2SV_blank>cdf.c,v<S2SV_blank>1.49<S2SV_blank>2012/02/20<S2SV_blank>20:04:37<S2SV_blank>christos<S2SV_blank>Exp<S2SV_blank>$" <S2SV_ModEnd> ) <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> uint32_t size ) { if ( ms ) { uint32_t nestsize = ( uint32_t <S2SV_ModEnd> ) ms -> nest_size [ ms -> nest_level ]
<S2SV_ModStart> for ( i = 0 ; i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { if ( ! unicode_type && ( <S2SV_ModStart> 1 ] & 0xc0 ) != 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> szLine [ i ] &= 0xbf ; } else break ; } else <S2SV_ModStart> i ] & 0xe0 ) == 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if ( ( szLine [ i ] <S2SV_ModStart> i ] & 0xf0 ) == 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if ( ( szLine [ i ] <S2SV_ModStart> i ] & 0xf8 ) == 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { i += 1 ; continue ; <S2SV_ModStart> { i += 1 ; continue ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j ] = 0 ; strcpy (
<S2SV_ModStart> = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof ( cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } <S2SV_ModStart> strcpy ( cat_enum . szPath , "." ) ; if ( strlen ( fileName ) >= sizeof ( cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , fileName ) ; } else { if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModEnd> , sep + 1 ) ; sep [ 0 <S2SV_ModStart> strchr ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 <S2SV_ModEnd> , sep + 1 ) ; sep [ 0 <S2SV_ModStart> , "" ) ; if ( sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n" , sep ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szOpt <S2SV_ModEnd> , sep ) ; sep [ 0 ] =
<S2SV_ModStart> . to_url , 1 , no_mime_check ) ) { strncpy ( the_url , evt -> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf ( stderr , "Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url )
<S2SV_ModStart> = GF_FALSE ; char * ext , szName [ 1024 <S2SV_ModEnd> ] , szExt [ 20 ] ; const char <S2SV_ModStart> = ( FFDemux * ) plug -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt )
<S2SV_ModStart> unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> to_read ) ; i = 0 ; while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) <S2SV_ModEnd> ) { i ++ ; } if ( i
<S2SV_ModStart> GF_DataInformationBox * ) s ) -> dref ) { GF_Box * dref ; <S2SV_ModStart> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> s ) -> dref = ( GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; } return GF_OK ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; param2 = * param_tmp ; if ( param2 < 0 || param2 <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32438598" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ) ; param2 = * param_tmp ; if ( param2 < 0 || <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32436341" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ) ; param2 = * param_tmp ; if ( param2 < 0 || <S2SV_ModStart> ) { p -> status = - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32247948" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; }
<S2SV_ModStart> , r -> e_text , r -> server_princ , r -> client_princ ? & r -> client_princ -> name : NULL , r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL , NULL , reply ) ; if
<S2SV_ModStart> ; krb5_keyblock sessionkey ; krb5_kvno kvno ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , rsp , spn , client , cp , tgt_realm ,
<S2SV_ModStart> * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> context , server -> entry . principal ) , tgt_realm <S2SV_ModEnd> ) ; if ( ret ) goto out ;
<S2SV_ModStart> if ( l_header_read == 0 ) { if ( 3 == <S2SV_ModStart> , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count <S2SV_ModEnd> ) { * o_column_idx = ( unsigned int *
<S2SV_ModStart> <S2SV_null> smb_sdrc_t smb2_flush ( smb_request_t * sr ) { <S2SV_ModEnd> uint16_t StructSize ; uint16_t reserved1 ; uint32_t reserved2 ; <S2SV_ModStart> status ) ; return ( SDRC_SUCCESS ) ; } smb_ofile_flush ( sr , sr -> fid_ofile <S2SV_ModEnd> ) ; ( void ) smb_mbc_encodef ( & sr
<S2SV_ModStart> ERRbadfid ) ; return ( SDRC_ERROR ) ; } smb_ofile_flush <S2SV_ModEnd> ( sr , sr -> fid_ofile ) ; } <S2SV_ModStart> { mutex_enter ( & file -> f_mutex ) ; smb_ofile_flush <S2SV_ModEnd> ( sr , file ) ; mutex_exit ( &
<S2SV_ModStart> dt -> af = AF_INET6 ; } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ; Huff_transmit ( & huff , ch , seq , size << 3
<S2SV_ModStart> ch , byte * fin , int * offset , int maxoffset <S2SV_ModStart> node && node -> symbol == INTERNAL_NODE ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
<S2SV_ModStart> ch , byte * fout , int * offset , int maxoffset <S2SV_ModStart> -> loc [ ch ] , NULL , fout , maxoffset
<S2SV_ModStart> * huff , int ch , byte * fout , int maxoffset <S2SV_ModStart> ) { Huff_transmit ( huff , NYT , fout , maxoffset <S2SV_ModStart> -> loc [ ch ] , NULL , fout , maxoffset
<S2SV_ModStart> node , node_t * child , byte * fout , int maxoffset <S2SV_ModStart> send ( node -> parent , node , fout , maxoffset ) ; } if ( child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; } <S2SV_ModEnd> if ( node -> right == child ) {
<S2SV_ModStart> ; qboolean sgn ; int i , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> ; } if ( msg -> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> 7 ) { nbits = bits & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> data , & msg -> bit , msg -> cursize << 3 <S2SV_ModStart> get << ( i + nbits ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }
<S2SV_ModStart> ; oldsize += bits ; if ( msg -> overflowed ) { <S2SV_ModEnd> return ; } if ( bits == 0 || <S2SV_ModStart> if ( msg -> oob ) { if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> int nbits ; nbits = bits & 7 ; if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> data , & msg -> bit , msg -> maxsize << 3 <S2SV_ModStart> ; value = ( value >> 8 ) ; if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; }
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> , sizeof ( filename ) , ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( ) != 2 ) { Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ) { searchpath_t * search ; long len ; qboolean isLocalConfig ; <S2SV_ModStart> ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG <S2SV_ModStart> search ; search = search -> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> int len ; tm = localtime ( & t ) ; if ( tm == NULL ) return g_strdup ( "???"
<S2SV_ModStart> , NICK_REC * nick ) { NICK_REC * list , * newlist <S2SV_ModStart> NULL ) return ; if ( list == nick ) { newlist = nick -> next ; } else { newlist = list ; <S2SV_ModEnd> while ( list -> next != nick ) list <S2SV_ModStart> list -> next = nick -> next ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }
<S2SV_ModStart> , ( SIGNAL_FUNC ) read_settings ) ; signal_remove ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
<S2SV_ModStart> ( "setup<S2SV_blank>changed" , ( SIGNAL_FUNC ) read_settings ) ; signal_add ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;
<S2SV_ModStart> ) ; g_free_not_null ( ircconn -> alternate_nick ) ; g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ;
<S2SV_ModStart> = src -> sasl_mechanism ; rec -> sasl_username = g_strdup ( src -> sasl_username ) ; rec -> sasl_password = g_strdup ( src -> sasl_password ) <S2SV_ModEnd> ; * dest = ( SERVER_CONNECT_REC * ) rec
<S2SV_ModStart> ircnet -> sasl_password ) { conn -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; } else g_warning ( "The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty" ) ; }
<S2SV_ModStart> ) ; if ( tls_cnx == NULL ) { flush_cmd ( ) ;
<S2SV_ModStart> ssize_t readnb ; signed char seen_r = 0 ; <S2SV_ModEnd> if ( scanned > ( size_t ) 0U )
<S2SV_ModStart> ; if ( ! PPEEK_IS ( ')' ) ) { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> PINC ; name_end = name = p ; gnum
<S2SV_ModStart> ci -> pattern_enc != ci -> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else { cpat = ( UChar *
<S2SV_ModStart> r < 0 ) return r ; } } if ( * state != CCS_START )
<S2SV_ModStart> group_head ) { int r , len , group <S2SV_ModEnd> ; Node * qn ; Node * * tp <S2SV_ModStart> ; Node * qn ; Node * * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> == ( enum TokenSyms ) term ) goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;
<S2SV_ModStart> ; case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 ) ; if ( * p <S2SV_ModStart> s ) goto fail ; p ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT ; break ; case OP_EXACT1_IC :
<S2SV_ModStart> UChar * q = p + reg -> dmin ; if ( q >= end ) return 0
<S2SV_ModStart> : if ( * type == CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> pprev : str ) , * low ) ; }
<S2SV_ModStart> case BAG_IF_ELSE : { int cond_len , then_len , else_len , <S2SV_ModStart> 0 ; jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH <S2SV_ModStart> } if ( IS_NOT_NULL ( Else ) ) { else_len = compile_length_tree ( Else , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModEnd> ; r = add_op ( reg , OP_JUMP ) <S2SV_ModStart> COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r = <S2SV_ModEnd> compile_tree ( Else , reg , env ) ;
<S2SV_ModStart> ) return tlen ; len += tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Else ) ) { <S2SV_ModEnd> tlen = compile_length_tree ( Else , reg ) ;
<S2SV_ModStart> , enc ) ; if ( num < 0 || num >= 256
<S2SV_ModStart> , enc ) ; if ( num < 0 || num >= 256
<S2SV_ModStart> , & use_master , NULL ) ; if ( ! code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP <S2SV_ModEnd> ) { * canon_user = userid . user ;
<S2SV_ModStart> = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ctx -> terminated ||
<S2SV_ModStart> = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ctx -> terminated ||
<S2SV_ModStart> minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> ; kgctx . k5_context = NULL ; kgctx . established = 1 ; kgctx .
<S2SV_ModStart> ( ld , result ) ; if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; goto cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ; <S2SV_ModEnd> cleanup : ldap_msgfree ( result ) ; if (
<S2SV_ModStart> ) { ( * respond ) ( arg , EINVAL <S2SV_ModEnd> , NULL , NULL , NULL ) ; return <S2SV_ModStart> ) { ( * respond ) ( arg , EINVAL <S2SV_ModEnd> , NULL , NULL , NULL ) ; return
<S2SV_ModStart> = ENOMEM ; } if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( ! retval && ( component = va_arg
<S2SV_ModStart> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { int len ; char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ; if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { if ( ( len = sys -> read ( fh , & buf [ 0 ] , 9 ) ) < 2 ) return MSPACK_ERR_READ ; for ( i = 0 ; i < len ; i ++ ) if ( ! ( * fn ++ = buf [ i ] ) ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( i + 1 - len ) , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; fn -- ; } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; if ( ( len = sys -> read ( fh , & buf [ 0 ] , 4 ) ) < 2 ) return MSPACK_ERR_READ ; for ( i = 0 ; i < len ; i ++ ) if ( ! ( * fn ++ = buf [ i ] ) ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT <S2SV_ModEnd> ; if ( sys -> seek ( fh , <S2SV_ModStart> ; if ( sys -> seek ( fh , ( off_t ) ( i + 1 - len ) , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModEnd> ; } * fn = '\\0' ; } if
<S2SV_ModStart> case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ; if ( bits_left == 0 ) ENSURE_BITS ( 16 ) <S2SV_ModEnd> ; bits_left = 0 ; bit_buffer = 0 ;
<S2SV_ModStart> chm -> index_root != 0xFFFFFFFF && chm -> index_root >= <S2SV_ModEnd> chm -> num_chunks ) { D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" <S2SV_ModStart> ( end - p ) ) goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;
<S2SV_ModStart> ; unsigned char * buf ; if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks ) return NULL ; if (
<S2SV_ModStart> ( end - p ) ) goto chunk_end ; <S2SV_ModEnd> name = p ; p += name_len ; READ_ENCINT <S2SV_ModStart> READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
<S2SV_ModStart> st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; assert ( 0 == unlink ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( "Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here." ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ;
<S2SV_ModStart> ; switch ( type ) { case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> return ( - 1 ) ; break ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> return ( - 1 ) ; break ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL ) return ( - 1 ) ; <S2SV_ModStart> - 1 ) ; allAreDefined = * p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
<S2SV_ModStart> -> compsize -= extdsize - 2 ; if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> ARCHIVE_ERRNO_FILE_FORMAT , "Missing<S2SV_blank>number" ) ; return ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Too<S2SV_blank>many<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> unsigned long ) mtree_atol ( & p ) ; <S2SV_ModEnd> } if ( argc < 2 ) { archive_set_error
<S2SV_ModStart> zip -> stream ) ; # endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {
<S2SV_ModStart> ( rsrc -> compression ) { case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , ( intmax_t ) rsrc -> compressed_size ) ; return ( ARCHIVE_WARN ) ; } <S2SV_ModStart> ( rsrc -> compression ) { case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;
<S2SV_ModStart> . numUnpackStreams ) return ( - 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
<S2SV_ModStart> = len ; len = get_line_size ( * b + len , * avail - len <S2SV_ModEnd> , nl ) ; if ( len >= 0
<S2SV_ModStart> ( archive_entry_filetype ( entry ) == AE_IFLNK ) { if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , "Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte" ) ; return ( ARCHIVE_FATAL ) ; }
<S2SV_ModStart> probe_packet -> buf [ i ] ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue ; if ( temp_buffer == VOP_START_CODE ) <S2SV_ModStart> VISUAL_OBJECT_START_CODE ) VISO ++ ; else if ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> < 0x120 ) VO ++ ; else if ( temp_buffer >= 0x120 &&
<S2SV_ModStart> ; uint32_t vsize ; uint16_t asize ; uint16_t auxsize ; int ret <S2SV_ModStart> = & nsv -> ahead [ NSV_ST_VIDEO ] ; if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret <S2SV_ModEnd> ; pkt -> stream_index = st [ NSV_ST_VIDEO ] <S2SV_ModStart> bps , channels , samplerate ) ; } } if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret <S2SV_ModEnd> ; pkt -> stream_index = st [ NSV_ST_AUDIO ]
<S2SV_ModStart> line_end - line ) ; line = line_end ; <S2SV_ModEnd> error = add_push_report_pkt ( push , pkt ) ;
<S2SV_ModStart> ( buf , line_end ) ; error = 0 <S2SV_ModEnd> ; switch ( pkt -> type ) { case
<S2SV_ModStart> ; if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) <S2SV_ModEnd> ; if ( cmd & 0x10 ) len =
<S2SV_ModStart> line_end - line ) ; line = line_end ; <S2SV_ModEnd> error = add_push_report_pkt ( push , pkt ) ;
<S2SV_ModStart> ( buf , line_end ) ; error = 0 <S2SV_ModEnd> ; switch ( pkt -> type ) { case
<S2SV_ModStart> size_t off = 0 , len = 0 ; # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ; if ( cmd & 0x04 ) ADD_DELTA ( off , 16UL ) ; if ( cmd & 0x08 ) ADD_DELTA ( off , <S2SV_ModEnd> 24UL ) ; if ( cmd & 0x10 ) <S2SV_ModStart> 24UL ) ; if ( cmd & 0x10 ) ADD_DELTA ( len , 0UL ) ; if ( cmd & 0x20 ) ADD_DELTA ( len , 8UL ) ; if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> ; if ( ! len ) len = 0x10000 <S2SV_ModStart> if ( ! len ) len = 0x10000 ; # undef ADD_DELTA
<S2SV_ModStart> ) ) { git_cert * cert ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> < 0 ) return error ; giterr_clear ( ) <S2SV_ModEnd> ; error = t -> owner -> certificate_check_cb (
<S2SV_ModStart> ) ) { git_cert * cert ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> 0 ) return error ; giterr_clear ( ) ; error = t -> owner -> certificate_check_cb ( cert , is_valid <S2SV_ModEnd> , t -> connection_data . host , t ->
<S2SV_ModStart> { size_t off = 0 , len = 0 , end <S2SV_ModStart> len = 0x10000 ; # undef ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <S2SV_ModEnd> || res_sz < len ) goto fail ; memcpy
<S2SV_ModStart> key -> ptr , alias_len ) ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> ; } if ( field_identifier == SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < 0 ) { __post_internal_error ( & <S2SV_ModStart> ) ; } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) <S2SV_ModEnd> value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error ( & descriptor
<S2SV_ModStart> ; } if ( field_identifier == SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < 0 ) { __post_internal_error ( & <S2SV_ModStart> ) ; } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) <S2SV_ModEnd> value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error ( & descriptor
<S2SV_ModStart> ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_ModEnd> return 0 ; } } else { if (
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> 0 ; if ( ! in ) { return NULL <S2SV_ModEnd> ; } while ( in [ len ] !=
<S2SV_ModStart> ] == '/' ) { strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 <S2SV_ModEnd> ) ; } else { char szPath [ ODBC_FILENAME_MAX
<S2SV_ModStart> { if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> if ( state -> ptr == tmp ) { goto softfail <S2SV_ModEnd> ; } case 'A' : case 'B' : case <S2SV_ModStart> end , tmp , 1 ) ) ) { goto softfail <S2SV_ModEnd> ; } state -> ptr += mb - 1 <S2SV_ModStart> state -> ptr != state -> end ) ; softfail : state -> offset = 0 ;
<S2SV_ModStart> TSRMLS_DC ) { size_t maxlen = 3 * len + 8
<S2SV_ModStart> * datas = ( struct IGDdatas * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
<S2SV_ModStart> NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser . xmlstart = buffer ; parser .
<S2SV_ModStart> NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser . xmlstart = buffer ; parser .
<S2SV_ModStart> case 1 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 2 : context -> curY += <S2SV_ModStart> case 2 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 3 : context -> curY += <S2SV_ModStart> case 3 : context -> curY += 4 ; <S2SV_ModEnd> break ; case 4 : context -> curY += <S2SV_ModStart> : context -> curY += 2 ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> case 1 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 2 : context -> curY += <S2SV_ModStart> case 2 : context -> curY += 8 ; <S2SV_ModEnd> break ; case 3 : context -> curY += <S2SV_ModStart> case 3 : context -> curY += 4 ; <S2SV_ModEnd> break ; case 4 : context -> curY += <S2SV_ModStart> : context -> curY += 2 ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> ( u8 ) act_code ; old_code = act_code ; if ( npix > 0 ) <S2SV_ModStart> ; * ( -- stackp ) = casspecial ; if ( npix >= ( stack_top - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= ( stack_top - stackp ) ; stackp
<S2SV_ModStart> ) { int rc ; u64 base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> , sizeof ( cmsUInt16Number ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } if (
<S2SV_ModStart> ) goto Error ; cmsPipelineFree ( Lut ) ; Lut = NULL ; <S2SV_ModStart> = ColorSpaceOut ; } return Result ; Error : if ( Lut != NULL )
<S2SV_ModStart> ; if ( l >= ( len - o - 4
<S2SV_ModStart> struct mrb_context * old_c = mrb -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> mrb_value value ; fiber_check_cfunc ( mrb , c ) ; status = c -> status ; if ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED ) { mrb_raise ( mrb , <S2SV_ModStart> , E_FIBER_ERROR , "resuming<S2SV_blank>transferred<S2SV_blank>fiber" ) ; } if ( status == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED ) { mrb_raise ( mrb , <S2SV_ModStart> , E_FIBER_ERROR , "double<S2SV_blank>resume<S2SV_blank>(fib)" ) ; } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED ) { mrb_raise ( mrb , <S2SV_ModStart> ( mrb , E_FIBER_ERROR , "resuming<S2SV_blank>dead<S2SV_blank>fiber" ) ; } old_c <S2SV_ModEnd> -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_ModStart> c -> prev : mrb -> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED ) { mrb_value * b , <S2SV_ModStart> ) { mrb_value * b , * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c -> stack + 1 ; e <S2SV_ModStart> ( mrb , a , len ) ; } <S2SV_ModEnd> if ( vmexec ) { c -> vmexec =
<S2SV_ModStart> ( char * out , const char * in , size_t olen <S2SV_ModStart> ) return - 1 ; in += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> ++ ; if ( digit3 != '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> ++ ; if ( digit4 != '=' ) { if ( len == olen ) return len ;
<S2SV_ModStart> ] && s [ 2 ] ) ) { char t <S2SV_ModEnd> = from_hex ( s [ 1 ] ) << <S2SV_ModStart> << 4 | from_hex ( s [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> ) ) outFileName = tqx_value ; } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> goto err ; } # else { int i ; int ubits = BN_num_bits ( u ) ; int vbits = BN_num_bits ( v ) ; int <S2SV_ModEnd> top = p -> top ; BN_ULONG * udp <S2SV_ModStart> ubits -- ; } if ( ubits <= BN_BITS2 ) { if ( udp [ 0 ] == 0 ) goto err ; if ( udp [ 0 ] == 1 ) break ; } <S2SV_ModEnd> if ( ubits < vbits ) { i =
<S2SV_ModStart> sizeof ( trust_data ) ; trust_data . dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ; trust_data . <S2SV_ModStart> ) ; safe_free ( trust_file . pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( "PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( "PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }
<S2SV_ModStart> error_code = GetLastError ( ) ; if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModEnd> return WindowsErrorString ( ) ; switch ( error_code ) <S2SV_ModStart> : return "Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check." ; case CRYPT_E_NO_TRUSTED_SIGNER : return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; case CERT_E_UNTRUSTEDROOT : return "The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted." ; case TRUST_E_NOSIGNATURE : return "Not<S2SV_blank>digitally<S2SV_blank>signed." ; case TRUST_E_EXPLICIT_DISTRUST : return "One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."
<S2SV_ModStart> PyObject * args , PyObject * kw ) { PyUnicodeObject <S2SV_ModEnd> * logical = NULL ; FriBidiParType base = FRIBIDI_TYPE_RTL <S2SV_ModStart> * logical = NULL ; FriBidiParType base = FRIBIDI_TYPE_RTL <S2SV_ModEnd> ; int clean = 0 ; int reordernsm = <S2SV_ModStart> kwargs [ ] = { "logical" , "base_direction" , <S2SV_ModEnd> "clean" , "reordernsm" , NULL } ; if ( <S2SV_ModStart> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , "U|iii" <S2SV_ModEnd> , kwargs , & logical , & base , <S2SV_ModStart> kwargs , & logical , & base , & clean , & reordernsm ) ) { return NULL ; } <S2SV_ModEnd> if ( ! ( base == FRIBIDI_TYPE_RTL || base <S2SV_ModStart> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) { <S2SV_ModStart> PyErr_Format ( PyExc_ValueError , "invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON" , base ) ; } return unicode_log2vis <S2SV_ModEnd> ( logical , base , clean , reordernsm ) <S2SV_ModStart> logical , base , clean , reordernsm ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } } break ; case 'p' : if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> username ) { int res ; PktBuf * buf <S2SV_ModEnd> ; client -> pool = get_pool ( client ->
<S2SV_ModStart> user = client -> auth_user ; if ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> size_required ; uint32_t num_extensions = 0 ; if ( <S2SV_ModEnd> size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" ,
<S2SV_ModStart> ; while ( size_left ) { uint32_t id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> char digest [ 64 ] ; PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 32 ] ; PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 20 ] ; PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> char digest [ 16 ] ; PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; }
<S2SV_ModStart> ) ; if ( read != entry . uncompressed_filesize || read <= 8
<S2SV_ModStart> ) flags , hint_charset , double_encode TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
<S2SV_ModStart> , zend_class_entry * ce ) { long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , "Bad<S2SV_blank>unserialize<S2SV_blank>data" ) ; return - 1 ; } <S2SV_ModStart> , "Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'" , ce -> name ) ; return - 1 <S2SV_ModEnd> ; } return elements ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; } start = cursor ; # line 501 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE yych ; static const unsigned char <S2SV_ModStart> ':' ) goto yy95 ; yy3 : # line 875 "ext/standard/var_unserializer.re" { return 0 ; } # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : yych = * ( YYMARKER = <S2SV_ModStart> yy3 ; yy14 : ++ YYCURSOR ; # line 869 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , <S2SV_ModStart> "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data" ) ; return 0 ; } # line 612 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 717 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , len2 , len3 , <S2SV_ModStart> object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 795 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 704 "ext/standard/var_unserializer.re" { long elements ; <S2SV_ModEnd> if ( ! var_hash ) return 0 ; INIT_PZVAL <S2SV_ModStart> return 0 ; INIT_PZVAL ( * rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 833 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 683 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long elements = parse_iv ( start + <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 648 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 0 ) ; return 1 ; } # line 931 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 615 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 1 ) ; return 1 ; } # line 985 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> } } yy63 : ++ YYCURSOR ; # line 605 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 use_double : <S2SV_ModStart> ) ) ; return 1 ; } # line 1083 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 590 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ; } return 1 ; } # line 1157 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 int digits <S2SV_ModStart> ) ) ; return 1 ; } # line 1211 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 556 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ) ; return 1 ; } # line 1226 "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 549 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> rval ) ; return 1 ; } # line 1236 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 526 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1282 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 505 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1326 "ext/standard/var_unserializer.c" } # line 877 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> output ) == FAILURE ) { return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive" ) ; RETURN_FALSE ; }
<S2SV_ModStart> ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> ) goto yy18 ; yych = * ++ YYCURSOR <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 805 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } # line 837 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 882 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> str ) ; return 1 ; } # line 937 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> len ) ; return 1 ; } # line 990 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1087 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ; } return 1 ; } # line 1162 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1215 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ) ; return 1 ; } # line 1229 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 573 <S2SV_ModStart> rval ) ; return 1 ; } # line 1238 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> rval_ref ) ; return 1 ; } # line 1286 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) ; } return 1 ; } # line 1335 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } # line 886 "ext/standard/var_unserializer.re" return 0 ;
<S2SV_ModStart> index >= intern -> llist -> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException , "Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" , 0 ) ;
<S2SV_ModStart> ) row_buffer -> ptr + data_size + 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> ++ ) { zend_uchar * this_field_len_pos = p ; const <S2SV_ModStart> long len = php_mysqlnd_net_field_length ( & p ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , "Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>" MYSQLND_SZ_T_SPEC "<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }
<S2SV_ModStart> * ) & var2 ) == SUCCESS ) { if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE ; } else { <S2SV_ModEnd> RETURN_FALSE ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . x = Z_LVAL ( lval ) ; } else { rect . x = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . y = Z_LVAL ( lval ) ; } else { rect . y = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . width = Z_LVAL ( lval ) ; } else { rect . width = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . height = Z_LVAL ( lval ) ; } else { rect . height = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> ( zval_affine_elem ) ; break ; case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; affine [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . x = Z_LVAL ( lval ) ; } else { rect . x = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . y = Z_LVAL ( lval ) ; } else { rect . y = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . width = Z_LVAL ( lval ) ; } else { rect . width = Z_LVAL_PP ( tmp ) ; } } <S2SV_ModEnd> else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; rect . height = Z_LVAL ( lval ) ; } else { rect . height = Z_LVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; x = Z_DVAL ( dval ) ; } else { x = Z_DVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING <S2SV_ModStart> * ) & tmp ) != FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; y = Z_DVAL ( dval ) ; } else { y = Z_DVAL_PP ( tmp ) ; } <S2SV_ModEnd> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING
<S2SV_ModStart> ( tmp ) ; break ; case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; m1 [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC , <S2SV_ModStart> ( tmp ) ; break ; case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; m2 [ i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default : php_error_docref ( NULL TSRMLS_CC ,
<S2SV_ModStart> if ( zr_rsrc -> zf ) { buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 ) ; n = zip_fread ( zr_rsrc
<S2SV_ModStart> == NULL ) { RETURN_FALSE ; } buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 ) ; n = zip_fread ( zf
<S2SV_ModStart> get_properties = spl_array_get_properties ; spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
<S2SV_ModStart> = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> } -- p ; count = Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> ) ) { goto outexcept ; } if ( <S2SV_ModEnd> * p == ',' ) { ++ p ; <S2SV_ModStart> & entry ) ; goto outexcept ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash = spl_object_storage_get_hash ( intern , getThis
<S2SV_ModStart> { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
<S2SV_ModStart> ) ; } start = cursor ; # line 496 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE yych ; static const unsigned char <S2SV_ModStart> ':' ) goto yy95 ; yy3 : # line 861 "ext/standard/var_unserializer.re" { return 0 ; } # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : yych = * ( YYMARKER = <S2SV_ModStart> yy3 ; yy14 : ++ YYCURSOR ; # line 855 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , <S2SV_ModStart> "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data" ) ; return 0 ; } # line 607 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 708 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , len2 , len3 , <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 785 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 699 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { if ( ! var_hash ) return 0 <S2SV_ModStart> UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } # line 819 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 678 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long elements = parse_iv ( start + <S2SV_ModStart> return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 643 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 0 ) ; return 1 ; } # line 917 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 610 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * <S2SV_ModStart> 1 ) ; return 1 ; } # line 971 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : yych = * ++ YYCURSOR ; <S2SV_ModStart> } } yy63 : ++ YYCURSOR ; # line 600 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 use_double : <S2SV_ModStart> ) ) ; return 1 ; } # line 1069 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 585 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ; } return 1 ; } # line 1143 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # if SIZEOF_LONG == 4 int digits <S2SV_ModStart> ) ) ; return 1 ; } # line 1197 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 551 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> ) ) ; return 1 ; } # line 1212 "ext/standard/var_unserializer.c" yy87 : ++ YYCURSOR ; # line 544 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * p = YYCURSOR ; INIT_PZVAL ( <S2SV_ModStart> rval ) ; return 1 ; } # line 1222 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 521 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1268 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : yych = * ++ YYCURSOR ; <S2SV_ModStart> ) goto yy18 ; ++ YYCURSOR ; # line 500 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long id ; * p = YYCURSOR <S2SV_ModStart> rval ) ; return 1 ; } # line 1312 "ext/standard/var_unserializer.c" } # line 863 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> "msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
<S2SV_ModStart> , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> int namelen ; int has_value ; php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> < endptr ; ) { zval * * tmp ; skip = 0 <S2SV_ModStart> * tmp == PS ( http_session_vars ) ) { skip = 1 <S2SV_ModEnd> ; } } if ( has_value ) { ALLOC_INIT_ZVAL <S2SV_ModStart> ) endptr , & var_hash TSRMLS_CC ) ) { if ( ! skip ) { <S2SV_ModStart> namelen , current , & var_hash TSRMLS_CC ) ; } <S2SV_ModStart> ( & var_hash , & current ) ; } if ( ! skip ) { PS_ADD_VARL ( name , namelen ) ; } <S2SV_ModEnd> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash
<S2SV_ModStart> int namelen ; int has_value ; php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> { zval * * tmp ; q = p ; skip = 0 <S2SV_ModStart> * tmp == PS ( http_session_vars ) ) { skip = 1 <S2SV_ModEnd> ; } } if ( has_value ) { ALLOC_INIT_ZVAL <S2SV_ModStart> ) endptr , & var_hash TSRMLS_CC ) ) { if ( ! skip ) { <S2SV_ModStart> namelen , current , & var_hash TSRMLS_CC ) ; } <S2SV_ModStart> ( & var_hash , & current ) ; } if ( ! skip ) { PS_ADD_VARL ( name , namelen ) ; } <S2SV_ModEnd> skip : efree ( name ) ; p =
<S2SV_ModStart> , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> * options = NULL , * classes = NULL ; zval * retval <S2SV_ModStart> ) ; } ZEND_HASH_FOREACH_END ( ) ; } } retval = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p , p + buf_len , & <S2SV_ModStart> class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_ModEnd> if ( ! EG ( exception ) ) { <S2SV_ModStart> ) , buf_len ) ; } RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if (
<S2SV_ModStart> else { convert_to_string ( key ) ; if ( zend_hash_find <S2SV_ModEnd> ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P
<S2SV_ModStart> char * host = NULL ; # ifdef HAVE_IPV6 <S2SV_ModEnd> if ( * ( str ) == '[' && <S2SV_ModStart> ) == '[' && str_len > 1 ) { char * <S2SV_ModStart> + 1 , ']' , str_len - 2 ) , * e = NULL <S2SV_ModStart> ; } return NULL ; } * portno = strtol ( p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup ( str + 1 , p - <S2SV_ModStart> = NULL ; } if ( colon ) { char * e = NULL ; * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( str , colon - str ) ; <S2SV_ModStart> ( str , colon - str ) ; } } <S2SV_ModEnd> if ( get_err ) { * err = strpprintf <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , s + buf_len , & var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept ; } var_push_dtor ( & var_hash ,
<S2SV_ModStart> , 0 TSRMLS_CC ) ; if ( ! offset || ! ht
<S2SV_ModStart> ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers ( request_rec * r ) { oidc_cfg
<S2SV_ModStart> ( r , "invalid_token" , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user" ) ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> , "Invalid<S2SV_blank>Request" , apr_psprintf ( r -> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" <S2SV_ModEnd> ) , HTTP_INTERNAL_SERVER_ERROR ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * npairs = 0 ; return NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ) , errmsg ( "empty<S2SV_blank>query" ) ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
<S2SV_ModStart> ITEM * ptr , int32 * pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> -> size = 0 ; return query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> cntsize ( in , & sumlen , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) )
<S2SV_ModStart> [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS <S2SV_ModEnd> ] ; char * realptr ; char * * <S2SV_ModStart> = 0 ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ;
<S2SV_ModStart> NULL ) { # ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ; * fsec = strtol ( fstr
<S2SV_ModStart> '.' ) { # ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ; * fsec = strtol ( fstr
<S2SV_ModStart> '\\0' ) { field [ nf ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart> * lp ++ = '\\0' ; nf ++ ; <S2SV_ModEnd> } * numfields = nf ; return 0 ;
<S2SV_ModStart> = 0 ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ;
<S2SV_ModStart> & realptr ; if ( strlen ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult
<S2SV_ModStart> path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_ModEnd> size_t pathlen ; path = dir ; if ( <S2SV_ModStart> [ pathlen - 1 ] = '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if ( res < 0 ) { <S2SV_ModStart> ) ; if ( res < 0 ) { if ( errno == EPERM ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM ; return - 1 ; }
<S2SV_ModStart> path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_ModEnd> size_t pathlen ; path = pstrdup ( p , <S2SV_ModStart> [ pathlen - 1 ] = '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if ( res < 0 ) { <S2SV_ModStart> ) ; if ( res < 0 ) { if ( errno == EPERM ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM ; return - 1 ; }
<S2SV_ModStart> ; s -> vex_v = 0 ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> live = true ; } -- parameters_size ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> , to ) ; return - 1 ; } int len = to - from ; ut8 * buf = calloc ( len <S2SV_ModEnd> , 1 ) ; if ( ! buf || <S2SV_ModStart> ( bf -> buf , from , buf , len <S2SV_ModEnd> ) ; while ( needle < to ) { <S2SV_ModStart> if ( ( to - needle ) > 5 + rc ) { bool is_wide32 = ( needle + rc + 2 < to ) && ( <S2SV_ModEnd> ! w [ 0 ] && ! w [ <S2SV_ModStart> [ 3 ] && ! w [ 4 ] )
<S2SV_ModStart> struct r_bin_mdmp_obj * obj ) { int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( obj -> kv , "mdmp_directory.offset" , <S2SV_ModStart> "mdmp_directory.format" , "[4]E?<S2SV_blank>" "(mdmp_stream_type)StreamType<S2SV_blank>" "(mdmp_location_descriptor)Location" , 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> -> hdr -> number_of_streams ; i ++ ) { ut32 delta = i * sizeof ( struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory ) ) ; if ( r ) { r_bin_mdmp_init_directory_entry ( obj , & entry ) ; } <S2SV_ModEnd> } return true ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( input [ 0 ] == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr ( input , '<S2SV_blank>' ) ; <S2SV_ModStart> fs , ptr , input , off ) ) { eprintf ( "Cannot<S2SV_blank>mount<S2SV_blank>%s\\n" , input ) ; } } <S2SV_ModEnd> else { if ( ! ( ptr = r_fs_name <S2SV_ModStart> -> fs , core -> offset ) ) ) { eprintf ( "Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n" ) ; } <S2SV_ModEnd> else if ( ! r_fs_mount ( core -> fs <S2SV_ModStart> ptr , input , core -> offset ) ) { eprintf ( "Cannot<S2SV_blank>mount<S2SV_blank>%s\\n" , input ) ; } <S2SV_ModEnd> free ( ptr ) ; } break ; case
<S2SV_ModStart> ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext <S2SV_ModStart> ) { grub_error ( GRUB_ERR_BAD_FS , "invalid<S2SV_blank>extent" ) ; free ( buf ) ; <S2SV_ModStart> ( ext [ i ] . len ) ) { free ( buf ) ; return 0 ; } <S2SV_ModEnd> else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( <S2SV_ModStart> ( ext [ i ] . start ) ; free ( buf ) ; <S2SV_ModStart> } } else { grub_error ( GRUB_ERR_BAD_FS , "something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent" ) ; free ( buf ) ; return - 1 ; } free ( buf ) ; <S2SV_ModEnd> } if ( fileblock < INDIRECT_BLOCKS ) { blknr <S2SV_ModStart> ( blksz ) ; if ( ! indir ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS <S2SV_ModStart> ( blksz ) ; if ( ! indir ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> if ( grub_disk_read ( data -> disk , ( <S2SV_ModStart> log2_blksz , 0 , blksz , indir ) ) { return grub_errno ; } <S2SV_ModEnd> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock
<S2SV_ModStart> , EXT2_BLOCK_SIZE ( data ) , buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = ( struct grub_ext4_extent_header * ) buf ;
<S2SV_ModStart> * currfound , struct grub_fshelp_find_file_closure * c ) { char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; <S2SV_ModEnd> while ( * name == '/' ) name ++ <S2SV_ModStart> ! * name ) { * currfound = currnode ; free ( fpath ) <S2SV_ModStart> ) { free_node ( currnode , c ) ; free ( fpath ) ; <S2SV_ModStart> ( ! found ) { if ( grub_errno ) { free ( fpath ) ; return grub_errno ; } <S2SV_ModEnd> break ; } if ( type == GRUB_FSHELP_SYMLINK ) <S2SV_ModStart> ) ; free_node ( oldnode , c ) ; free ( fpath ) ; <S2SV_ModStart> ! symlink ) { free_node ( oldnode , c ) ; free ( fpath <S2SV_ModStart> ) { free_node ( oldnode , c ) ; free ( fpath ) ; <S2SV_ModStart> = currnode ; c -> foundtype = type ; free ( fpath ) ; <S2SV_ModStart> return 0 ; } name = next ; } free ( fpath ) ;
<S2SV_ModStart> } RBuffer * tbuf = r_buf_new ( ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> = calloc ( 1 , n_got * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ; if ( got_table ) { ut32
<S2SV_ModStart> send_msg ( g , "E01" ) ; } } return - 1 ;
<S2SV_ModStart> if ( dirent . namelen != 0 ) { char * filename = grub_malloc ( dirent . namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * fdiro ; enum grub_fshelp_filetype type = <S2SV_ModStart> * fdiro ; enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> namelen , filename ) ; if ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) <S2SV_ModStart> grub_fshelp_node ) ) ; if ( ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data = diro -> data ; fdiro <S2SV_ModStart> -> inode ) ; if ( grub_errno ) { free ( filename ) ; <S2SV_ModStart> filename , type , fdiro , closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos += grub_le_to_cpu16 ( dirent . direntlen
<S2SV_ModStart> ; } } if ( fileblock < INDIRECT_BLOCKS ) { <S2SV_ModStart> -> blocks . dir_blocks [ fileblock ] ) ; }
<S2SV_ModStart> > filesize ) len = filesize - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> , addrsize ) ; if ( ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil , core -> anal , romem
<S2SV_ModStart> printline ( "bytes" , NULL , 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; for ( j = 0 ; j < minsz ; j ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : buf [ j + idx ] ; r_cons_printf ( "%02x" , ch <S2SV_ModEnd> ) ; } r_cons_newline ( ) ; if ( <S2SV_ModStart> ; if ( op . val != UT64_MAX ) { <S2SV_ModStart> "0x%08" PFMT64x "\\n" , op . val ) ; } if ( op . ptr != UT64_MAX ) { <S2SV_ModEnd> printline ( "ptr" , "0x%08" PFMT64x "\\n" , op <S2SV_ModStart> "0x%08" PFMT64x "\\n" , op . ptr ) ; } <S2SV_ModStart> if ( op . refptr != - 1 ) { <S2SV_ModStart> "refptr" , "%d\\n" , op . refptr ) ; }
<S2SV_ModStart> ; bool keep = true ; if ( argReg > regsz ) { return ; <S2SV_ModEnd> } p4 = r_uleb128 ( p4 , p4_end -
<S2SV_ModStart> ; op -> type = R_ANAL_OP_TYPE_CJMP ; if ( len > 1 ) { if ( data [ 1 ] <= 127 ) { <S2SV_ModEnd> op -> jump = addr + data [ 1 <S2SV_ModStart> data [ 1 ] + op -> size ; } else { <S2SV_ModEnd> op -> jump = addr - ( 256 - <S2SV_ModStart> [ 1 ] ) + op -> size ; } } else { op -> jump = addr ; }
<S2SV_ModStart> if ( data ) { if ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> data + pos + real_offset , len ) ; }
<S2SV_ModStart> buf [ i ] != eoc ) { i ++ <S2SV_ModEnd> ; } if ( buf [ i ] !=
<S2SV_ModStart> = NULL ; RBinWasmDataEntry * ptr = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count = sec -> count ; ut32 <S2SV_ModStart> n = 0 ; while ( i < len && len < buflen <S2SV_ModStart> -> index , & i ) ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if ( ! ( n = consume_init_expr <S2SV_ModStart> , NULL , & i ) ) ) { goto beach <S2SV_ModEnd> ; } ptr -> offset . len = n <S2SV_ModStart> -> size , & i ) ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr -> data = sec -> payload_data <S2SV_ModStart> ; r += 1 ; } return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> r = 0 ; while ( i < len && len < buflen <S2SV_ModStart> -> index , & i ) ) ) { goto beach <S2SV_ModEnd> ; } if ( ! ( consume_init_expr ( buf <S2SV_ModStart> , NULL , & i ) ) ) { goto beach <S2SV_ModEnd> ; } if ( ! ( consume_u32 ( buf <S2SV_ModStart> -> num_elem , & i ) ) ) { goto beach <S2SV_ModEnd> ; } ut32 j = 0 ; while ( <S2SV_ModStart> ; r += 1 ; } return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> = NULL ; RBinWasmGlobalEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; int buflen = bin -> buf -> length - <S2SV_ModEnd> ( ut32 ) sec -> payload_data ; ut32 len
<S2SV_ModStart> ] . class_id > bin -> header . types_size <S2SV_ModEnd> ) { continue ; } if ( is_class_idx_in_code_classes (
<S2SV_ModStart> ) { int va = info -> has_va ; char * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits = info -> bits ; ut64 <S2SV_ModStart> config , "anal.arch" , arch ) ; if ( cpu && * <S2SV_ModEnd> cpu ) { r_config_set ( r -> config , <S2SV_ModStart> { r_config_set ( r -> config , "anal.cpu" , <S2SV_ModEnd> cpu ) ; } else { r_config_set ( r <S2SV_ModStart> , NULL ) ; r_core_bin_set_cur ( r , binfile ) ; free ( cpu ) ; free ( arch
<S2SV_ModStart> ) { case '<S2SV_blank>' : case '=' : case \'"\' : case '\\\\' : case
<S2SV_ModStart> = a ; while ( * arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case '@' : case '`' : case <S2SV_ModStart> '`' : case '|' : case ';' : case '=' : case <S2SV_ModStart> : break ; default : * b ++ = ch <S2SV_ModEnd> ; break ; } arg ++ ; } *
<S2SV_ModStart> r -> bin -> prefix ) { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\"\\n" <S2SV_ModEnd> , module , symbol -> ordinal , r -> <S2SV_ModStart> , symname ) ; } else { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s\\"\\n" <S2SV_ModEnd> , module , symbol -> ordinal , symname )
<S2SV_ModStart> RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 <S2SV_ModEnd> * length ) { int tag , len ;
<S2SV_ModStart> revcode ; collen = 0 ; } while ( indexw < width && <S2SV_ModStart> indexw ++ ; collen -- ; } while ( indexw < width && <S2SV_ModStart> revcode ; collen = 0 ; } while ( indexw < width && <S2SV_ModStart> indexw ++ ; collen -- ; } while ( indexw < width &&
<S2SV_ModStart> uint32 length , format ; uint8 * data ; struct stream packet = * s ; <S2SV_ModStart> type , status , length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } if (
<S2SV_ModStart> <S2SV_null> static RD_BOOL mcs_parse_domain_params ( STREAM s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length <S2SV_ModStart> ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> { UNUSED ( mcs_data ) ; uint8 result ; uint32 length ; STREAM s ; struct stream packet <S2SV_ModEnd> ; RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( <S2SV_ModStart> ; if ( s == NULL ) return False ; packet = * s <S2SV_ModStart> ) ; in_uint8s ( s , length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> uint16 flags ; uint8 type ; uint8 * next_order ; struct stream packet = * s <S2SV_ModStart> ) ; in_uint8 ( s , type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( "process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream" , & packet ) ; }
<S2SV_ModStart> , var , iface ) >= sizeof ( spath ) ) return - 1 ; if ( strstr ( name , ".." ) || strchr ( name , '/'
<S2SV_ModStart> ) ; id_auth_tag_len = rb_intern_const ( "auth_tag_len" ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> { ossl_raise ( eCipherError , NULL ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> ; const EVP_CIPHER * cipher ; char * name <S2SV_ModEnd> ; name = StringValueCStr ( str ) ; GetCipherInit <S2SV_ModStart> ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL <S2SV_ModEnd> , NULL , - 1 ) != 1 )
<S2SV_ModStart> ; OPENSSL_cleanse ( iv , sizeof iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> 1 ) ossl_raise ( eCipherError , NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> "11" , & data , & str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> return FALSE ; Stream_Read_UINT32 ( s , scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
<S2SV_ModStart> key , char * * where TSRMLS_DC ) { int o_name_len = name_len ; char * buf , * buf2 <S2SV_ModEnd> , * d , * d_url ; int l <S2SV_ModStart> * d , * d_url ; int l ; <S2SV_ModEnd> buf = estrndup ( name , name_len ) ; <S2SV_ModStart> buf = estrndup ( name , name_len ) ; <S2SV_ModEnd> name_len = php_url_decode ( buf , name_len ) ; <S2SV_ModStart> , name_len + 1 ) ) { decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( * where , name , o_name_len ) <S2SV_ModStart> 1 ) ) { goto decrypt_return_plain ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode ( buf2 , value_len ) ; <S2SV_ModStart> l ; efree ( d_url ) ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return * where ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> value_len , char * key TSRMLS_DC ) { char * buf , * buf2 <S2SV_ModEnd> , * d , * d_url ; int l <S2SV_ModStart> * d , * d_url ; int l ; <S2SV_ModEnd> buf = estrndup ( name , name_len ) ; <S2SV_ModStart> buf = estrndup ( name , name_len ) ; <S2SV_ModEnd> name_len = php_url_decode ( buf , name_len ) ; <S2SV_ModStart> , name_len + 1 ) ) { encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup ( value , value_len ) ; } <S2SV_ModStart> 1 ) ) { goto encrypt_return_plain ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode ( buf2 , value_len ) ; <S2SV_ModStart> & l ) ; efree ( d ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( __force __le16 ) msg_tmp . controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; if ( peekonly ) { <S2SV_ModEnd> goto peekout ; } if ( ( msg_tmp . <S2SV_ModStart> space_rem < sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } <S2SV_ModEnd> saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ;
<S2SV_ModStart> ; CALL_AND_WAIT ( error = bt_interface -> enable ( false
<S2SV_ModStart> ) ; int err ; do { err = TEMP_FAILURE_RETRY ( nanosleep ( & delay , & delay ) <S2SV_ModEnd> ) ; } while ( err == - 1
<S2SV_ModStart> . events = POLLIN | POLLHUP ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) <S2SV_ModStart> ( ) ; return 0 ; } n = TEMP_FAILURE_RETRY ( <S2SV_ModStart> + n_read , len - n_read , 0 ) )
<S2SV_ModStart> msglen ) ; UIPC_LOCK ( ) ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> [ ch_id ] . fd , p_buf , msglen )
<S2SV_ModStart> r < 0 ) return r ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> , false , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ) return - errno ; if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r = fchmod ( fd , mode
<S2SV_ModStart> 1 ; case HTML_DD : CLOSE_A ; CLOSE_DT ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; }
<S2SV_ModStart> ; int i , attr_id = 0 , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> ptr ; int newlen ; newlen = x -> area_size <S2SV_ModEnd> * 6 / 5 ; if ( newlen == <S2SV_ModStart> / 5 ; if ( newlen == x -> area_size <S2SV_ModEnd> ) newlen += 2 ; x -> ptr =
<S2SV_ModStart> Mat_VarFree ( matvar ) ; return NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> total_subobj_len > 0 && hexdump == FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> . f * 8 / 1000000 ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
<S2SV_ModStart> ; } msgptr ; int msg_len_valid = 0 ; if ( is_ipv6 ) { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 = ( const struct olsr_msg6 * <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ; } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> } break ; case OLSR_NAMESERVICE_MSG : { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; addr_size = 4 ; if ( is_ipv6 ) addr_size = 16 ; name_entries_valid = 0 <S2SV_ModEnd> ; if ( ( name_entries > 0 ) && <S2SV_ModStart> ) ) <= msg_tlen ) ) name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s" , EXTRACT_16BITS
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; return hdrlen ; } if ( caplen
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; else isoclns_print ( ndo , p , <S2SV_ModStart> ; else isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; break ; default : if ( !
<S2SV_ModStart> ndo , p + 1 , length - 1 <S2SV_ModEnd> ) ; return ( 1 ) ; case ETHERTYPE_PPPOED
<S2SV_ModStart> ) { isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; return ( hdrlen ) ; } if
<S2SV_ModStart> PT_OSI : isoclns_print ( ndo , p , length <S2SV_ModEnd> ) ; break ; default : break ; }
<S2SV_ModStart> ndo , "[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid ; switch ( subobj_type ) {
<S2SV_ModStart> const struct ip6_hdr * ) bp2 ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if ( ndo -> ndo_vflag ) {
<S2SV_ModStart> * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t nitems ; tptr = pptr ; <S2SV_ModStart> * ) pptr ; ND_TCHECK ( * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> = ( const struct vqp_obj_tlv_t * ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> } ND_TCHECK2 ( * tptr , vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; switch ( vqp_obj_type ) { case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%s<S2SV_blank>(0x%08x)" , ipaddr_string ( <S2SV_ModStart> ; break ; case VQP_OBJ_MAC_ADDRESS : case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
<S2SV_ModStart> = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , <S2SV_ModStart> ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
<S2SV_ModStart> if ( in_cksum ( vec , 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> & bp [ 6 ] ) ) ) ; }
<S2SV_ModStart> ) ( io + nid ) ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp , len ) ) { ND_PRINT
<S2SV_ModStart> ) ; while ( -- n >= 0 && <S2SV_ModEnd> ND_TTEST ( * ps ) ) { const struct <S2SV_ModStart> + ps -> nid ; io < ie && <S2SV_ModEnd> ND_TTEST ( * io ) ; ++ io )
<S2SV_ModStart> ; if ( ! ( opt_len == 12 && ( flags & TH_SYN ) <S2SV_ModEnd> ) && ! ( opt_len == 20 && (
<S2SV_ModStart> const struct mp_dss * ) opt ; if ( opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> flags & TH_SYN ) return 0 ; if ( <S2SV_ModStart> , "<S2SV_blank>fin" ) ) ; opt += 4 ; opt_len -= 4 ; <S2SV_ModStart> if ( mdss -> flags & MP_DSS_a ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 8 ; opt_len -= 8 ; } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; <S2SV_ModStart> if ( mdss -> flags & MP_DSS_m ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 8 ; opt_len -= 8 ; } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "<S2SV_blank>subseq<S2SV_blank>%u" , EXTRACT_32BITS ( <S2SV_ModStart> opt ) ) ) ; opt += 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt ) ) ) ; opt += 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>csum<S2SV_blank>0x%x" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! ( opt_len == 12 && ( flags & TH_SYN ) <S2SV_ModEnd> ) && ! ( opt_len == 16 && ( <S2SV_ModStart> ) ) && ! ( opt_len == 24 && ( flags & TH_ACK ) <S2SV_ModEnd> ) ) return 0 ; if ( opt_len !=
<S2SV_ModStart> , "(altcoa:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> , "%s" , tstr ) ) ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; switch ( otype ) { case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ( ndo , EXTRACT_16BITS ( bp ) ) ; } <S2SV_ModStart> ; break ; } break ; case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> "0x%08x" , EXTRACT_32BITS ( bp ) ) ) ; } break ; case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModEnd> ND_PRINT ( ( ndo , "v%d" , * bp <S2SV_ModStart> EXTRACT_16BITS ( bp + 2 ) ) ) ; }
<S2SV_ModStart> , "(ni:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) ) ; p += 2 ; caplen
<S2SV_ModStart> ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; type = * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModEnd> ) ; len = EXTRACT_16BITS ( tptr + 2 <S2SV_ModStart> ) ; if ( type <= 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , "\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( eap_type_values , "unknown" , subtype ) , subtype <S2SV_ModEnd> ) ) ; switch ( subtype ) { case <S2SV_ModStart> 5 ; while ( count < len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> count ++ ; } break ; case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ( tptr + 5 ) ) ) ) ; <S2SV_ModEnd> ND_PRINT ( ( ndo , "<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x," , bittok2str ( <S2SV_ModStart> * ( tptr + 5 ) ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ) ) ; } break ; case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> * ( tptr + 5 ) ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
<S2SV_ModStart> ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; <S2SV_ModEnd> if ( caplen < 3 ) { ND_PRINT ( <S2SV_ModStart> < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ; seq = EXTRACT_LE_8BITS ( p + 2 <S2SV_ModStart> ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<<S2SV_blank>" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS ( p ) ; p += <S2SV_ModStart> EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! <S2SV_ModEnd> ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen <S2SV_ModStart> ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> h , register const u_char * p ) { return chdlc_print ( ndo , p , h -> len <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ;
<S2SV_ModStart> "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p <S2SV_ModEnd> ) ) ) ; p += 8 ; caplen
<S2SV_ModStart> 4 ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; return 0 ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; break ; case LDP_TLV_FT_SESSION : TLV_TCHECK ( 12 <S2SV_ModEnd> ) ; ft_flags = EXTRACT_16BITS ( tptr ) ; <S2SV_ModStart> ) ; trunc : ND_PRINT ( ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ; return 0 ; badtlv : ND_PRINT
<S2SV_ModStart> = ( const struct vtp_vlan_ * ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ( & vtp_vlan -> index ) ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr <S2SV_ModEnd> , vtp_vlan -> name_len , NULL ) ; len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= <S2SV_ModEnd> 4 * ( ( vtp_vlan -> name_len + 3 <S2SV_ModStart> + 3 ) / 4 ) ; tptr += <S2SV_ModEnd> 4 * ( ( vtp_vlan -> name_len + 3 <S2SV_ModStart> ) ; while ( len > 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> type ) , type ) ) ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; <S2SV_ModEnd> return ; } ND_TCHECK2 ( * tptr , tlv_len <S2SV_ModStart> tptr , tlv_len * 2 + 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> + tlv_len * 2 ) ; break ; } }
<S2SV_ModStart> , "(refresh:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
<S2SV_ModStart> tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> tptr < ( pptr + length ) ) { ND_TCHECK_8BITS ( tptr ) ;
<S2SV_ModStart> u_int length ) { const struct aodv_hello * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> sizeof ( struct aodv_hello ) ) goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u" , ep -> length ) ) ; break ; }
<S2SV_ModStart> if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS ( & prep -> pp_n )
<S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> 1 ) , len ) >= 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) )
<S2SV_ModStart> , lmp_obj_len , lmp_obj_ctype , obj_tlen ; int hexdump , ret <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 <S2SV_ModStart> , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 <S2SV_ModStart> , obj_tptr , obj_tlen - 36 , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 <S2SV_ModStart> , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
<S2SV_ModStart> obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ;
<S2SV_ModStart> , & ip6 -> ip6_dst ) ) ) ; <S2SV_ModEnd> } else { ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]" <S2SV_ModStart> , & ip -> ip_dst ) ) ) ; } return ; <S2SV_ModEnd> } sport = EXTRACT_16BITS ( & pgm -> pgm_sport <S2SV_ModStart> ( 2 * sizeof ( uint16_t ) ) ; ND_TCHECK_16BITS ( bp ) ;
<S2SV_ModStart> IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , <S2SV_ModStart> IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , <S2SV_ModStart> 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x" , <S2SV_ModStart> ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if ( bp [ hlen ] & <S2SV_ModStart> if ( bp [ hlen ] & 0xf0 ) { <S2SV_ModStart> ND_PRINT ( ( ndo , "K" ) ) ; } hlen += 1 ; hlen += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , <S2SV_ModStart> mh -> ip6m_data8 [ 0 ] ) ) ; ND_TCHECK ( mh -> ip6m_data8 [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModEnd> & 0x80 ) ND_PRINT ( ( ndo , "<S2SV_blank>K" <S2SV_ModStart> , "<S2SV_blank>K" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , <S2SV_ModStart> ] ) ) ) ; hlen += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , <S2SV_ModStart> ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>homeaddr<S2SV_blank>%s"
<S2SV_ModStart> dat ; register const struct netinfo6 * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch ( rp -> rip6_cmd ) { <S2SV_ModStart> ( rp -> rip6_cmd ) { case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( * ni ) ; if ( <S2SV_ModStart> * ni ) ; if ( j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED <S2SV_ModStart> ndo , "<S2SV_blank>ripng-req<S2SV_blank>dump" ) ) ; break ; } } <S2SV_ModStart> ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:" , j , length <S2SV_ModEnd> ) ) ; else ND_PRINT ( ( ndo , <S2SV_ModStart> ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u:" , j ) <S2SV_ModEnd> ) ; for ( ni = rp -> rip6_nets <S2SV_ModStart> ; for ( ni = rp -> rip6_nets ; length_left >= sizeof ( * ni ) ; length_left <S2SV_ModEnd> -= sizeof ( * ni ) , ++ ni <S2SV_ModStart> ( * ni ) , ++ ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ( ndo , ni , 0 ) ; } if ( length_left != 0 ) goto trunc ; break ; case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( * ni ) ; if ( <S2SV_ModStart> ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:" , j , length <S2SV_ModEnd> ) ) ; else ND_PRINT ( ( ndo , <S2SV_ModStart> ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d:" , j ) ) ; for ( ni = rp -> rip6_nets ; length_left >= sizeof ( * ni ) ; length_left <S2SV_ModEnd> -= sizeof ( * ni ) , ++ ni <S2SV_ModStart> ( * ni ) , ++ ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> , ni -> rip6_metric ) ; } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; default : ND_PRINT ( ( ndo <S2SV_ModStart> rip6_cmd , length ) ) ; break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> , "<S2SV_blank>[vers<S2SV_blank>%d]" , rp -> rip6_vers ) ) ; return ; trunc : ND_PRINT ( ( ndo , "[|ripng]" ) ) ; return ;
<S2SV_ModStart> ; } if ( rh . command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> ; uint16_t port = 0 ; or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> ; if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) { or_circ = TO_OR_CIRCUIT ( circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModEnd> relay_header_unpack ( & rh , cell -> payload ) <S2SV_ModStart> ( rh . stream_id , circ , end_reason , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( ! <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( or_circ <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; return 0 ; } if ( ! <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; return 0 ; } } log_debug ( <S2SV_ModStart> if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; log_info ( LD_REND , "begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream." ) ; <S2SV_ModStart> ( rh . stream_id , circ , END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ; connection_free ( TO_CONN ( n_stream ) )
<S2SV_ModStart> -> bios + data_offset ) ; if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING ) return false ; mode -> crtc_htotal = <S2SV_ModStart> -> bios + data_offset ) ; if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ; dtd_timings = & tv_info_v1_2
<S2SV_ModStart> ) ; if ( q -> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_ctx ; flush_rq -> tag = first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
<S2SV_ModStart> ) ; if ( q -> mq_ops ) { struct blk_mq_hw_ctx * hctx ; spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq <S2SV_ModEnd> ) ; flush_rq -> tag = - 1 ;
<S2SV_ModStart> , bit + 1 ) ) { rq = hctx -> tags -> rqs [ off + bit ] <S2SV_ModEnd> ; if ( rq -> q == hctx ->
<S2SV_ModStart> , bit + 1 ) ) { rq = tags -> rqs [ off + bit ] <S2SV_ModEnd> ; fn ( rq , data , reserved )
<S2SV_ModStart> blk_mq_tags * tags , unsigned int tag ) { return tags -> rqs [ tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = usb_get_intfdata ( intf ) ; const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModEnd> ; dev_dbg ( & d -> udev -> dev <S2SV_ModStart> ( d ) ; dvb_usbv2_exit ( d ) ; pr_info ( "%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( client -> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> = ns ; new -> uid = uid ; new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( & ucounts_lock ) ; ucounts = <S2SV_ModStart> ; ucounts = new ; } } if ( ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts
<S2SV_ModStart> ucounts * ucounts ) { unsigned long flags ; spin_lock_irqsave ( & ucounts_lock , flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ; else ucounts = NULL <S2SV_ModEnd> ; spin_unlock_irqrestore ( & ucounts_lock , flags ) ; <S2SV_ModStart> , flags ) ; kfree ( ucounts ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> } mutex_unlock ( & ufile -> umap_lock ) ; skip_mm :
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
<S2SV_ModStart> out ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } skip_mm :
<S2SV_ModStart> ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
<S2SV_ModStart> ) ; if ( res ) return res ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct domain_device * dev , * n <S2SV_ModStart> ) { struct domain_device * dev , * n <S2SV_ModEnd> ; list_for_each_entry_safe ( dev , n , & port
<S2SV_ModStart> ) ; port -> port_dev = NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> ) ; if ( res ) return res ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = <S2SV_ModStart> ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices <S2SV_ModEnd> , } ; disc -> pending = 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct domain_device * dev , * n <S2SV_ModStart> ) { struct domain_device * dev , * n <S2SV_ModEnd> ; list_for_each_entry ( dev , & port -> disco_list
<S2SV_ModStart> : mutex_unlock ( & ha -> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> -> disco_list_node , & port -> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = sas_find_bcast_dev ( port_dev , & dev ) ; if <S2SV_ModEnd> ( res == 0 && dev ) { struct <S2SV_ModStart> while ( i < ex -> num_phys ) ; <S2SV_ModEnd> } return res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy -> port = NULL ; }
<S2SV_ModStart> == 1 ) { sas_unregister_domain_devices ( port , gone ) ; sas_destruct_devices ( port
<S2SV_ModStart> ; INIT_LIST_HEAD ( & port -> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> ( rc ) { sas_unregister_dev ( port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> cmd == VFIO_DEVICE_SET_IRQS ) { struct vfio_irq_set hdr ; size_t size ; u8 * data = NULL ; int max , <S2SV_ModEnd> ret = 0 ; minsz = offsetofend ( struct <S2SV_ModStart> || hdr . index >= VFIO_PCI_NUM_IRQS || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> VFIO_IRQ_SET_DATA_TYPE_MASK | VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count ( vdev , hdr . index <S2SV_ModStart> vdev , hdr . index ) ; if ( <S2SV_ModEnd> hdr . start >= max || hdr . start <S2SV_ModStart> hdr . start + hdr . count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
<S2SV_ModStart> ) return - EINVAL ; vdev -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;
<S2SV_ModStart> usb_device * usb_dev = atusb -> usb_dev ; char * build ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModEnd> ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( <S2SV_ModStart> -> dev , "Firmware:<S2SV_blank>build<S2SV_blank>%s\\n" , build ) ; } kfree ( build ) ;
<S2SV_ModStart> * usb_dev = atusb -> usb_dev ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( <S2SV_ModStart> & usb_dev -> dev , "Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer" ) ; } kfree ( buffer ) ;
<S2SV_ModStart> = atusb -> usb_dev ; int ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( & usb_dev -> dev , "atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n" <S2SV_ModStart> , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ; if ( ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return ret ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> mdev = dev -> mdev ; struct mlx5_ib_create_qp_resp resp = { }
<S2SV_ModStart> utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
<S2SV_ModStart> * outlen = utf8s_to_utf16s ( name , len , UTF16_HOST_ENDIAN , ( wchar_t * ) outname , FAT_LFN_LEN + 2 <S2SV_ModEnd> ) ; if ( * outlen < 0 )
<S2SV_ModStart> = f_hidg_req_complete ; req -> context = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; goto release_write_pending <S2SV_ModEnd> ; } else { status = count ; } <S2SV_ModStart> ; } else { status = count ; } <S2SV_ModEnd> return status ; release_write_pending : spin_lock_irqsave ( & hidg <S2SV_ModStart> ( & hidg -> write_spinlock , flags ) ; <S2SV_ModEnd> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( &
<S2SV_ModStart> { case ACL_TYPE_ACCESS : if ( acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval ) goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry <S2SV_ModStart> ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : if ( !
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret = 0 ; break ; case
<S2SV_ModStart> EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode <S2SV_ModStart> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT
<S2SV_ModStart> EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime = ext4_current_time ( inode ) ; <S2SV_ModStart> ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT
<S2SV_ModStart> F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error ; set_acl_inode ( inode , inode <S2SV_ModStart> ; set_acl_inode ( inode , inode -> i_mode ) <S2SV_ModEnd> ; } break ; case ACL_TYPE_DEFAULT : name_index =
<S2SV_ModStart> umode_t mode = inode -> i_mode ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( mode != inode -> i_mode ) <S2SV_ModStart> ; if ( mode != inode -> i_mode ) mark_inode_dirty ( inode ) ; <S2SV_ModEnd> } if ( acl ) { len = posix_acl_to_xattr
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { err = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err ; } err = 0 ;
<S2SV_ModStart> JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { umode_t mode ; rc = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc ; if ( inode -> i_mode <S2SV_ModStart> ( rc < 0 ) return rc ; } <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { rc = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) <S2SV_ModEnd> goto out ; } rc = __jfs_setxattr ( tid
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { umode_t mode ; error = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( error ) { gossip_err ( "%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n" <S2SV_ModEnd> , __func__ , error ) ; return error ; <S2SV_ModStart> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT
<S2SV_ModStart> XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT
<S2SV_ModStart> if ( type == ACL_TYPE_ACCESS ) { umode_t mode ; error = posix_acl_update_mode ( inode , & mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> error = xfs_set_mode ( inode , mode ) ;
<S2SV_ModStart> d_instantiate ( dentry , inode ) ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
<S2SV_ModStart> ; int ret ; uint32_t size ; uint32_t backup_handle = 0 <S2SV_ModStart> -> backup_base ) ; if ( ret == 0 ) { if ( <S2SV_ModEnd> res -> backup -> base . num_pages * PAGE_SIZE <S2SV_ModStart> ; ret = - EINVAL ; goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
<S2SV_ModStart> == NULL ) return - ENOMEM ; ue -> card = card ; ue ->
<S2SV_ModStart> struct user_element * ue = kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> ue -> elem_data , ue -> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> ; struct user_element * ue = kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> ucontrol -> value , ue -> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> new_data ) ) return PTR_ERR ( new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = new_data ; ue -> tlv_data_size = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModEnd> if ( ! ue -> tlv_data_size || ! ue <S2SV_ModStart> ue -> tlv_data_size || ! ue -> tlv_data ) { ret = - ENXIO ; goto err_unlock ; } if ( size < ue -> tlv_data_size ) { ret = - ENOSPC ; goto err_unlock ; } <S2SV_ModEnd> if ( copy_to_user ( tlv , ue -> tlv_data <S2SV_ModStart> ue -> tlv_data , ue -> tlv_data_size ) ) ret = - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ; <S2SV_ModEnd> } return change ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock
<S2SV_ModStart> & resp_buftype , flags , & rsp_iov ) ; <S2SV_ModEnd> rsp = ( struct smb2_read_rsp * ) rsp_iov . <S2SV_ModStart> io_parms -> offset , io_parms -> length ) ; cifs_small_buf_release ( req ) ;
<S2SV_ModStart> short op , int st ) { struct blkif_response * <S2SV_ModStart> flags ; union blkif_back_rings * blk_rings ; int notify <S2SV_ModEnd> ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags <S2SV_ModStart> -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> <S2SV_ModStart> -> native , blk_rings -> native . rsp_prod_pvt ) ; break ; case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> <S2SV_ModStart> -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ; break ; case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> <S2SV_ModStart> -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; default : BUG ( ) ; <S2SV_ModStart> break ; default : BUG ( ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
<S2SV_ModStart> [ i ] ; goto out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
<S2SV_ModStart> ] ; goto out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; } if (
<S2SV_ModStart> posix_acl * acl ; struct xfs_acl_entry * ace ; unsigned
<S2SV_ModStart> ret = - EFAULT ; goto exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> , s_cmd , sizeof ( * s_cmd ) + s_cmd -> <S2SV_ModEnd> insize ) ) ret = - EFAULT ; exit
<S2SV_ModStart> ) ; if ( ret == 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> = key -> payload . data [ 0 ] ; else zap = NULL
<S2SV_ModStart> kvm ) ; kvm_for_each_memslot ( memslot , slots ) kvm_iommu_unmap_pages ( kvm , memslot <S2SV_ModEnd> ) ; srcu_read_unlock ( & kvm -> srcu ,
<S2SV_ModStart> ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ;
<S2SV_ModStart> __user * utp ) { struct compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> ( hid -> name , req -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf ( hid -> phys , sizeof
<S2SV_ModStart> q -> bufs [ first ] -> map = kzalloc <S2SV_ModEnd> ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL )
<S2SV_ModStart> q ; int i ; dprintk ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map , map -> count , vma ->
<S2SV_ModStart> = vma -> vm_private_data ; dprintk ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map , map -> count , vma ->
<S2SV_ModStart> ( "lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n" , - task -> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : goto retry_rebind ; } <S2SV_ModEnd> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay
<S2SV_ModStart> ; task -> tk_cred_retry = 2 ; task -> tk_rebind_retry = 2 ; task ->
<S2SV_ModStart> -> disk_name , cmd ) ) ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
<S2SV_ModStart> ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 <S2SV_ModEnd> ) ; } smin_val = src_reg . smin_value ;
<S2SV_ModStart> env , regs , insn -> dst_reg ) ; coerce_reg_to_size ( & regs [ insn -> dst_reg ] , 4 <S2SV_ModEnd> ) ; } } else { regs [ insn
<S2SV_ModStart> [ value_regno ] . type == SCALAR_VALUE ) { coerce_reg_to_size ( & regs [ value_regno ] , size <S2SV_ModEnd> ) ; } return err ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = nvmet_fc_getqueueid ( connection_id ) ; unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
<S2SV_ModStart> * xtregs = uregs ; int ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
<S2SV_ModStart> verbose ( "%d:<S2SV_blank>" , insn_idx ) ; print_bpf_insn ( env ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ( BPF_MODE ( insn -> code ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , insn -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ; } else { verbose ( "BUG_ld_%02x\\n"
<S2SV_ModStart> op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) <S2SV_ModEnd> ) { flags &= ~ FLAG_LAST_MATCHED ; pc +=
<S2SV_ModStart> , uid ) ; if ( user -> uid_keyring && user -> session_keyring
<S2SV_ModStart> tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen + frag_hdr_sz ) ) { if
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct super_block * sb , unsigned char <S2SV_ModStart> from , int fromlen , unsigned char * to , int tolen <S2SV_ModStart> struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; <S2SV_ModEnd> while ( elen < fromlen ) { pc = <S2SV_ModStart> lengthComponentIdent > 0 ) break ; case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p , "../" , 3 ) ; <S2SV_ModStart> "../" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p , "./" , 2 ) ; <S2SV_ModStart> "./" , 2 ) ; p += 2 ; tolen -= 2 ; break ; case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- <S2SV_ModEnd> ; break ; } elen += sizeof ( struct <S2SV_ModStart> ; else p [ 0 ] = '\\0' ; return 0 ;
<S2SV_ModStart> ; } symlink = bh -> b_data ; } err = <S2SV_ModStart> i_sb , symlink , inode -> i_size , p , PAGE_SIZE ) ; brelse ( bh ) ; if ( err ) goto out_unlock_inode <S2SV_ModEnd> ; up_read ( & iinfo -> i_data_sem ) ;
<S2SV_ModStart> ) { pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void * memory ; if ( dma_alloc_from_coherent
<S2SV_ModStart> ) { pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void * memory ; if ( dma_alloc_from_coherent
<S2SV_ModStart> ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> ] ; altsd = get_iface_desc ( alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> S_ISDIR ( mode ) ) mode |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> ; same = NULL ; goto out ; } same -> dest_count = count ;
<S2SV_ModStart> = upperdir -> d_inode ; struct dentry * upper <S2SV_ModEnd> ; int err ; inode_lock_nested ( dir , I_MUTEX_PARENT <S2SV_ModStart> err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; err = - ESTALE ; if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir ) err = vfs_rmdir ( dir <S2SV_ModStart> vfs_unlink ( dir , upper , NULL ) ; ovl_dentry_version_inc ( dentry -> d_parent ) ; } dput ( upper ) ; <S2SV_ModEnd> if ( ! err ) d_drop ( dentry ) <S2SV_ModStart> ( ! err ) d_drop ( dentry ) ; out_unlock :
<S2SV_ModStart> lock_rename ( new_upperdir , old_upperdir ) ; olddentry = lookup_one_len ( old -> d_name . name , old_upperdir , old <S2SV_ModEnd> -> d_name . len ) ; err = PTR_ERR <S2SV_ModStart> d_name . len ) ; err = PTR_ERR ( olddentry ) ; if ( IS_ERR ( olddentry ) ) goto out_unlock ; err = - ESTALE ; if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir ) goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModEnd> if ( olddentry == trap ) goto out_dput ; <S2SV_ModStart> ) ; out_dput : dput ( newdentry ) ; out_dput_old : dput ( olddentry ) ;
<S2SV_ModStart> base = i -> iov_offset ; while ( bytes || ! iov -> iov_len
<S2SV_ModStart> ; copied = status ; cond_resched ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> ( i ) ) ; goto again ; } <S2SV_ModEnd> pos += copied ; written += copied ; balance_dirty_pages_ratelimited
<S2SV_ModStart> ( "%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n" , bd -> name , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
<S2SV_ModStart> ) { if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw <S2SV_ModEnd> ( ) && ! capable ( CAP_SYS_ADMIN ) )
<S2SV_ModStart> ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn
<S2SV_ModStart> & end_ptr , 0 ) ; if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) { printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" "<S2SV_blank>%u\\n" ,
<S2SV_ModStart> return - EBUSY ; } chip -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL ) ; if ( chip -> data_buffer
<S2SV_ModStart> source_mnt , struct list_head * tree_list ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> m , prev_dest_mnt , prev_src_mnt , & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
<S2SV_ModStart> rqstp -> rq_arg . head [ 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> ntohl ( * p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ; if (
<S2SV_ModStart> void * ) p - head -> iov_base ; if ( hdr > head -> iov_len ) return 0 ;
<S2SV_ModStart> ep_loop_check ( ep , tfile ) != 0 ) { clear_tfile_check_list ( ) ; goto error_tgt_fput ; } <S2SV_ModEnd> } else list_add ( & tfile -> f_tfile_llink ,
<S2SV_ModStart> , KLSI_STATUSBUF_LEN , 10000 ) ; if ( rc != KLSI_STATUSBUF_LEN ) { dev_err ( & port -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status = get_unaligned_le16 ( status_buf ) ;
<S2SV_ModStart> ( bh ) ; clear_buffer_new ( bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
<S2SV_ModStart> ( sbi ) ; unsigned int ovp_segments , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i <S2SV_ModStart> KERN_ERR , "Wrong<S2SV_blank>layout:<S2SV_blank>check<S2SV_blank>mkfs.f2fs<S2SV_blank>version" ) ; return 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer <S2SV_ModStart> * pipe , struct pipe_buffer * buf ) { return try_get_page <S2SV_ModEnd> ( buf -> page ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> & ( opipe -> buffers - 1 ) ; if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe -> bufs + nbuf ; *
<S2SV_ModStart> -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf = * ibuf ; obuf -> flags
<S2SV_ModStart> rcur -> var_off ) ; } else { return false <S2SV_ModEnd> ; } case PTR_TO_MAP_VALUE : return memcmp ( rold
<S2SV_ModStart> -> cid_shift = 16 ; new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
<S2SV_ModStart> cifs_dbg ( VFS , "BAD_NETWORK_NAME:<S2SV_blank>%s\\n" , tree ) ; if ( tcon )
<S2SV_ModStart> ) ; goto err ; } if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) { dev_err ( dev , "Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n" ,
<S2SV_ModStart> vma -> vm_flags & VM_WRITE ) ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) { pte_unmap_unlock ( ptep , ptl )
<S2SV_ModStart> unsigned int flags ) { struct dentry * dir <S2SV_ModEnd> ; int dir_has_key , cached_with_key ; if ( flags <S2SV_ModStart> dput ( dir ) ; return 0 ; } <S2SV_ModEnd> spin_lock ( & dentry -> d_lock ) ; cached_with_key <S2SV_ModStart> & dentry -> d_lock ) ; dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL ) ; dput ( dir ) ;
<S2SV_ModStart> -> len ; return 0 ; } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir ) ; if ( ret && ret
<S2SV_ModStart> struct inode * inode ) { struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res ; if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( ! ci ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free (
<S2SV_ModStart> keyring_key ) ) return PTR_ERR ( keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> res = - ENOKEY ; goto out ; } <S2SV_ModEnd> ukp = user_key_payload ( keyring_key ) ; if ( <S2SV_ModStart> struct fscrypt_key ) ) { res = - EINVAL <S2SV_ModEnd> ; goto out ; } master_key = ( struct <S2SV_ModStart> -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read ( & keyring_key -> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * np = netdev_priv ( dev ) ; struct mii_ioctl_data * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = np -> phy_addr ; switch ( <S2SV_ModStart> -> phy_addr ; switch ( cmd ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; break ; case SIOCGMIIREG : miidata -> val_out <S2SV_ModEnd> = mii_read ( dev , phy_addr , miidata -> <S2SV_ModStart> , miidata -> reg_num ) ; break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev , phy_addr , miidata -> reg_num <S2SV_ModStart> , phy_addr , miidata -> reg_num , miidata -> val_in <S2SV_ModEnd> ) ; break ; default : return - EOPNOTSUPP
<S2SV_ModStart> - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; spin_lock_init ( & ctx -> cancel_lock
<S2SV_ModStart> void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) { spin_lock ( & ctx -> cancel_lock ) ; __timerfd_remove_cancel ( ctx ) ; spin_unlock ( & ctx -> cancel_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct timerfd_ctx * ctx , int flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> spin_unlock ( & cancel_lock ) ; } } else { __timerfd_remove_cancel ( ctx ) ; } spin_unlock ( & ctx -> cancel_lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> src_addr , struct page * * pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> ( page ) ; set_page_huge_active ( page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; if ( vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = huge_add_to_page_cache ( page , mapping , <S2SV_ModStart> dst_mm , dst_pte ) ; spin_lock ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
<S2SV_ModStart> wait ; unsigned long flags ; if ( ! tty ) return ; if ( !
<S2SV_ModStart> demodulator_priv ; int i , ret ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> } printk ( ")<S2SV_blank>toneburst=%d\\n" , toneburst ) ; } <S2SV_ModEnd> for ( i = 0 ; i < d
<S2SV_ModStart> 0 ; out_cancel : xfs_trans_cancel ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
<S2SV_ModStart> , buf [ sizeof ( "nnnnn\\0" ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( copy_from_user ( buf , buffer , <S2SV_ModStart> ; if ( copy_from_user ( buf , buffer , size <S2SV_ModEnd> ) ) return - EFAULT ; tmp = simple_strtol
<S2SV_ModStart> += 255 ) len = * ip ++ ; if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;
<S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) ) { const unsigned char * <S2SV_ModStart> ; } else # endif { NEED_OP ( t , 0 ) ; NEED_IP ( t , <S2SV_ModEnd> 3 ) ; do { * op ++ = <S2SV_ModStart> ; TEST_LB ( m_pos ) ; NEED_OP ( 2 , 0 <S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> 31 + * ip ++ ; NEED_IP ( 2 , 0 <S2SV_ModStart> += 255 ; ip ++ ; NEED_IP ( 1 , 0 <S2SV_ModStart> 7 + * ip ++ ; NEED_IP ( 2 , 0 <S2SV_ModStart> t ; if ( likely ( HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) ) { do { COPY8 ( <S2SV_ModStart> op = oe ; if ( HAVE_IP ( 6 , 0 <S2SV_ModStart> continue ; } } else { NEED_OP ( t , 0 <S2SV_ModStart> oe = op + t ; NEED_OP ( t , 0 <S2SV_ModStart> CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 <S2SV_ModEnd> ) ) ) { COPY4 ( op , ip <S2SV_ModStart> ; } else # endif { NEED_IP ( t , 3 ) ; NEED_OP ( t , 0 <S2SV_ModEnd> ) ; while ( t > 0 ) {
<S2SV_ModStart> = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> ( & mpu -> input_lock , flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = <S2SV_ModEnd> readw ( mpu -> dev -> MIDQ + JQS_wTail <S2SV_ModStart> ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head <S2SV_ModEnd> ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & <S2SV_ModStart> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , mpu -> dev -> MIDQ + JQS_wHead ) <S2SV_ModStart> -> dev -> MIDQ + JQS_wHead ) ; } out :
<S2SV_ModStart> netns_ids , id ) ; if ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer ) ; spin_unlock_bh ( & net ->
<S2SV_ModStart> - EFAULT ; len = namelen ; if ( len <S2SV_ModEnd> > 32 ) len = 32 ; down_read (
<S2SV_ModStart> strlen ( res ) + 1 ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len = count ; if ( copy_to_user
<S2SV_ModStart> struct rusage r ; long ret , err ; unsigned int status = 0 ; <S2SV_ModStart> KERNEL_DS ) ; ret = sys_wait4 ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , ( struct rusage __user * ) <S2SV_ModStart> - EFAULT ; err = 0 ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> return 1 ; case GSI_GET_HWRPB : if ( nbytes > <S2SV_ModEnd> sizeof ( * hwrpb ) ) return - EINVAL
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst <S2SV_ModStart> struct x86_emulate_ctxt * ctxt , ulong dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_call ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_ModStart> = ( unsigned long ) ctxt -> _eip ; rc = jmp_rel ( ctxt , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc <S2SV_ModEnd> ; return em_push ( ctxt ) ; } <S2SV_null>
<S2SV_ModStart> int old_eip ; old_eip = ctxt -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModEnd> ; ctxt -> src . val = old_eip ; <S2SV_ModStart> ctxt ) ; break ; } case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) <S2SV_ModEnd> ; break ; case 5 : rc = em_jmp_far
<S2SV_ModStart> int em_jcxz ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = <S2SV_ModStart> , ctxt -> src . val ) ; return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_loop ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ^ 0x5 , ctxt -> eflags ) ) ) rc = <S2SV_ModStart> , ctxt -> src . val ) ; return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int em_ret ( struct x86_emulate_ctxt * ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct x86_emulate_ctxt * ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; if ( rc != X86EMUL_CONTINUE ) return
<S2SV_ModStart> ; struct desc_struct cs , ss ; u64 msr_data , rcx , rdx <S2SV_ModStart> usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 0 ; cs . l = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> 0 , VCPU_SREG_SS ) ; ctxt -> _eip = rdx <S2SV_ModEnd> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = <S2SV_ModStart> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel <S2SV_ModStart> struct x86_emulate_ctxt * ctxt , int rel ) { return
<S2SV_ModStart> ctxt -> b , ctxt -> eflags ) ) rc = <S2SV_ModStart> ; break ; case 0xe9 : case 0xeb : rc = <S2SV_ModStart> ctxt -> b , ctxt -> eflags ) ) rc =
<S2SV_ModStart> if ( keyring == new -> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> * find_keyring_by_name ( const char * name , bool uid_keyring <S2SV_ModEnd> ) { struct key * keyring ; int bucket <S2SV_ModStart> name ) != 0 ) continue ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref ( keyring , 0 ) , <S2SV_ModStart> ) , KEY_NEED_SEARCH ) < 0 ) continue ; }
<S2SV_ModStart> -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
<S2SV_ModStart> inode_owner_or_capable ( const struct inode * inode ) { struct user_namespace * ns ; <S2SV_ModStart> , inode -> i_uid ) ) return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return true ; return false ; }
<S2SV_ModStart> , fsuid ) ) return 0 ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_FOWNER ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( inode -> i_mode ) ) { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_OVERRIDE ) ) return 0 ; <S2SV_ModStart> ! ( mask & MAY_WRITE ) ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ; <S2SV_ModStart> inode -> i_mode & S_IXUGO ) ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_OVERRIDE ) ) return 0 ; <S2SV_ModStart> ; if ( mask == MAY_READ ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;
<S2SV_ModStart> & ( S_ISUID | S_ISGID ) ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I ( ip ) , CAP_FSETID ) )
<S2SV_ModStart> ; } inode -> i_generation = iinfo -> i_unique ; if ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out
<S2SV_ModStart> [ dp ++ ] ; if ( tag == ASN1_EOC <S2SV_ModEnd> ) { if ( data [ dp ++ ] <S2SV_ModStart> ++ ] ; if ( len <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) <S2SV_ModStart> ; if ( unlikely ( n > sizeof ( len <S2SV_ModEnd> ) - 1 ) ) goto length_too_long ; if <S2SV_ModStart> > datalen - dp ) ) goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > 0 ; n -- ) { <S2SV_ModStart> len |= data [ dp ++ ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
<S2SV_ModStart> case S_IFREG : case S_IFLNK : case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else { switch ( dip -> di_aformat )
<S2SV_ModStart> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid <S2SV_ModEnd> ( ) ) ) { int mode = ( <S2SV_ModStart> << 3 ) | mode ; } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) { int mode = ( table ->
<S2SV_ModStart> pdev -> dev ) ; gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc <S2SV_ModEnd> , gpio_dev ) ; if ( IS_ERR ( gpio_dev <S2SV_ModStart> gc , gpio_dev ) ; if ( ret ) return ret <S2SV_ModEnd> ; ret = gpiochip_add_pin_range ( & gpio_dev -> gc <S2SV_ModStart> : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> chunk_end - chunk -> skb -> data ) ; <S2SV_ModEnd> } } if ( ! chunk ) { struct <S2SV_ModStart> v = NULL ; if ( chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> > skb_tail_pointer ( chunk -> skb ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( "+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ia_valid & ATTR_SIZE ; if ( size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ia_size ) ; if ( status ) goto bail_unlock <S2SV_ModEnd> ; if ( i_size_read ( inode ) >= attr
<S2SV_ModStart> -> dentry = dentry ; path -> mnt = nd -> path . mnt <S2SV_ModEnd> ; if ( should_follow_link ( dentry , nd -> <S2SV_ModStart> -> flags & LOOKUP_FOLLOW ) ) return 1 ; mntget ( path -> mnt ) ;
<S2SV_ModStart> platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> : port -> port . count = 0 ; info -> port = NULL ;
<S2SV_ModStart> ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
<S2SV_ModStart> BUG_ON ( ! vma_can_userfault ( vma ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
<S2SV_ModStart> == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u64 mode = ( * ( u64 <S2SV_ModEnd> * ) valp ) & PSR_AA32_MODE_MASK ; switch ( <S2SV_ModStart> ; switch ( mode ) { case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
<S2SV_ModStart> offset ; struct iov_iter i ; struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> & pages [ cur_page ] ) ; if ( unlikely ( ret < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - EFAULT ; goto out_unmap ; } <S2SV_ModStart> ( bio ) ; return bio ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; } out : kfree ( pages )
<S2SV_ModStart> ( & stime -> running , 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime -> hrt ) ; hrtimer_start (
<S2SV_ModStart> ( & stime -> running , 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
<S2SV_ModStart> ; cdev_del ( cc -> cdev ) ; } fuse_conn_put ( & cc -> fc ) ;
<S2SV_ModStart> ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id <S2SV_ModStart> struct iwl_priv * priv , u8 sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , "invalid<S2SV_blank>sta_id<S2SV_blank>%u" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> . sta . sta . addr ) ; } return 0 ;
<S2SV_ModStart> = xfs_attr_rmtval_get ( & args ) ; if ( ! retval ) <S2SV_ModEnd> retval = context -> put_listent ( context , entry
<S2SV_ModStart> -> namelen ] ) ; if ( error ) { kmem_free ( sbuf ) ; return error ; } <S2SV_ModEnd> if ( context -> seen_enough ) break ; cursor
<S2SV_ModStart> ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ; <S2SV_ModEnd> result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev <S2SV_ModStart> , le16_to_cpu ( get_version_reply . build_no ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
<S2SV_ModStart> timer = & pit -> pit_state . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
<S2SV_ModStart> * tty , struct usb_serial_port * port ) { <S2SV_ModEnd> return usb_serial_generic_open ( tty , port ) ; }
<S2SV_ModStart> 0 , } ; char * command , * largs = NULL , * <S2SV_ModStart> if ( size == 0 ) return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> [ size - 1 ] != '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - EINVAL ; args = strim ( args ) ; command = strsep ( & args , "<S2SV_blank>" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , "current" ) == 0 ) { if ( strcmp ( command , "changehat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permhat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , "changeprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else if ( strcmp ( name , "exec" ) == 0 ) { if ( strcmp ( command , "exec" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; else goto fail ; } else goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error ; fail : sa . type <S2SV_ModStart> . info = name ; aad . error = error = <S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NM_I ( sbi ) ; struct free_nid * i , * e ; struct nat_entry * ne ; int err = - EINVAL ; bool ret = false <S2SV_ModEnd> ; if ( unlikely ( nid == 0 ) <S2SV_ModStart> ( nid == 0 ) ) return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> kgid_t group = new -> egid ; int ret ; if ( current_chrooted ( ) ) return - EPERM
<S2SV_ModStart> ( cmd -> device -> host ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> ) ; sas_end_task ( cmd , task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
<S2SV_ModStart> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n" , __func__ , task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; continue ; case TASK_IS_ABORTED : <S2SV_ModStart> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n" , __func__ , task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; continue ; case TASK_IS_AT_LU : <S2SV_ModStart> ) , cmd -> device -> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; sas_scsi_clear_queue_lu ( work_q , cmd
<S2SV_ModStart> -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) ; } } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; } if ( move_group ) { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if ( gctx -> task == TASK_TOMBSTONE <S2SV_ModStart> err = - ESRCH ; goto err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_unpin_context ( ctx ) ; if ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock ( & ctx -> mutex ) <S2SV_ModStart> return event_fd ; err_locked : if ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock ( & ctx -> mutex )
<S2SV_ModStart> ; struct kvm_vcpu * vcpu , * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
<S2SV_ModStart> i8042_lock , flags ) ; if ( likely ( serio <S2SV_ModEnd> && ! filtered ) ) serio_interrupt ( serio ,
<S2SV_ModStart> struct i8042_port * port = serio -> port_data ; spin_lock_irq ( & i8042_lock ) ; port -> exists = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct i8042_port * port = serio -> port_data ; spin_lock_irq ( & i8042_lock ) ; port -> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModEnd> ; synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ <S2SV_ModStart> ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> printk ( KERN_ERR "kvm_iommu_map_address:" "iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n" , pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn
<S2SV_ModStart> ( & net -> passive , 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
<S2SV_ModStart> void queue_delete ( struct snd_seq_queue * q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ( q -> timer ) ; snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
<S2SV_ModStart> = llc_sk ( sk ) ; int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( sllc ) ) ; lock_sock ( <S2SV_ModStart> goto out ; * uaddrlen = sizeof ( sllc <S2SV_ModEnd> ) ; if ( peer ) { rc =
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , ":<S2SV_blank>%zu<S2SV_blank>[%s]"
<S2SV_ModStart> key_payload_reserve ( key , 0 ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) && ( size_t ) key ->
<S2SV_ModStart> -> next , struct key , graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ) ; key_check ( key ) ; if ( state == KEY_IS_POSITIVE <S2SV_ModEnd> && key -> type -> destroy ) key -> <S2SV_ModStart> key -> user -> nkeys ) ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec ( & key -> user -> nikeys
<S2SV_ModStart> ; mutex_lock ( & key_construction_mutex ) ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret = key -> type -> instantiate <S2SV_ModStart> ( & key -> user -> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , &
<S2SV_ModStart> prep ) ; if ( ret == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write ( & key -> sem )
<S2SV_ModStart> } mutex_lock ( & key_construction_mutex ) ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_inc ( & key -> user -> <S2SV_ModStart> ( & key -> user -> nikeys ) ; mark_key_instantiated ( key , - error <S2SV_ModEnd> ) ; now = current_kernel_time ( ) ; key
<S2SV_ModStart> prep ) ; if ( ret == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write ( & key -> sem )
<S2SV_ModStart> seq_puts ( m , "[anon]" ) ; if ( key_is_positive <S2SV_ModEnd> ( keyring ) ) { if ( keyring ->
<S2SV_ModStart> keyring_ptr_to_key ( object ) ; unsigned long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( "{%d}" , key -> serial ) <S2SV_ModStart> ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( state < 0 ) { ctx -> result = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]" , ctx -> skipped_ret
<S2SV_ModStart> if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key ; ret = key_task_permission ( key_ref
<S2SV_ModStart> ; if ( ret ) return - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate ( key ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , "<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"
<S2SV_ModStart> m , key -> description ) ; if ( key_is_positive <S2SV_ModEnd> ( key ) ) seq_printf ( m , ":<S2SV_blank>%u"
<S2SV_ModStart> -> expiry = prep -> expiry ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap = dereference_key_locked ( key ) ;
<S2SV_ModStart> BUG ( ) ; BUG_ON ( ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> primary , new ) ; synchronize_rcu ( ) ; unlock :
<S2SV_ModStart> mutex_unlock ( & key_construction_mutex ) ; if ( keyring && link_ret == 0
<S2SV_ModStart> -> wq . entry , & fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_ModEnd> spin_lock ( & ctx -> event_wqh . lock ) <S2SV_ModStart> ( ! list_empty ( & fork_event ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> -> event_wqh , & uwq -> wq ) ; if ( likely ( ! ret ) ) userfaultfd_event_complete ( ctx , uwq ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
<S2SV_ModStart> size ) ; if ( ret != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> follow_dotdot ( struct nameidata * nd ) { if <S2SV_ModStart> . dentry ) ; dput ( old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> = nd -> path . dentry -> d_inode ; return 0 ;
<S2SV_ModStart> = parent ; nd -> seq = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
<S2SV_ModStart> { return follow_dotdot_rcu ( nd ) ; } else return
<S2SV_ModStart> struct vcpu_data vcpu_info ; int idx , ret = 0 <S2SV_ModEnd> ; if ( ! kvm_arch_has_assigned_device ( kvm ) || <S2SV_ModStart> -> irq_routing , & kvm -> irq_srcu ) ; if ( guest_irq >= irq_rt -> nr_rt_entries || hlist_empty ( & irq_rt -> map [ guest_irq ] ) ) { pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } <S2SV_ModEnd> hlist_for_each_entry ( e , & irq_rt -> map [
<S2SV_ModStart> timer , 1 ) ; # endif _end : <S2SV_ModEnd> kill_fasync ( & runtime -> fasync , SIGIO , <S2SV_ModStart> runtime -> fasync , SIGIO , POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;
<S2SV_ModStart> void acpi_ns_terminate ( void ) { acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * prev ; union acpi_operand_object * next <S2SV_ModStart> union acpi_operand_object * prev ; union acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> = NULL ; acpi_ut_remove_reference ( prev ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex (
<S2SV_ModStart> ; struct scatterlist sg [ 3 ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen , err ; err = format_input
<S2SV_ModStart> , offset , bytes ) ; flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart> length = tmp ; req -> num_pages ++ ; <S2SV_ModEnd> count += tmp ; pos += tmp ; offset
<S2SV_ModStart> ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr = 0x800 ; msr <= 0x8ff <S2SV_ModStart> ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_ModEnd> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull ,
<S2SV_ModStart> ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
<S2SV_ModStart> ) ) msr_bitmap = vmx_msr_bitmap_nested ; else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if ( is_long_mode ( vcpu ) )
<S2SV_ModStart> pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> ) ; kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT
<S2SV_ModStart> kvm_memory_slot * slot , gfn_t gfn , unsigned long npages <S2SV_ModEnd> ) { gfn_t end_gfn ; pfn_t pfn ; pfn <S2SV_ModStart> slot , gfn ) ; end_gfn = gfn + npages <S2SV_ModEnd> ; gfn += 1 ; if ( is_error_noslot_pfn (
<S2SV_ModStart> * st = d -> priv ; int ret <S2SV_ModEnd> ; if ( 1 + wlen > MAX_XFER_SIZE ) <S2SV_ModStart> , wlen ) ; return - EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & d -> data_mutex ) ; st <S2SV_ModStart> [ 1 ] , wbuf , wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw ( d , st -> data <S2SV_ModStart> , st -> data , 1 + wlen , st -> data , rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen <S2SV_ModEnd> ) ; mutex_unlock ( & d -> data_mutex )
<S2SV_ModStart> ; haddr -> hci_dev = hdev -> id ; haddr -> hci_channel = 0 ;
<S2SV_ModStart> if ( ! addr ) return - ENODEV ; <S2SV_ModEnd> switch ( io -> regsize ) { case 1 <S2SV_ModStart> -> io_size ) ; return - EIO ; } io -> io_cleanup = mem_cleanup ;
<S2SV_ModStart> ; if ( ! addr ) return - ENODEV <S2SV_ModEnd> ; switch ( io -> regsize ) { case <S2SV_ModStart> regsize ) ; return - EIO ; } } io -> io_cleanup = port_cleanup ;
<S2SV_ModStart> struct iso_directory_record * de , struct inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = parse_rock_ridge_inode_internal ( de , inode , <S2SV_ModStart> int result = parse_rock_ridge_inode_internal ( de , inode , flags <S2SV_ModEnd> ) ; if ( ( ISOFS_SB ( inode -> <S2SV_ModStart> { result = parse_rock_ridge_inode_internal ( de , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; } return result ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * de , struct inode * inode , int flags <S2SV_ModEnd> ) { int symlink_len = 0 ; int cnt <S2SV_ModStart> int symlink_len = 0 ; int cnt , sig ; unsigned int reloc_block <S2SV_ModStart> , inode , & rs ) ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs . chr += 14 ; rs <S2SV_ModStart> ; case SIG ( 'C' , 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block ; reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block <S2SV_ModEnd> , 0 ) ; if ( IS_ERR ( reloc
<S2SV_ModStart> int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> sizeof ( info ) ) ) return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL
<S2SV_ModStart> [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; int i <S2SV_ModStart> return - EFAULT ; else info = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
<S2SV_ModStart> ) ; if ( PageDirty ( page ) ) SetPageDirty ( newpage ) ; <S2SV_ModEnd> if ( page_is_young ( page ) ) set_page_young (
<S2SV_ModStart> , enum migrate_mode mode , int extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> SetPageSwapBacked ( newpage ) ; return MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> newpage , page_private ( page ) ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> page_unfreeze_refs ( page , expected_count - 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone , NR_FILE_PAGES ) ; __inc_zone_state ( newzone , NR_FILE_PAGES ) ; if ( PageSwapBacked ( page ) && ! PageSwapCache ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return MIGRATEPAGE_SUCCESS ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( nsock ) ; return - EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
<S2SV_ModStart> , insn -> dst_reg ) ; break ; } <S2SV_ModEnd> dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value <S2SV_ModStart> = S64_MIN ; dst_reg -> smax_value = S64_MAX ; <S2SV_ModEnd> if ( src_known ) dst_reg -> var_off = tnum_rshift
<S2SV_ModStart> ( "clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( "execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n" , args -> num_cliprects ) ; return - EINVAL ; }
<S2SV_ModStart> * saddr = NULL , * final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> sk , flowi6_to_flowi ( & fl6 ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; final_p = fl6_update_dst ( & fl6 , <S2SV_ModEnd> opt , & final ) ; dst = ip6_dst_lookup_flow <S2SV_ModStart> ; icsk -> icsk_ext_hdr_len = 0 ; if ( opt ) icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen <S2SV_ModEnd> ; inet -> inet_dport = usin -> sin6_port ;
<S2SV_ModStart> struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; <S2SV_ModStart> newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen <S2SV_ModEnd> ; dccp_sync_mss ( newsk , dst_mtu ( dst )
<S2SV_ModStart> req , flowi6_to_flowi ( & fl6 ) ) ; rcu_read_lock ( ) ; final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst = ip6_dst_lookup_flow ( sk , & <S2SV_ModStart> ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; err = net_xmit_eval ( err ) ;
<S2SV_ModStart> & ( MSG_OOB ) ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> RCV_SHUTDOWN ) return 0 ; return err ; } <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg . smin_value ; smax_val = src_reg <S2SV_ModStart> ; break ; case BPF_LSH : if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown ( env , regs , insn <S2SV_ModStart> ; break ; case BPF_RSH : if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown ( env , regs , insn <S2SV_ModStart> , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
<S2SV_ModStart> do { if ( frags >= work_to_do ) { netdev_err ( vif -> dev , "Need<S2SV_blank>more<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } if ( <S2SV_ModStart> ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { netdev_err ( vif -> dev , "Too<S2SV_blank>many<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } memcpy ( <S2SV_ModStart> txp -> size > first -> size ) { netdev_err ( vif -> dev , "Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - frags ; } first -> <S2SV_ModStart> txp -> size ) > PAGE_SIZE ) ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n" , txp -> <S2SV_ModStart> "txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n" , txp -> offset , txp -> size ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> gso -> u . gso . size ) { netdev_err ( vif -> dev , "GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - EINVAL ; } if ( <S2SV_ModStart> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n" , gso -> <S2SV_ModStart> "Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n" , gso -> u . gso . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> unlikely ( work_to_do -- <= 0 ) ) { netdev_err ( vif -> dev , "Missing<S2SV_blank>extra<S2SV_blank>info\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return - EBADR ; } memcpy ( <S2SV_ModStart> vif -> tx . req_cons = ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> dev , "Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n" , extra . <S2SV_ModStart> vif -> dev , "Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n" , extra . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) ; if ( ! vif ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , "Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>" "req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> if ( unlikely ( work_to_do < 0 ) ) continue ; <S2SV_ModEnd> } ret = netbk_count_requests ( vif , & txreq <S2SV_ModStart> if ( unlikely ( ret < 0 ) ) continue ; <S2SV_ModEnd> idx += ret ; if ( unlikely ( txreq <S2SV_ModStart> txreq . size ) > PAGE_SIZE ) ) { netdev_err <S2SV_ModEnd> ( vif -> dev , "txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\n" , txreq . <S2SV_ModStart> ~ PAGE_MASK ) + txreq . size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue ; } index = pending_index ( <S2SV_ModStart> gso ) ) { kfree_skb ( skb ) ; <S2SV_ModEnd> continue ; } } page = xen_netbk_alloc_page ( netbk
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct rtattr * * tb , u32 <S2SV_ModStart> ; if ( IS_ERR ( algt ) ) return false ; * type |= algt -> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & CRYPTO_ALG_INTERNAL ; if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; u32 mask = 0 ; int err ; if ( ! <S2SV_ModStart> ( tb , & type , & mask ) ) return - EINVAL
<S2SV_ModStart> if ( type == ACL_TYPE_ACCESS ) { error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; } inode -> i_ctime = current_time ( inode
<S2SV_ModStart> ( tp ) ; inet_csk_delack_init ( sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> ; bool is_dir = d_is_dir ( old_dentry ) ; <S2SV_ModEnd> struct inode * source = old_dentry -> d_inode ; <S2SV_ModStart> unsigned max_links = new_dir -> i_sb -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> ) ; if ( error ) return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return error ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( p_inode -> i_fsnotify_mask & mask ) { struct name_snapshot name ; mask |= FS_EVENT_ON_CHILD ; take_dentry_name_snapshot ( & name , dentry ) <S2SV_ModEnd> ; if ( path ) ret = fsnotify ( <S2SV_ModStart> ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , name <S2SV_ModEnd> . name , 0 ) ; else ret = <S2SV_ModStart> , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , name . name , 0 ) ; release_dentry_name_snapshot ( & name <S2SV_ModEnd> ) ; } dput ( parent ) ; return
<S2SV_ModStart> tlb , vma , pmd , addr ) ) goto next ; } if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) goto next <S2SV_ModEnd> ; next = zap_pte_range ( tlb , vma , <S2SV_ModStart> pmd , addr , next , details ) ; next :
<S2SV_ModStart> >> PAGE_SHIFT ; continue ; } } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) mincore_unmapped_range ( vma , addr
<S2SV_ModStart> walk -> mm , pmd ) ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) goto again ; err =
<S2SV_ModStart> pmd_addr_end ( addr , end ) ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) ) continue ; ret = unuse_pte_range
<S2SV_ModStart> [ 24 ] ) ; out : kfree ( req ) ; kfree (
<S2SV_ModStart> * rsize ) { if ( * rsize >= 18 <S2SV_ModEnd> && rdesc [ 11 ] == 0x3c && rdesc
<S2SV_ModStart> { case USB_DEVICE_ID_KYE_ERGO_525V : if ( * rsize >= 75 <S2SV_ModEnd> && rdesc [ 61 ] == 0x05 && rdesc
<S2SV_ModStart> -> quirks & LG_RDESC ) && * rsize >= 91 <S2SV_ModEnd> && rdesc [ 83 ] == 0x26 && rdesc <S2SV_ModStart> -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 51 <S2SV_ModEnd> && rdesc [ 32 ] == 0x81 && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 31 <S2SV_ModEnd> && rdesc [ 29 ] == 0x05 && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 62 <S2SV_ModEnd> && rdesc [ 39 ] == 0x2a && rdesc
<S2SV_ModStart> * rsize ) { if ( * rsize >= 112 <S2SV_ModEnd> && rdesc [ 104 ] == 0x26 && rdesc
<S2SV_ModStart> alg_sock * ask2 ; struct hash_ctx * ctx2 ; bool more ; int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? crypto_ahash_export ( req , state ) : 0 ; release_sock ( sk ) <S2SV_ModEnd> ; if ( err ) return err ; err <S2SV_ModStart> = ask2 -> private ; ctx2 -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err = crypto_ahash_import ( & ctx2 -> req
<S2SV_ModStart> ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
<S2SV_ModStart> ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i = 0 ; i < HASHBIN_SIZE <S2SV_ModStart> ; i < HASHBIN_SIZE ; i ++ ) { while ( 1 ) { <S2SV_ModStart> & hashbin -> hb_queue [ i ] ) ; if ( ! queue ) break ; if ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } } } <S2SV_ModEnd> hashbin -> hb_current = NULL ; hashbin -> magic <S2SV_ModStart> ; if ( hashbin -> hb_type & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) <S2SV_ModStart> ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> kfree ( hashbin ) ; return 0 ; }
<S2SV_ModStart> dev , int voice , int value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
<S2SV_ModStart> voice , int chn ) { struct channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct key * * _dest_keyring ) { <S2SV_ModStart> * dest_keyring = * _dest_keyring , * authkey ; int ret ; <S2SV_ModStart> { key_get ( dest_keyring ) ; } else { bool do_perm_check = true ; <S2SV_ModStart> authkey -> sem ) ; if ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred <S2SV_ModStart> KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> "<S2SV_blank>[dk<S2SV_blank>%d]" , key_serial ( dest_keyring ) ) ; return 0
<S2SV_ModStart> key_type_keyring ) return ERR_PTR ( - EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ( ) ) ; if ( ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key ( ctx , dest_keyring , flags <S2SV_ModStart> { ret = 0 ; } else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put ( dest_keyring ) ; kleave ( <S2SV_ModStart> , NULL ) ; key_put ( key ) ; error_put_dest_keyring : key_put ( dest_keyring ) ; error : <S2SV_ModEnd> kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ERR_PTR
<S2SV_ModStart> if ( len > INT_MAX ) len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
<S2SV_ModStart> if ( size > INT_MAX ) size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
<S2SV_ModStart> ; case SIG ( 'E' , 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
<S2SV_ModStart> ; } if ( need_dev ) { if ( ! dev_name ||
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static unsigned long stack_maxrandom_size ( void ) { unsigned long <S2SV_ModEnd> max = 0 ; if ( ( current -> <S2SV_ModStart> ADDR_NO_RANDOMIZE ) ) { max = ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK ) << PAGE_SHIFT ; } return
<S2SV_ModStart> mct_u232_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct mct_u232_private * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , "expected<S2SV_blank>endpoint<S2SV_blank>missing\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> priv = kzalloc ( sizeof ( * priv ) <S2SV_ModStart> ) return - ENOMEM ; priv -> read_urb = <S2SV_ModEnd> serial -> port [ 1 ] -> interrupt_in_urb ;
<S2SV_ModStart> ; rcu_read_unlock ( ) ; return ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> le16_to_cpu ( udev -> descriptor . idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> out_buf ) return - ENOMEM ; if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2 ) count = DJREPORT_SHORT_LENGTH - 2
<S2SV_ModStart> ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif }
<S2SV_ModStart> ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
<S2SV_ModStart> , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
<S2SV_ModStart> error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
<S2SV_ModStart> 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
<S2SV_ModStart> -> flags = IFF_NOARP | IFF_POINTOPOINT ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; } } payload = NULL ; if ( plen <S2SV_ModEnd> ) { ret = - ENOMEM ; payload =
<S2SV_ModStart> nodemask_t * nodemask , unsigned long totalpages ) { long <S2SV_ModEnd> points ; if ( oom_unkillable_task ( p , mem
<S2SV_ModStart> } if ( pmd_trans_unstable ( pmd ) ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto out ; } ptep = pte_offset_map_lock <S2SV_ModStart> ptep ; if ( pte_none ( pte ) ) * vec = 0 <S2SV_ModEnd> ; else if ( pte_present ( pte ) ) <S2SV_ModStart> { swp_entry_t entry = pte_to_swp_entry ( pte ) ; * vec = ! ! non_swap_entry ( entry ) ; <S2SV_ModEnd> } vec ++ ; } pte_unmap_unlock ( ptep -
<S2SV_ModStart> long end , struct mm_walk * walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; walk -> private += nr <S2SV_ModEnd> ; return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> page ) ) ; if ( locked_vma ) { if ( page == check_page ) { mlock_vma_page ( page ) ; ret = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; } <S2SV_ModEnd> continue ; } if ( ptep_clear_flush_young_notify ( vma ,
<S2SV_ModStart> - ( addr + 5 ) ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif return len ; } <S2SV_ModEnd> b -> opcode = 0xe8 ; b -> delta
<S2SV_ModStart> 5 ) ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif return len ; } <S2SV_ModEnd> b -> opcode = 0xe9 ; b -> delta
<S2SV_ModStart> & miux , 0 , & miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & rw , 0 , & rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> , sock -> service_name_len , & service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & miux , 0 , & miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> & rw , 0 , & rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> nfc_llcp_local * local ) { u8 * gb_cur , version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> ; __be16 wks = cpu_to_be16 ( local -> local_wks <S2SV_ModStart> & version , 1 , & version_length ) ; if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> -> lto , 1 , & lto_length ) ; if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> & wks , 2 , & wks_length ) ; if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> -> miux , 0 , & miux_length ) ; if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; }
<S2SV_ModStart> , buffer -> cpumask ) ) return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if ( atomic_read ( & buffer -> resize_disabled
<S2SV_ModStart> IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page ) ; goto out ; }
<S2SV_ModStart> ( pskb_expand_head ( skb_out , 0 , size - skb_out <S2SV_ModEnd> -> len , GFP_ATOMIC ) < 0 ) {
<S2SV_ModStart> ) { unsigned long nr_pages , i ; size_t bytes , <S2SV_ModStart> ; i < nr_pages ; i ++ ) { bytes <S2SV_ModEnd> = min_t ( const size_t , cur_len , PAGE_SIZE <S2SV_ModStart> [ i ] , & it , 0 , bytes <S2SV_ModEnd> ) ; cur_len -= copied ; iov_iter_advance ( & <S2SV_ModStart> ; iov_iter_advance ( & it , copied ) ; if ( copied < bytes ) break ; } cur_len = save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) <S2SV_ModEnd> ; wdata -> sync_mode = WB_SYNC_ALL ; wdata ->
<S2SV_ModStart> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; first_source = source_mnt
<S2SV_ModStart> else { struct mount * n , * p ; bool done <S2SV_ModStart> p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE ; if ( IS_MNT_SHARED ( m
<S2SV_ModStart> ( p ) ; if ( ret < 0 && ! p -> skip_release_on_error
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root
<S2SV_ModStart> , int flags ) { struct btrfs_dir_item * di = NULL <S2SV_ModStart> if ( ! path ) return - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; goto out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( ! di ) { ret = - ENODATA ; goto out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item ( <S2SV_ModEnd> trans , root , path , btrfs_ino ( inode <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { goto out ; } if ( di && ( flags & XATTR_CREATE ) ) { ret = - EEXIST ; goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC ; goto out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out : btrfs_free_path ( path ) ; return
<S2SV_ModStart> res = - ENOTCONN ; goto exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> res = - ENOTCONN ; goto exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> family = AF_TIPC ; addr -> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
<S2SV_ModStart> -> vbd . bdev ; unsigned long secure ; struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX "access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> discard . nr_sectors , GFP_KERNEL , secure ) ; fail_response :
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe == NULL <S2SV_ModStart> - EIO ; if ( dvb_attach ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , & <S2SV_ModStart> ] . fe , & dw2104_ts2020_config , & d <S2SV_ModEnd> -> i2c_adap ) ) { info ( "Attached<S2SV_blank>RS2000/TS2020!" )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe == NULL <S2SV_ModStart> - EIO ; if ( dvb_attach ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , & <S2SV_ModStart> ] . fe , & dw2104_ts2020_config , & d <S2SV_ModEnd> -> i2c_adap ) ) { info ( "Attached<S2SV_blank>DS3000/TS2020!" )
<S2SV_ModStart> dvb_usb_device * d = i2c_get_adapdata ( adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( ! d ) return - ENODEV <S2SV_ModStart> if ( ! d ) return - ENODEV ; state = d -> priv ; <S2SV_ModStart> i2c_mutex ) < 0 ) return - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> 0 ] . addr ) { case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] = msg [ 0 ] . <S2SV_ModStart> ] . buf [ 0 ] + 0x36 ; state -> data [ 1 ] = 3 ; state -> data <S2SV_ModEnd> [ 2 ] = 0 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 0 , 0 ) < 0 ) err <S2SV_ModStart> ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; break ; case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] = 0x10 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0x10 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , 0 ) < 0 ) err <S2SV_ModStart> [ 0 ] . buf [ 1 ] = state -> data <S2SV_ModEnd> [ 0 ] ; msg [ 0 ] . <S2SV_ModStart> [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ; break ; default : state -> data [ 0 ] = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] = msg [ 0 ] . <S2SV_ModStart> ] = msg [ 0 ] . addr ; state -> data <S2SV_ModEnd> [ 2 ] = msg [ 0 ] . <S2SV_ModStart> [ 0 ] . len ; memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] , msg [ 0 ] . <S2SV_ModStart> len ) ; if ( dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , msg [ 0 ] . len + 3 <S2SV_ModStart> msg [ 0 ] . len + 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; } break ; case 2 : state -> data [ 0 ] = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] = msg [ 1 ] . <S2SV_ModStart> ] = msg [ 1 ] . len ; state -> data <S2SV_ModEnd> [ 3 ] = msg [ 0 ] . <S2SV_ModStart> [ 0 ] . addr ; memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] , msg [ 0 ] . <S2SV_ModStart> len ) ; if ( dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , msg [ 0 ] . len + 4 <S2SV_ModStart> msg [ 0 ] . len + 4 , state -> data <S2SV_ModEnd> , msg [ 1 ] . len + 1 <S2SV_ModStart> ( msg [ 1 ] . buf , & state -> data <S2SV_ModEnd> [ 1 ] , msg [ 1 ] . <S2SV_ModStart> ; break ; } mutex_unlock ( & d -> data_mutex ) ; mutex_unlock ( & d ->
<S2SV_ModStart> ( struct dw2102_state * ) d -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( "%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d" , __func__ , i , <S2SV_ModStart> ( i && ! state -> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; state -> initialized = 1 ; ret = dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 2 , NULL , 0 , 0 ) <S2SV_ModStart> 2 , NULL , 0 , 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int t220_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 50 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> ] = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe = dvb_attach <S2SV_ModStart> ( cxd2820r_attach , & cxd2820r_config , & d -> i2c_adap , NULL ) ; if ( adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe != NULL <S2SV_ModStart> NULL ) { if ( dvb_attach ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ 0 ] . fe , 0x60 <S2SV_ModStart> 0 ] . fe , 0x60 , & d <S2SV_ModEnd> -> i2c_adap , & tda18271_config ) ) { info
<S2SV_ModStart> struct dw2102_state * state = d -> priv ; <S2SV_ModEnd> struct i2c_adapter * i2c_adapter ; struct i2c_client * client <S2SV_ModStart> } ; struct ts2020_config ts2020_config = { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] = 1 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] = 0 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] = 1 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 1 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw <S2SV_ModStart> = 0x51 ; if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , 0 ) < 0 ) err <S2SV_ModStart> , 0 ) < 0 ) err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex
<S2SV_ModStart> -> list ) ; kfree ( pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> * * new_cred ) { struct cred * cred ; int err = - ENOMEM <S2SV_ModStart> ; cred = prepare_creds ( ) ; if ( cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else * new_cred = cred ; } return err <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( src ) ; flush_spe_to_thread ( src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
<S2SV_ModStart> struct iovec * ) _iov ; size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> unlikely ( total_len == 0 ) ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> struct pipe_buf_operations * ops = buf -> ops ; size_t chars = buf -> len ; size_t written ; int error <S2SV_ModEnd> ; if ( chars > total_len ) chars = <S2SV_ModStart> ret ) ret = error ; break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; } ret += chars ; buf
<S2SV_ModStart> } mark_discard_range_all ( sbi ) ; f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> <S2SV_null> <S2SV_null> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount <S2SV_ModStart> __drop_discard_cmd ( sbi ) ; __wait_discard_cmd ( sbi , ! umount <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , & cpc ) ; } f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( iova < mem -> iova || length > mem -> length || iova > mem -> iova + mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default : return - EFAULT ; }
<S2SV_ModStart> * sdp = GFS2_SB ( inode ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> ptrs_per_blk ; const unsigned end_of_metadata = height - 1 ; int ret <S2SV_ModStart> ptr ++ = cpu_to_be64 ( bn ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , "Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n" ) ; clear_buffer_zeronew ( bh_map ) ; } }
<S2SV_ModStart> ; struct buffer_head * dibh ; int error ; unsigned int nr_blks ; sector_t lblock = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if ( offset + len <S2SV_ModEnd> > inode -> i_size && ! ( mode & <S2SV_ModStart> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) i_size_write ( inode , offset + len ) ; mark_inode_dirty ( inode ) ; out : brelse ( dibh ) ; <S2SV_ModEnd> return error ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 1 ) >> sdp -> sd_sb . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> } max_bytes = bytes ; calc_max_reserv ( ip , ( len > max_chunk_size ) ? max_chunk_size :
<S2SV_ModStart> = - EPERM ; if ( ! new_idmap_permitted ( file ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static bool new_idmap_permitted ( const struct file * file , <S2SV_ModStart> ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid )
<S2SV_ModStart> type ) { struct hexline * hx ; u8 * buf ; int ret , pos = 0 ; u16 cpu_cs_register = cypress [ type ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 ) err ( "could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU." ) ; <S2SV_ModStart> "firmware<S2SV_blank>download<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>%d" , pos , ret ) ; kfree ( buf <S2SV_ModEnd> ) ; return ret ; } if ( ret <S2SV_ModStart> ; } if ( ret == 0 ) { buf [ 0 ] = 0 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) != 1 ) { err ( <S2SV_ModStart> } else ret = - EIO ; kfree ( buf <S2SV_ModEnd> ) ; return ret ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> activation_params . nfca_poll_iso_dep ; nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ) <S2SV_ModEnd> ; pr_debug ( "rats_res_len<S2SV_blank>%d\\n" , nfca_poll -> rats_res_len ) <S2SV_ModStart> -> activation_params . nfcb_poll_iso_dep ; nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ) <S2SV_ModEnd> ; pr_debug ( "attrib_res_len<S2SV_blank>%d\\n" , nfcb_poll -> attrib_res_len )
<S2SV_ModStart> ; data += 2 ; nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n" , nfca_poll -> sens_res ,
<S2SV_ModStart> __u8 * data ) { nfcb_poll -> sensb_res_len = min_t ( __u8 , * data ++ , NFC_SENSB_RES_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "sensb_res_len<S2SV_blank>%d\\n" , nfcb_poll -> sensb_res_len )
<S2SV_ModStart> = * data ++ ; nfcf_poll -> sensf_res_len = min_t ( __u8 , * data ++ , NFC_SENSF_RES_MAXSIZE ) <S2SV_ModEnd> ; pr_debug ( "bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\n" , nfcf_poll -> bit_rate ,
<S2SV_ModStart> MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ; if ( err ) goto out ; <S2SV_ModEnd> if ( msg -> msg_name ) { struct sockaddr_vm
<S2SV_ModStart> , __func__ ) ; return ; } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n" , __func__ ) ; return ; } if ( <S2SV_ModStart> "%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n" , __func__ ) ; } else if ( ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 <S2SV_ModEnd> ) ; command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up
<S2SV_ModStart> ; ptr = ( void * ) val ; <S2SV_ModEnd> memset ( ptr , 0 , size ) ;
<S2SV_ModStart> ) ; addr = page_address ( page ) ; <S2SV_ModEnd> memset ( addr , 0 , size ) ;
<S2SV_ModStart> ext4_put_nojournal ( handle ) ; return 0 ; } err = handle -> h_err ; if ( ! handle -> h_transaction ) { rc = jbd2_journal_stop ( handle ) ; return err ? err : rc <S2SV_ModEnd> ; } sb = handle -> h_transaction -> t_journal <S2SV_ModStart> sb = handle -> h_transaction -> t_journal -> j_private <S2SV_ModEnd> ; rc = jbd2_journal_stop ( handle ) ; if
<S2SV_ModStart> * child , struct task_struct * new_parent ) { __ptrace_link ( child , new_parent , current_cred ( ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> } ufs -> lower_namelen = statfs . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> & resp_buftype , flags , & rsp_iov ) ; <S2SV_ModEnd> rsp = ( struct smb2_write_rsp * ) rsp_iov . <S2SV_ModStart> io_parms -> offset , * nbytes ) ; } cifs_small_buf_release ( req ) ;
<S2SV_ModStart> ) ; for ( i = 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i ++ ) { ret = serdes_phy_create
<S2SV_ModStart> ] ; for ( i = 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i ++ ) { struct serdes_macro *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer <S2SV_ModStart> * pipe , struct pipe_buffer * buf ) { return try_get_page <S2SV_ModEnd> ( buf -> page ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> & ( opipe -> buffers - 1 ) ; if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe -> bufs + nbuf ; *
<S2SV_ModStart> -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf = * ibuf ; obuf -> flags
<S2SV_ModStart> retry ; } if ( flags & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags & FOLL_TOUCH ) { if (
<S2SV_ModStart> ) ret = - EBUSY ; } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl ) ; lock_page ( page )
<S2SV_ModStart> ( * page ) ) goto unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret = 0 ; unmap : pte_unmap
<S2SV_ModStart> = pte_page ( huge_ptep_get ( pte ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> < exec_size ) { DRM_ERROR ( "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> { signo = SIGCHLD ; err = 0 ; if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> interface_to_usbdev ( usbif ) ; int brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness = data [ 4 ] ; <S2SV_ModStart> , "Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n" , data [ 4 ] ) ; ret = - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> interface_to_usbdev ( usbif ) ; int current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile = data [ 7 ] ; <S2SV_ModStart> , "Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n" , data [ 7 ] ) ; ret = - EIO ; goto out ; } ret = <S2SV_ModEnd> snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile <S2SV_ModStart> buf , PAGE_SIZE , "%d\\n" , current_profile ) ; out : kfree ( data ) ; return ret ;
<S2SV_ModStart> usbif ) ; const char * macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( <S2SV_ModStart> dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } switch ( data [ 0 ] ) <S2SV_ModStart> , "K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n" , data [ 0 ] ) ; ret = - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( * req ) ) return - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
<S2SV_ModStart> struct file * file = vma -> vm_file ; * prev = vma ; <S2SV_ModStart> # ifdef CONFIG_SWAP if ( ! file ) { <S2SV_ModEnd> force_swapin_readahead ( vma , start , end ) ; <S2SV_ModStart> ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma , start , end , file <S2SV_ModStart> file ) ) ) { return 0 ; } <S2SV_ModEnd> start = ( ( start - vma -> vm_start
<S2SV_ModStart> & balloon_mutex ) ; return 0 ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
<S2SV_ModStart> ) ; } if ( credit < 0 ) { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; state = decrease_reservation ( n_pages , GFP_BALLOON ) ; if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; } <S2SV_ModEnd> state = update_schedule ( state ) ; mutex_unlock (
<S2SV_ModStart> ) ; if ( err ) goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> ; filp -> f_pos ++ ; case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> i_ino ) { printk ( KERN_ERR "hfs:<S2SV_blank>walked<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>dir\\n" ) ; err = - EIO ; goto out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {
<S2SV_ModStart> futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
<S2SV_ModStart> USB_DT_SECURITY , ( void * * ) & secd , sizeof ( * secd )
<S2SV_ModStart> nr = pagevec_count ( pvec ) ; int delta_munlocked = - nr <S2SV_ModStart> continue ; else __munlock_isolation_failed ( page ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> -> pages [ i ] = NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;
<S2SV_ModStart> ; port_subs_info_init ( & new_port -> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> ; new_port -> addr . port = num ; sprintf ( new_port -> name , "port-%d" , num ) ; <S2SV_ModStart> ; mutex_unlock ( & client -> ports_mutex ) ; <S2SV_ModEnd> return new_port ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( current -> active_mm != mm ) { smp_mb ( ) ; goto out ; } <S2SV_ModEnd> if ( ! current -> mm ) { leave_mm <S2SV_ModStart> ) { leave_mm ( smp_processor_id ( ) ) ; smp_mb ( ) ;
<S2SV_ModStart> mm ) { if ( current -> mm ) { __flush_tlb_one ( start ) ; } else { leave_mm ( smp_processor_id ( ) ) ; smp_mb ( ) ; } <S2SV_ModEnd> } if ( cpumask_any_but ( mm_cpumask ( mm )
<S2SV_ModStart> ] ; int err ; BT_DBG ( "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD
<S2SV_ModStart> ; if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
<S2SV_ModStart> int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
<S2SV_ModStart> < ds ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> long copied = 0 ; lock_sock ( sk ) ; msg -> msg_namelen = 0
<S2SV_ModStart> t_prefer_loopback ) { trans = & rds_loop_transport ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ;
<S2SV_ModStart> iov_page ) ; out_iov = in_iov + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
<S2SV_ModStart> , GFP_KERNEL ) ; if ( pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> = kzalloc ( sizeof ( struct pipe_buffer ) * pipe_bufs , GFP_KERNEL ) ; } <S2SV_ModEnd> if ( pipe -> bufs ) { init_waitqueue_head ( <S2SV_ModStart> -> w_counter = 1 ; pipe -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( & pipe -> mutex ) ; <S2SV_ModStart> pipe -> mutex ) ; return pipe ; } free_uid ( user ) ;
<S2SV_ModStart> ( struct pipe_inode_info * pipe ) { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> ret = - EPERM ; goto out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> * sizeof ( struct pipe_buffer ) ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> * tp = tcp_sk ( sk ) ; u32 count , <S2SV_ModStart> HZ ; if ( now != challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; challenge_timestamp = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK )
<S2SV_ModStart> struct inode * inode ; struct path path ; uid_t check_ruid ; <S2SV_ModStart> ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid <S2SV_ModStart> "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" "known<S2SV_blank>incompatibilities\\n" ) ; goto out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }
<S2SV_ModStart> ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid <S2SV_ModStart> fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; * check_ruid = 0 <S2SV_ModStart> ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1
<S2SV_ModStart> private ; struct vm_area_struct * vma = v ; if ( ! IS_ERR ( vma ) )
<S2SV_ModStart> ( ref , struct ipmi_user , refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
<S2SV_ModStart> struct ipmi_user * user ) { _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put ( & user -> refcount ,
<S2SV_ModStart> * udev , struct usb_interface * intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_ModStart> alt = uas_find_uas_alt_setting ( intf ) ; if ( ! alt ) return - ENODEV ; return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> . expires += incr ; timer -> it_overrun += 1LL <S2SV_ModEnd> << i ; delta -= incr ; } }
<S2SV_ModStart> ! timr ) return - EINVAL ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer ( timr , flags ) ; return
<S2SV_ModStart> -> it_interval ) return ; timr -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer , timer -> base -> get_time
<S2SV_ModStart> REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += <S2SV_ModEnd> kc -> timer_forward ( timr , now ) ;
<S2SV_ModStart> kclock = kc ; new_timer -> it_overrun = - 1LL <S2SV_ModEnd> ; if ( event ) { rcu_read_lock ( )
<S2SV_ModStart> ) ; } # endif timr -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer , now , timr -> it_interval
<S2SV_ModStart> timr -> it_overrun ; timr -> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr -> it_requeue_pending ; info -> si_overrun <S2SV_ModStart> ; ++ timr -> it_requeue_pending ; info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer ( timr , flags ) ;
<S2SV_ModStart> : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return - EINVAL ; * vm_flags &= <S2SV_ModStart> : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return - EINVAL ; * vm_flags &=
<S2SV_ModStart> chan ; BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
<S2SV_ModStart> log_file ) { filep = d -> log_file ; d -> log_file = eventfp ;
<S2SV_ModStart> sk ; struct irda_sock * self ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> endif struct cred * new ; int ret ; p -> replacement_session_keyring = NULL ;
<S2SV_ModStart> ( ! unqueue_me ( & q ) ) goto out <S2SV_ModEnd> ; ret = - ETIMEDOUT ; if ( to <S2SV_ModStart> ( to && ! to -> task ) goto out <S2SV_ModEnd> ; if ( ! signal_pending ( current ) ) <S2SV_ModStart> ; if ( ! signal_pending ( current ) ) goto retry ; <S2SV_ModEnd> ret = - ERESTARTSYS ; if ( ! abs_time <S2SV_ModStart> - ERESTARTSYS ; if ( ! abs_time ) goto out <S2SV_ModEnd> ; restart = & current_thread_info ( ) -> restart_block <S2SV_ModStart> flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if ( to ) { hrtimer_cancel (
<S2SV_ModStart> futex_q * q ) { struct futex_hash_bucket * hb <S2SV_ModEnd> ; hb = hash_futex ( & q -> key
<S2SV_ModStart> { spin_unlock ( & hb -> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> < sizeof ( tfrc ) ) return - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) )
<S2SV_ModStart> retval ; retval = xfs_attr_shortform_remove ( args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX
<S2SV_ModStart> ) return tmp ; } if ( in ) <S2SV_ModEnd> dev -> in_pipe = usb_rcvbulkpipe ( udev , in <S2SV_ModStart> in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in ) { dev -> iso_in =
<S2SV_ModStart> vs_ie = ( struct ieee_types_header * ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
<S2SV_ModStart> , len ) ; if ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> beacon . tail_len ) ; if ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> rate_ie + 1 , rate_ie -> len ) ; }
<S2SV_ModStart> ; if ( vendor_ie ) { wmm_ie = vendor_ie ; if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return
<S2SV_ModStart> if ( page ) put_page ( page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> pending_idx ] ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx , u8 status <S2SV_ModStart> make_tx_response ( vif , & pending_tx_info -> req , status <S2SV_ModEnd> ) ; index = pending_index ( netbk -> pending_prod
<S2SV_ModStart> u16 * ) skb -> data ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo = skb_shinfo ( skb ) ; <S2SV_ModStart> status ; if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( frag_get_pending_idx ( & shinfo -> frags <S2SV_ModStart> i ++ ) { int j , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ <S2SV_ModStart> ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; continue ; } xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err ) continue ; pending_idx = * <S2SV_ModStart> -> data ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> j ] ) ; xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> ; } else { xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> ; u8 * buf = dctx -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> * dst = dctx -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> , xsave , 0 , - 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> fpu ) ; if ( using_compacted_format ( ) ) { <S2SV_ModStart> fpu -> state . xsave , buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user ( & fpu -> state . <S2SV_ModStart> state . xsave , buf_fx , state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }
<S2SV_ModStart> ; devinfo . n_subdevs = dev -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . driver_name , dev -> driver -> <S2SV_ModStart> dev -> driver -> driver_name , COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo . board_name , dev -> board_name ,
<S2SV_ModStart> ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> __local_bh_enable ( unsigned int cnt ) { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> pin ) { spin_lock ( & pin_lock ) ; hlist_del_init ( & pin -> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin -> s_list ) ; spin_unlock (
<S2SV_ModStart> struct user_element * ue ; int idx , err <S2SV_ModEnd> ; if ( info -> count < 1 ) <S2SV_ModStart> , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM <S2SV_ModEnd> ; memcpy ( & kctl . id , &
<S2SV_ModStart> 2 ; } } else { uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp , valuelen ) ; nblks += dblocks
<S2SV_ModStart> ; args -> rmtblkcnt2 = args -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> ; args -> rmtblkcnt = args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
<S2SV_ModStart> -> rmtblkcnt2 = args -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen <S2SV_ModEnd> = 0 ; } retval = xfs_attr3_leaf_add ( blk <S2SV_ModStart> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2
<S2SV_ModStart> xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
<S2SV_ModStart> ; name_rmt -> valuelen = cpu_to_be32 ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf ( args -> trans , bp
<S2SV_ModStart> ; name_rmt -> valuelen = cpu_to_be32 ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf ( args -> trans , bp1
<S2SV_ModStart> , args -> namelen ) == 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( name_rmt -> valuelen ) ; args <S2SV_ModStart> = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if ( args -> flags & ATTR_KERNOVAL <S2SV_ModStart> flags & ATTR_KERNOVAL ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 ; } if ( args -> <S2SV_ModStart> 0 ; } if ( args -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR ( ERANGE ) ; } args <S2SV_ModStart> ( ERANGE ) ; } args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; args -> index = probe ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> <S2SV_ModEnd> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( <S2SV_ModStart> ( args -> dp -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; return XFS_ERROR ( EEXIST ) ; }
<S2SV_ModStart> ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args .
<S2SV_ModStart> * dst = args -> value ; int valuelen <S2SV_ModEnd> ; int nmap ; int error ; int blkcnt <S2SV_ModStart> ! ( args -> flags & ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
<S2SV_ModStart> ; blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen <S2SV_ModEnd> ) ; error = xfs_bmap_first_unused ( args -> trans <S2SV_ModStart> = args -> rmtblkcnt ; valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; while ( valuelen > 0 ) { struct
<S2SV_ModStart> entry ; size_t size ; int error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ea_idebug
<S2SV_ModStart> * bh = NULL ; int error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ea_idebug
<S2SV_ModStart> * s = & bs -> s ; struct mb2_cache_entry <S2SV_ModEnd> * ce = NULL ; int error = 0 <S2SV_ModStart> = NULL ; int error = 0 ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; # <S2SV_ModStart> ENOSPC ; if ( s -> base ) { <S2SV_ModEnd> BUFFER_TRACE ( bs -> bh , "get_write_access" ) ; <S2SV_ModStart> -> h_refcount == cpu_to_le32 ( 1 ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> ea_bdebug ( bs -> bh , "modifying<S2SV_blank>in-place" ) ; <S2SV_ModStart> b_data ; unlock_buffer ( bs -> bh ) ; <S2SV_ModEnd> ea_bdebug ( bs -> bh , "cloning" ) ; <S2SV_ModStart> ) goto cleanup_dquot ; lock_buffer ( new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> ; if ( error ) goto cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; ce = NULL ; } else <S2SV_ModStart> = 0 ; cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; brelse ( new_bh ) ; if
<S2SV_ModStart> * inode , struct ext4_xattr_header * header , struct mb2_cache_entry <S2SV_ModEnd> * * pce ) { __u32 hash = le32_to_cpu <S2SV_ModStart> = le32_to_cpu ( header -> h_hash ) ; struct mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if <S2SV_ModStart> , "looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]" , ( int ) hash ) ; ce = mb2_cache_entry_find_first ( ext4_mb_cache , <S2SV_ModEnd> hash ) ; while ( ce ) { struct <S2SV_ModStart> ( ce ) { struct buffer_head * bh ; <S2SV_ModEnd> bh = sb_bread ( inode -> i_sb , ce <S2SV_ModStart> ; } brelse ( bh ) ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ) ; } return NULL ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , struct buffer_head * bh ) { <S2SV_ModStart> ( BHDR ( bh ) -> h_hash ) ; int error ; error = mb2_cache_entry_create ( ext4_mb_cache , GFP_NOFS , hash , bh -> b_blocknr ) ; if ( error ) { if ( error == - EBUSY ) ea_bdebug ( bh , "already<S2SV_blank>in<S2SV_blank>cache" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh , "inserting<S2SV_blank>[%x]" , ( int ) <S2SV_ModStart> , "inserting<S2SV_blank>[%x]" , ( int ) hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> struct mb2_cache * ext4_xattr_create_cache ( void ) { return mb2_cache_create ( <S2SV_ModEnd> HASH_BUCKET_BITS ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) { if ( cache ) mb2_cache_destroy <S2SV_ModEnd> ( cache ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * inode , struct buffer_head * bh ) { int error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( bh , "get_write_access" ) ; error <S2SV_ModStart> -> h_refcount == cpu_to_le32 ( 1 ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; ea_bdebug ( bh , "refcount<S2SV_blank>now=0;<S2SV_blank>freeing" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh ( bh ) ; unlock_buffer ( <S2SV_ModStart> -> h_refcount , - 1 ) ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block (
<S2SV_ModStart> verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; <S2SV_ModEnd> return PTR_ERR ( map ) ; } insn [
<S2SV_ModStart> ; newnp -> opt = NULL ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> = np -> rxopt . all ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; int ret , i ; struct rb_node * <S2SV_ModStart> << ( i * 8 ) ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> } write_unlock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long tmp ; char * p = <S2SV_ModStart> node -> nd_set_attributes ) ) return - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> && cluster -> cl_local_node != node -> nd_num ) { ret = - EBUSY ; goto out ; } if ( tmp && ! cluster -> cl_has_local ) { ret = o2net_start_listening ( node ) ; if ( ret ) goto out ; } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> to_o2nm_node ( item ) ; struct o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long tmp ; char * p = <S2SV_ModStart> node -> nd_set_attributes ) ) return - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> } write_unlock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ;
<S2SV_ModStart> svm -> vcpu ) + 2 ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm -> vcpu , & msr )
<S2SV_ModStart> ; msr . host_initiated = false ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu , & msr ) != 0 )
<S2SV_ModStart> -> lsm [ lsm_rule ] . rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
<S2SV_ModStart> ; } mntget ( path -> mnt ) ; nd -> last_type = LAST_BIND ;
<S2SV_ModStart> goto error ; id = kcontrol -> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
<S2SV_ModStart> & oplock , & fileHandle , xid ) ; switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; if ( ( rc == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if ( rc == - ENOENT ) <S2SV_ModEnd> { rc = 0 ; direntry -> d_time =
<S2SV_ModStart> tp -> packets_out - tp -> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
<S2SV_ModStart> = arch_mmap_rnd ( ) ; mm -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ; if ( mmap_is_legacy ( ) ) { mm
<S2SV_ModStart> ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ; task_lock ( p ) ; <S2SV_ModStart> ) ret = p -> io_context -> ioprio ; task_unlock ( p ) ;
<S2SV_ModStart> t_prefer_loopback ) { trans = & rds_loop_transport ; } <S2SV_ModEnd> } conn -> c_trans = trans ; ret =
<S2SV_ModStart> return bdev ; fail : ext3_msg ( sb , KERN_ERR ,
<S2SV_ModStart> options != ',' ) { ext3_msg ( sb , KERN_ERR ,
<S2SV_ModStart> DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
<S2SV_ModStart> free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) &&
<S2SV_ModStart> ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , "interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> ( & intf -> dev , "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; err = - EINVAL ;
<S2SV_ModStart> . tcpv_minrtt = ca -> base_rtt , } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> = ca -> sum_rtt ; do_div ( t , info . tcpv_rttcnt ) ; info . tcpv_rtt = t ; } <S2SV_ModEnd> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info
<S2SV_ModStart> retry ; } if ( flags & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags & FOLL_TOUCH ) { if (
<S2SV_ModStart> ) ret = - EBUSY ; } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl ) ; lock_page ( page )
<S2SV_ModStart> ( * page ) ) goto unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret = 0 ; unmap : pte_unmap
<S2SV_ModStart> = pte_page ( huge_ptep_get ( pte ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> unsigned long addr , int avoid_reserve ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> hstate_vma ( vma ) ; struct page * page <S2SV_ModEnd> ; long chg ; chg = vma_needs_reservation ( h <S2SV_ModStart> VM_FAULT_OOM ) ; if ( chg ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS <S2SV_ModStart> NUMA_NO_NODE ) ; if ( ! page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) ; return ERR_PTR ( - VM_FAULT_SIGBUS <S2SV_ModStart> } set_page_private ( page , ( unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation ( h , vma , addr
<S2SV_ModStart> int nid = page_to_nid ( page ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private ( page ) ; set_page_private ( <S2SV_ModStart> ) ; } spin_unlock ( & hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> chg < 0 ) return chg ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) ) return - ENOSPC ; ret <S2SV_ModStart> ) ; if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping <S2SV_ModEnd> -> private_list , from , to ) ; return
<S2SV_ModStart> inode -> i_mapping -> private_list , offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; spin_unlock ( & inode -> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg - freed ) ) ; hugetlb_acct_memory
<S2SV_ModStart> vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve ) ; } } } <S2SV_null> <S2SV_null>
<S2SV_ModStart> h , vma , address ) ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock ( & mapping -> i_mmap_mutex ) ;
<S2SV_ModStart> void pid_ns_release_proc ( struct pid_namespace * ns ) { kern_unmount <S2SV_ModEnd> ( ns -> proc_mnt ) ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> { switch ( type ) { case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw ) ; break ; case BPF_TYPE_MAP : raw = <S2SV_ModEnd> bpf_map_inc ( raw , true ) ; break ;
<S2SV_ModStart> ( inode -> i_private , * type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> ( IS_ERR ( map ) ) return map ; map =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> struct bpf_map * <S2SV_ModEnd> bpf_map_inc ( struct bpf_map * map , bool uref <S2SV_ModStart> struct bpf_map * map , bool uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec ( & map -> refcnt ) ; return ERR_PTR ( - EBUSY ) ; } <S2SV_ModEnd> if ( uref ) atomic_inc ( & map -> <S2SV_ModStart> ) atomic_inc ( & map -> usercnt ) ; return map ;
<S2SV_ModStart> ( IS_ERR ( prog ) ) return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput ( f ) ; return prog
<S2SV_ModStart> ( f ) ; return - E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_ModEnd> fdput ( f ) ; next_insn : insn ++
<S2SV_ModStart> ) ; else ci -> hcd = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
<S2SV_ModStart> ( ! dir_emit_dots ( file , ctx ) ) goto out <S2SV_ModEnd> ; pos = 2 ; for ( first_entry ( <S2SV_ModStart> sysctl_head_finish ( h ) ; break ; } } out :
<S2SV_ModStart> sk ; BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
<S2SV_ModStart> = new_dir -> i_sb -> s_max_links ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> ) return 0 ; error = may_delete ( old_dir
<S2SV_ModStart> [ dst_byte_offset ++ ] |= ( src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0 ; break ; } src_byte_offset ++
<S2SV_ModStart> response_data ; int rc = 0 ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16 params , byte_count ; cFYI (
<S2SV_ModStart> - ENOMEM ; ar2 -> udev = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> ] = usb_ifnum_to_if ( udev , 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> ar2 -> intf [ 1 ] -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> ( ar2 ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; ar2 -> channel_mask = channel_mask ; ar2 -> <S2SV_ModStart> -> channel_mask ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( udev , ar2 -> phys , <S2SV_ModStart> & ati_remote2_attr_group ) ; if ( r ) goto fail3 <S2SV_ModEnd> ; r = ati_remote2_input_init ( ar2 ) ; if <S2SV_ModStart> ( ar2 ) ; if ( r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( interface , ar2 ) ; interface <S2SV_ModStart> interface -> needs_remote_wakeup = 1 ; return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 ) ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [
<S2SV_ModStart> * addr , int addr_len ) { struct sockaddr_rc sa <S2SV_ModEnd> ; struct sock * sk = sock -> sk <S2SV_ModStart> sock * sk = sock -> sk ; int len , err = 0 <S2SV_ModEnd> ; if ( ! addr || addr -> sa_family <S2SV_ModStart> -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> ( & rfcomm_sk_list . lock ) ; if ( sa . rc_channel && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <S2SV_ModEnd> rc_bdaddr ) ) { err = - EADDRINUSE ; <S2SV_ModStart> rfcomm_pi ( sk ) -> src , & sa . <S2SV_ModEnd> rc_bdaddr ) ; rfcomm_pi ( sk ) -> channel <S2SV_ModStart> ) ; rfcomm_pi ( sk ) -> channel = sa . rc_channel <S2SV_ModEnd> ; sk -> sk_state = BT_BOUND ; } write_unlock
<S2SV_ModStart> -> parent_slot ; cursor = shortcut -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> ; cursor = ptr ; } BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node = assoc_array_ptr_to_node ( cursor ) ;
<S2SV_ModStart> * client , struct ion_handle * handle ) { <S2SV_ModEnd> BUG_ON ( client != handle -> client ) ; <S2SV_ModStart> ; mutex_lock ( & client -> lock ) ; ion_free_nolock ( client , handle <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock ) <S2SV_ModStart> ; mutex_unlock ( & client -> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * ion_handle_get_by_id ( struct ion_client * client <S2SV_ModStart> ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock ) <S2SV_ModStart> ( & client -> lock ) ; return handle <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ion_handle_put ( struct ion_handle * handle ) { <S2SV_ModStart> ( & client -> lock ) ; ret = ion_handle_put_nolock ( handle <S2SV_ModEnd> ) ; mutex_unlock ( & client -> lock )
<S2SV_ModStart> case ION_IOC_FREE : { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , data . handle . handle ) <S2SV_ModStart> ) ; if ( IS_ERR ( handle ) ) { mutex_unlock ( & client -> lock ) ; return PTR_ERR ( handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break ; } case ION_IOC_SHARE : case
<S2SV_ModStart> insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; }
<S2SV_ModStart> { unsigned int bytes = PAGE_SIZE - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] )
<S2SV_ModStart> case MSR_MTRRdefType : case MSR_IA32_CR_PAT : return true ; <S2SV_ModEnd> } return false ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; read_lock ( & tasklist_lock ) ; if ( child -> ptrace && child -> parent == current ) { WARN_ON ( child -> state == __TASK_TRACED ) ; if ( ignore_state || ptrace_freeze_traced ( child ) ) ret = 0 <S2SV_ModEnd> ; } read_unlock ( & tasklist_lock ) ; if <S2SV_ModStart> ; if ( ! ret && ! ignore_state ) { if ( ! wait_task_inactive ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = - ESRCH ; } } <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> crypto_init_skcipher_ops_ablkcipher ( tfm ) ; skcipher -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher -> encrypt = alg -> encrypt ;
<S2SV_ModStart> , int reason , unsigned int esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> , handler [ reason ] , esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , regs , & info , 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> inode = d_inode ( fh -> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> ; fh_drop_write ( fh ) ; nfserr = fh_getattr <S2SV_ModStart> ( argp -> acl_default ) ; return nfserr ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh ) ; out_errno : nfserr =
<S2SV_ModStart> inode = d_inode ( fh -> fh_dentry ) ; <S2SV_ModEnd> error = fh_want_write ( fh ) ; if ( <S2SV_ModStart> ) ; if ( error ) goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh ) ; out_errno : nfserr =
<S2SV_ModStart> inode = d_inode ( dentry ) ; if ( <S2SV_ModEnd> S_ISDIR ( inode -> i_mode ) ) flags = <S2SV_ModStart> if ( host_error < 0 ) goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if ( host_error < 0 ) goto <S2SV_ModStart> ) ; if ( host_error < 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( S_ISDIR ( inode -> i_mode ) <S2SV_ModStart> ( inode -> i_mode ) ) { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl )
<S2SV_ModStart> truncate = 0 ; int ret = 0 ; char * p ; int len ; <S2SV_ModStart> . NM . flags ) ; break ; } len = rr -> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) { truncate = 1 ; break <S2SV_ModStart> ) { truncate = 1 ; break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> u . NM . name , <S2SV_ModStart> , rr -> u . NM . name , len ) ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ; case SIG ( 'R' , 'E'
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_cipher rcipher ; strncpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher . blocksize = alg -> cra_blocksize
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_comp rcomp ; strncpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS
<S2SV_ModStart> * ualg , struct sk_buff * skb ) { strncpy ( ualg -> cru_name , <S2SV_ModEnd> alg -> cra_name , sizeof ( ualg -> cru_name <S2SV_ModStart> , sizeof ( ualg -> cru_name ) ) ; strncpy ( ualg -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name <S2SV_ModStart> , sizeof ( ualg -> cru_driver_name ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name , module_name ( alg -> cra_module <S2SV_ModStart> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> cru_flags = alg -> cra_flags ; <S2SV_ModStart> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; strncpy ( rl . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL
<S2SV_ModStart> end ) { loff_t offset ; int error ; struct file * f ; <S2SV_ModStart> VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; f = vma -> vm_file ; if ( ! f || ! f -> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> host ) { return - EINVAL <S2SV_ModStart> loff_t ) vma -> vm_pgoff << PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> mm -> mmap_sem ) ; error = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - <S2SV_ModStart> FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - start ) ; fput ( f
<S2SV_ModStart> level = rfcomm_pi ( sk ) -> sec_level ; sec . key_size = 0 ;
<S2SV_ModStart> ) ; if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ; <S2SV_ModEnd> q -> root_blkg = blkg ; q -> root_rl
<S2SV_ModStart> index ) ; BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> = - ENOMEM ; interface = intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if (
<S2SV_ModStart> false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if ( r -> CRn == 14 <S2SV_ModStart> -> Op2 & 7 ) ; } else { return false <S2SV_ModEnd> ; } if ( ! pmu_counter_idx_valid ( vcpu ,
<S2SV_ModStart> . start ) return - EINVAL ; entries = kmalloc_array ( cmap -> len , sizeof ( * entries ) <S2SV_ModEnd> , GFP_KERNEL ) ; if ( ! entries )
<S2SV_ModStart> struct iov_iter i ; int ret ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; fail :
<S2SV_ModStart> ) ; if ( ret < 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev <S2SV_ModEnd> ) ; return ret ; } kvm_get_kvm ( kvm
<S2SV_ModStart> sockfd_put ( csock ) ; return err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
<S2SV_ModStart> += delta ; else if ( i > pos + delta && i + insn -> off + 1 <= pos + delta <S2SV_ModEnd> ) insn -> off -= delta ; } }
<S2SV_ModStart> NULL ; unsigned char * symlink ; int err <S2SV_ModEnd> ; unsigned char * p = kmap ( page <S2SV_ModStart> ; struct udf_inode_info * iinfo ; uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> , pos ) ; if ( ! bh ) { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> symlink = bh -> b_data ; } udf_pc_to_char ( <S2SV_ModStart> ; unlock_page ( page ) ; return 0 ; out_unlock_inode <S2SV_ModEnd> : up_read ( & iinfo -> i_data_sem ) ; <S2SV_ModStart> -> i_data_sem ) ; SetPageError ( page ) ; out_unmap :
<S2SV_ModStart> if ( ret >= 0 ) return ret ; fsnotify_put_group ( group ) ;
<S2SV_ModStart> - 0x10 ) >> 1 ; u64 redir_content ; if ( redir_index < IOAPIC_NUM_PINS ) <S2SV_ModEnd> redir_content = ioapic -> redirtbl [ redir_index ] . <S2SV_ModStart> = ioapic -> redirtbl [ redir_index ] . bits ; else redir_content = ~ 0ULL
<S2SV_ModStart> } shm_file = shp -> shm_file ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
<S2SV_ModStart> ( & key -> user -> nikeys ) ; <S2SV_ModEnd> if ( key -> type -> destroy ) key <S2SV_ModStart> destroy ) key -> type -> destroy ( key ) ; key_user_put ( key -> user
<S2SV_ModStart> -> d >> DstShift ) & OpMask ) ; <S2SV_ModEnd> if ( ctxt -> rip_relative ) ctxt -> memopp <S2SV_ModStart> . mem . ea += ctxt -> _eip ; done :
<S2SV_ModStart> if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( ) ; <S2SV_ModEnd> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0
<S2SV_ModStart> , * rskb , * cskb ; int err = 0 ; msg -> msg_namelen
<S2SV_ModStart> = - EINVAL ; return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; } } else if ( strcmp (
<S2SV_ModStart> ; } if ( num_clips && clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
<S2SV_ModStart> break ; case PTR_TO_STACK : pointer_desc = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
<S2SV_ModStart> ; } else if ( rc == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode -> i_op -> removexattr ( dentry <S2SV_ModStart> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> void ptrace_triggered ( struct perf_event * bp <S2SV_ModEnd> , struct perf_sample_data * data , struct pt_regs *
<S2SV_ModStart> struct serial_icounter_struct * icnt ) { struct serial_icounter_struct icount = { }
<S2SV_ModStart> -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n" , ret ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info ( s -> dev , "Registered<S2SV_blank>as<S2SV_blank>%s\\n" <S2SV_ModStart> : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem
<S2SV_ModStart> : ovl_cleanup ( wdir , newdentry ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { int ret = 0 , found = 0 <S2SV_ModEnd> ; const char * home = NULL ; if <S2SV_ModStart> 1 ; } free ( user_config ) ; } <S2SV_ModEnd> if ( found == 0 ) return - 1
<S2SV_ModStart> KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ; default : r = 0 ;
<S2SV_ModStart> unsigned int count ) { struct snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
<S2SV_ModStart> ) ; if ( err ) goto out ; err = ovl_copy_up ( dentry ) ; if ( ! err ) { upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_ModEnd> mutex_lock ( & upperdentry -> d_inode -> i_mutex ) <S2SV_ModStart> & upperdentry -> d_inode -> i_mutex ) ; } <S2SV_ModEnd> ovl_drop_write ( dentry ) ; out : return err
<S2SV_ModStart> dbg_hid ( "%s,<S2SV_blank>size:%d\\n" , __func__ , size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return false ; }
<S2SV_ModStart> querying_devices = false ; return ; } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] )
<S2SV_ModStart> struct gendisk * disk , fmode_t mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( disk -> private_data ) ; mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey ( struct crypto_shash * tfm , const
<S2SV_ModStart> * value , void * data ) { int ret = pci_read_config_word ( dev , offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { struct xen_pcibk_dev_data * dev_data ; int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ) ; value &= ~ PCI_COMMAND_INVALIDATE ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
<S2SV_ModStart> oz_hcd_get_desc_cnf ( void * hport , u8 req_id , u8 status , const u8 * desc , u8 length , u16 offset , u16 <S2SV_ModEnd> total_size ) { struct oz_port * port = hport <S2SV_ModStart> return ; if ( status == 0 ) { unsigned int copy_len ; unsigned <S2SV_ModEnd> int required_size = urb -> transfer_buffer_length ; if (
<S2SV_ModStart> - EFAULT ; goto cleanup ; } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( dev -> max_fib_size - sizeof ( struct aac_fibhdr )
<S2SV_ModStart> ses -> server -> ops = & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { <S2SV_ModStart> ses -> server -> ops = & smb311_operations ; ses -> server -> vals = & smb311_values ; }
<S2SV_ModStart> ; spin_unlock_bh ( & socket_client -> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree ( socket_packet ) ; if ( error
<S2SV_ModStart> pmcraid_err ( "couldn\'t<S2SV_blank>build<S2SV_blank>passthrough<S2SV_blank>ioadls\\n" ) ; goto out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
<S2SV_ModStart> ) goto _error ; bprm -> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file = open_exec ( iname ) ; retval
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct io_context * ioc ; task_lock ( <S2SV_ModStart> ) { struct io_context * ioc ; task_lock ( task ) ; ioc = task -> io_context ; task -> io_context = NULL ; task_unlock ( task <S2SV_ModEnd> ) ; if ( atomic_dec_and_test ( & ioc ->
<S2SV_ModStart> , int format , const char __user * addr <S2SV_ModEnd> , int count , int pmgr_flag ) { int <S2SV_ModStart> return 0 ; if ( format != SYSEX_PATCH ) return - EINVAL ; if ( count < hdr_size ) return - EINVAL ; <S2SV_ModEnd> count -= hdr_size ; if ( copy_from_user ( & <S2SV_ModStart> count -= hdr_size ; if ( copy_from_user ( & sysex , addr , hdr_size ) ) return - EFAULT ; if ( ( unsigned ) count < ( unsigned ) sysex . len ) sysex . len = count ; <S2SV_ModEnd> left = sysex . len ; src_offs = 0
<S2SV_ModStart> , int format , const char __user * addr <S2SV_ModEnd> , int count , int pmgr_flag ) { struct <S2SV_ModStart> - EINVAL ; } if ( copy_from_user ( & ins , addr , sizeof ( ins ) <S2SV_ModEnd> ) ) return - EFAULT ; if ( ins
<S2SV_ModStart> ] -> load_patch ( dev , fmt , buf + p <S2SV_ModEnd> , c , 0 ) ; if ( err
<S2SV_ModStart> -> cmsg_flags & LLC_CMSG_PKTINFO ) { struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> | map . m_flags ; bh -> b_size = ( u64 )
<S2SV_ModStart> void smp_task_done ( struct sas_task * task ) { <S2SV_ModEnd> del_timer ( & task -> slow_task -> timer ) <S2SV_ModStart> del_timer ( & task -> slow_task -> timer ) <S2SV_ModEnd> ; complete ( & task -> slow_task -> completion
<S2SV_ModStart> ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) { task -> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( & task -> slow_task -> completion <S2SV_ModStart> ( & task -> slow_task -> completion ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;
<S2SV_ModStart> } ; int vnet_hdr_len = 0 ; int copylen = 0 <S2SV_ModStart> ( len < ETH_HLEN ) ) goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy = true ; if ( zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
<S2SV_ModStart> + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> & page [ i ] ) ; if ( num_pages != size <S2SV_ModEnd> ) { for ( i = 0 ; i
<S2SV_ModStart> ; if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period
<S2SV_ModStart> , struct mapped_device , kobj_holder . kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> -> flags ) || dm_deleting_md ( md ) ) { md = NULL ; goto out ; } dm_get ( md ) ; out : spin_unlock ( & _minor_lock <S2SV_ModEnd> ) ; return md ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> msq , ipc_rcu_free ) ; return retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> msq , msg_rcu_free ) ; return id ; } <S2SV_ModEnd> ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock
<S2SV_ModStart> size_t count ) { BUG_ON ( direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> struct pipe_inode_info * pipe = i -> pipe ; <S2SV_ModEnd> if ( unlikely ( i -> count < size <S2SV_ModStart> size ) ) size = i -> count ; if ( size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; if ( off ) left <S2SV_ModEnd> += off - pipe -> bufs [ idx ] <S2SV_ModStart> pipe -> bufs [ idx ] ; if ( left <= buf -> len ) break ; left <S2SV_ModEnd> -= buf -> len ; idx = next_idx ( <S2SV_ModStart> = next_idx ( idx , pipe ) ; } i -> idx = idx ; i -> iov_offset = buf -> offset + left ; } i -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> pid , int sig ) { struct siginfo info = { }
<S2SV_ModStart> if ( ! desc -> count ) break ; tp -> copied_seq = seq ; } tp -> copied_seq = seq ; <S2SV_ModEnd> tcp_rcv_space_adjust ( sk ) ; if ( copied >
<S2SV_ModStart> & bp ) ; if ( error ) { if ( bp && ( xfs_da_shrink_inode ( args , 0 , bp ) != 0 ) <S2SV_ModEnd> ) goto out ; xfs_idata_realloc ( dp , size
<S2SV_ModStart> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
<S2SV_ModStart> dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> void uwbd_start ( struct uwb_rc * rc ) { struct task_struct * <S2SV_ModEnd> task = kthread_run ( uwbd , rc , "uwbd" <S2SV_ModStart> uwbd , rc , "uwbd" ) ; if ( IS_ERR ( task ) ) { rc -> uwbd . task = NULL ; printk ( KERN_ERR "UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;<S2SV_blank>" "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; } else { rc -> uwbd . task = task ; <S2SV_ModEnd> rc -> uwbd . pid = rc -> uwbd <S2SV_ModStart> = rc -> uwbd . task -> pid ; }
<S2SV_ModStart> void uwbd_stop ( struct uwb_rc * rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; return - ENOMEM ;
<S2SV_ModStart> ( struct usb_serial * serial ) { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
<S2SV_ModStart> inode -> i_sb ) ; unsigned int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ( ident == TAG_IDENT_IE && ibh ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; struct indirectEntry * ie ; ie <S2SV_ModStart> ) ; if ( ie -> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , "too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy" "<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n" , UDF_MAX_ICB_NESTING ) ; make_bad_inode ( inode ) ; return ; } goto reread <S2SV_ModEnd> ; } } brelse ( ibh ) ; }
<S2SV_ModStart> match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> = ERR_PTR ( - EINVAL ) ; if ( <S2SV_ModEnd> ! index_key . type -> instantiate || ( !
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , . <S2SV_ModStart> KEYRING_SEARCH_DO_STATE_CHECK , } ; key_ref_t key ; int ret <S2SV_ModEnd> ; if ( type -> match_preparse ) { ret
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , .
<S2SV_ModStart> current_cred ( ) , . match_data . cmp = key_default_cmp <S2SV_ModEnd> , . match_data . raw_data = description , .
<S2SV_ModStart> * ) ( unsigned long ) args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_err ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; va_end (
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_info ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> ... ) { va_list va ; struct va_format vaf <S2SV_ModEnd> ; va_start ( va , fmt ) ; vaf <S2SV_ModStart> ( & qedi -> pdev -> dev ) , func <S2SV_ModEnd> , line , qedi -> host_no , & vaf <S2SV_ModStart> & vaf ) ; else pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line , & vaf ) ; ret :
<S2SV_ModStart> * new_data , * old_data = env -> insn_aux_data ; int i <S2SV_ModStart> - off - cnt + 1 ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
<S2SV_ModStart> env ) ; if ( ret == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> err ; regs = cur_regs ( env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> ( err ) return err ; insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
<S2SV_ModStart> outarg . namelen > FUSE_NAME_MAX ) goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + outarg . namelen + 1 ) goto err ;
<S2SV_ModStart> == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
<S2SV_ModStart> * * p , void * end , void * <S2SV_ModStart> EINVAL ; dout ( "ceph_x_decrypt<S2SV_blank>len<S2SV_blank>%d\\n" , len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> ( secret , & head , & head_len , *
<S2SV_ModStart> end ) { void * p = buf ; u8 reply_struct_v ; u32 num ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( & p , end , reply_struct_v <S2SV_ModStart> ( ac , secret , & p , end ) ; if ( ret ) return ret ; } return 0 ; bad : return - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> th ; int ret = 0 ; struct ceph_x_authorize_reply reply ; void * preply = & <S2SV_ModStart> -> session_key , & p , end , & preply <S2SV_ModEnd> , sizeof ( reply ) ) ; if (
<S2SV_ModStart> , void * * p , void * end <S2SV_ModEnd> ) { struct ceph_x_info * xi = ac -> <S2SV_ModStart> blob_struct_v ; struct ceph_x_ticket_handler * th ; void * dbuf = NULL ; void * <S2SV_ModStart> is_enc ; struct timespec validity ; struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> = ceph_x_decrypt ( secret , p , end , & dbuf , 0 <S2SV_ModEnd> ) ; if ( dlen <= 0 ) { <S2SV_ModStart> p , end , is_enc , bad ) ; <S2SV_ModEnd> if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) <S2SV_ModStart> ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if ( dlen < 0 ) { <S2SV_ModStart> { ret = dlen ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> p , end , dlen , bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> -> have_keys |= th -> service ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context ; } else { if (
<S2SV_ModStart> * port ; struct scatterlist sg [ 1 ] ; void * data ; int ret <S2SV_ModStart> if ( ! port ) return - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; sg_init_one ( sg , data , count ) ; ret = <S2SV_ModEnd> __send_to_port ( port , sg , 1 , count <S2SV_ModStart> ( port , sg , 1 , count , data , false ) ; kfree ( data ) ; return ret ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { err = - ENOTCONN ; break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> kvm_assigned_dev_kernel * match ; struct pci_dev * dev ; u8 header_type ; <S2SV_ModStart> r = - EINVAL ; goto out_free ; } pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ; if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) { r = - EPERM ; goto out_put ; } r = probe_sysfs_permissions ( dev ) ; if ( r ) goto out_put ;
<S2SV_ModStart> ) ; } if ( chg < 0 ) { ret = chg ; goto out_err ; } <S2SV_ModEnd> if ( hugepage_subpool_get_pages ( spool , chg ) ) <S2SV_ModStart> if ( hugepage_subpool_get_pages ( spool , chg ) ) { ret = - ENOSPC ; goto out_err ; } <S2SV_ModEnd> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_ModStart> ) { hugepage_subpool_put_pages ( spool , chg ) ; goto out_err <S2SV_ModEnd> ; } if ( ! vma || vma -> <S2SV_ModStart> , from , to ) ; return 0 ; out_err : resv_map_put ( vma ) ; return ret ;
<S2SV_ModStart> reservations -> regions , start , end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if ( reserve ) { hugetlb_acct_memory (
<S2SV_ModStart> = ( size - 4 ) / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n" , size ) ; return 0 ; } <S2SV_ModStart> = ( size - 6 ) / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n" , size ) ; return 0 ; }
<S2SV_ModStart> port -> serial ; struct cypress_private * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> , port , & priv -> tmp_termios ) ; usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result <S2SV_ModEnd> ) { dev_err ( & port -> dev , <S2SV_ModStart> ) { dev_err ( & port -> dev , <S2SV_ModEnd> "%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>submitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n" , __func__ , result ) ; cypress_set_dead (
<S2SV_ModStart> ( cookie ) ) ) return ; if ( <S2SV_ModEnd> status == nlm_lck_denied_grace_period ) { nlmsvc_insert_block ( block , <S2SV_ModStart> } else { nlmsvc_unlink_block ( block ) ; } <S2SV_ModEnd> nlmsvc_release_block ( block ) ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> ; } args -> vlen = v ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> count = ntohl ( * p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> p ) ; len -= PAGE_SIZE ; } return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! p ) return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * target , struct svc_cred * source ) { target -> cr_principal = kstrdup ( source -> cr_principal , GFP_KERNEL ) ; target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL ) ; if ( ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM <S2SV_ModEnd> ; target -> cr_flavor = source -> cr_flavor ;
<S2SV_ModStart> # endif if ( bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> ) ; if ( status ) goto out ;
<S2SV_ModStart> ntohl ( * p ++ ) ; p ++ ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> ; } args -> vlen = v ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u32 , args -> count , PAGE_SIZE ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( ! p ) return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ( rqstp -> rq_next_page ++ ) ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( err < 0 ) goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
<S2SV_ModStart> , struct svc_export * exp ) { if ( ! d_inode ( dentry ) ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModEnd> ) return 1 ; if ( nfsd4_is_junction ( dentry <S2SV_ModStart> ( dentry ) ) return 1 ; if ( d_mountpoint ( dentry ) ) return 2 ; return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> unsigned long used ; int target ; long timeo ; msg -> msg_namelen = 0
<S2SV_ModStart> goto drop_recycle_buffer ; } if ( unlikely ( len + ring -> frameoffset
<S2SV_ModStart> ; p ++ ) { struct media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> . source -> entity != entity ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
<S2SV_ModStart> 0 ) ; sk -> sk_state = BT_CONFIG ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> { unsigned int cpu ; struct cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
<S2SV_ModStart> pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
<S2SV_ModStart> ) { abort_creds ( new ) ; return ret <S2SV_ModEnd> ; } return commit_creds ( new ) ; }
<S2SV_ModStart> keyring ; if ( new -> process_keyring ) return 0 <S2SV_ModEnd> ; keyring = keyring_alloc ( "_pid" , new ->
<S2SV_ModStart> ; if ( ! new ) return - ENOMEM <S2SV_ModEnd> ; ret = install_thread_keyring_to_cred ( new ) ; if
<S2SV_ModStart> cred * new ) { struct key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> ; if ( ses -> server -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> <S2SV_ModStart> -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE )
<S2SV_ModStart> NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> ; if ( ses -> server -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> <S2SV_ModStart> -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;
<S2SV_ModStart> srv_mutex ) ; if ( ses -> server -> <S2SV_ModEnd> ops -> generate_signingkey ) { rc = ses -> <S2SV_ModStart> -> server -> ops -> generate_signingkey ( ses ) <S2SV_ModEnd> ; if ( rc ) { cifs_dbg ( FYI <S2SV_ModStart> ( & ses -> server -> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } if ( ! ses -> server <S2SV_ModStart> = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> num_interrupt_in == 0 ) ) return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> pipe ; int j ; if ( serial -> num_bulk_out < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial -> port [ 0 ] ;
<S2SV_ModStart> rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if ( svm -> vcpu . guest_debug &
<S2SV_ModStart> . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR
<S2SV_ModStart> { ret = - EAGAIN ; break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> struct mount * tree ; namespace_lock ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
<S2SV_ModStart> ; list_del ( & mnt -> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }
<S2SV_ModStart> ( ! list_empty ( & tmp_list ) ) { bool disconnect ; <S2SV_ModStart> ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if ( mnt_has_parent ( p ) ) <S2SV_ModStart> ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } <S2SV_ModEnd> change_mnt_propagation ( p , MS_PRIVATE ) ; } }
<S2SV_ModStart> ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> ; int ret ; kenter ( "" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;
<S2SV_ModStart> } INIT_LIST_HEAD ( & extra_response -> er_list ) ; strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ; strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail ( & extra_response -> er_list ,
<S2SV_ModStart> ( iscsi_check_for_auth_key ( key ) > 0 ) { <S2SV_ModEnd> kfree ( tmpbuf ) ; return 1 ; }
<S2SV_ModStart> struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ; iv = timr -> it_interval ;
<S2SV_ModStart> timespec64_to_ktime ( new_setting -> it_value ) ; sigev_none = timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ; kc -> timer_arm ( timr ,
<S2SV_ModStart> struct task_struct * rtn = current -> group_leader ; switch ( event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ; if ( ! rtn || ! same_thread_group ( rtn , current ) ) return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if ( event -> sigev_signo <= 0 || event -> sigev_signo > SIGRTMAX ) return NULL ; case SIGEV_NONE : return task_pid ( rtn ) ; default : return NULL ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct ld_semaphore * sem ) { long tmp = <S2SV_ModEnd> atomic_long_cmpxchg ( & sem -> count , * old <S2SV_ModStart> -> count , * old , new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> init ) ops -> init ( dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> ) ; if ( ret < 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> destroy ( dev ) ; return ret ; } <S2SV_ModEnd> cd -> fd = ret ; return 0 ;
<S2SV_ModStart> mm ) ; rcu_read_lock ( ) ; if ( dumpable != SUID_DUMP_USER <S2SV_ModEnd> && ! ptrace_has_cap ( __task_cred ( task ) ->
<S2SV_ModStart> ( & group -> inotify_data . idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
<S2SV_ModStart> int , flags ) { struct fsnotify_group * group <S2SV_ModEnd> ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC <S2SV_ModStart> IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; group = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; if ( IS_ERR ( group ) <S2SV_ModStart> ) ; if ( IS_ERR ( group ) ) return PTR_ERR ( group <S2SV_ModEnd> ) ; ret = anon_inode_getfd ( "inotify" , & <S2SV_ModStart> , O_RDONLY | flags ) ; if ( ret < 0 ) fsnotify_put_group ( group <S2SV_ModEnd> ) ; return ret ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static struct fsnotify_group * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events ) { struct fsnotify_group * group <S2SV_ModStart> . last_wd = 0 ; group -> inotify_data . fa = NULL ; group -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> struct fsnotify_group * group = file -> private_data ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>group=%p\\n" , __func__ , group ) ; <S2SV_ModStart> ( group ) ; fsnotify_put_group ( group ) ; <S2SV_ModEnd> return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> , & seg_desc , base3 , seg ) ; if ( desc ) * desc = seg_desc ;
<S2SV_ModStart> , old_cs ; ulong old_eip ; int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( & sel , ctxt -> src <S2SV_ModStart> valptr + ctxt -> op_bytes , 2 ) ; rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ctxt -> op_bytes , 2 ) ; rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModEnd> ) ; if ( rc != X86EMUL_CONTINUE ) return <S2SV_ModStart> if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ctxt ) { int rc ; unsigned long eip , cs ; u16 old_cs <S2SV_ModEnd> ; int cpl = ctxt -> ops -> cpl <S2SV_ModStart> ctxt -> ops -> cpl ( ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; rc = emulate_pop ( ctxt , & eip <S2SV_ModEnd> , ctxt -> op_bytes ) ; if ( rc <S2SV_ModStart> ; if ( rc != X86EMUL_CONTINUE ) return rc <S2SV_ModEnd> ; rc = emulate_pop ( ctxt , & cs <S2SV_ModStart> ) > cpl ) return X86EMUL_UNHANDLEABLE ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , ( u16 ) cs , VCPU_SREG_CS <S2SV_ModStart> ( ctxt , ( u16 ) cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> return rc ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt , selector , seg , cpl , false , NULL
<S2SV_ModStart> tss -> ldt , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModStart> tss -> es , VCPU_SREG_ES , cpl , true , NULL <S2SV_ModStart> tss -> cs , VCPU_SREG_CS , cpl , true , NULL <S2SV_ModStart> tss -> ss , VCPU_SREG_SS , cpl , true , NULL <S2SV_ModStart> tss -> ds , VCPU_SREG_DS , cpl , true , NULL
<S2SV_ModStart> tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModStart> tss -> es , VCPU_SREG_ES , cpl , true , NULL <S2SV_ModStart> tss -> cs , VCPU_SREG_CS , cpl , true , NULL <S2SV_ModStart> tss -> ss , VCPU_SREG_SS , cpl , true , NULL <S2SV_ModStart> tss -> ds , VCPU_SREG_DS , cpl , true , NULL <S2SV_ModStart> tss -> fs , VCPU_SREG_FS , cpl , true , NULL <S2SV_ModStart> tss -> gs , VCPU_SREG_GS , cpl , true , NULL
<S2SV_ModStart> >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
<S2SV_ModStart> user_ns ) ; new_ns -> ucounts = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
<S2SV_ModStart> parent_path ) { HLIST_HEAD ( tree_list ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; struct hlist_node * n ; int err ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt ) ; if ( err ) goto out ; } <S2SV_ModStart> . first , struct mount , mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> cleanup_group_ids ( source_mnt , NULL ) ; out : ns -> pending_mounts = 0 ;
<S2SV_ModStart> head , n -> list . prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
<S2SV_ModStart> p ) { q -> mnt_ns = new_ns ; new_ns -> mounts ++ ;
<S2SV_ModStart> = new_ns ; new_ns -> root = mnt ; new_ns -> mounts ++ ;
<S2SV_ModStart> ( ! list_empty ( & tmp_list ) ) { struct mnt_namespace * ns ; <S2SV_ModStart> ; list_del_init ( & p -> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> p -> mnt_ns = NULL ; if ( how
<S2SV_ModStart> & child -> mnt_hash , list ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> file , ns , cap_setid , & new_map ) <S2SV_ModEnd> ) goto out ; ret = - EPERM ; <S2SV_ModStart> out ; e -> lower_first = lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> ( & sm_info -> sit_entry_set ) ; if ( <S2SV_ModEnd> ! f2fs_readonly ( sbi -> sb ) ) {
<S2SV_ModStart> SM_I ( sbi ) -> fcc_info = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> effective = true ; } skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
<S2SV_ModStart> vsock_sk ( sk ) ; err = 0 ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ; inst -> alg . decrypt = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static void pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) { struct pcrypt_instance_ctx * ctx = <S2SV_ModStart> * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst ) ; crypto_drop_aead ( & ctx ->
<S2SV_ModStart> & OpMask ) ; if ( ctxt -> rip_relative && likely ( ctxt -> memopp )
<S2SV_ModStart> ; unsigned long tmpl ; struct desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ( ) & ~ X86_CR0_TS ) ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; #
<S2SV_ModStart> return - EFAULT ; if ( info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; return - EPERM ; } <S2SV_ModEnd> info . si_signo = sig ; return kill_proc_info (
<S2SV_ModStart> return - EINVAL ; if ( info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; return - EPERM ; } <S2SV_ModEnd> info -> si_signo = sig ; return do_send_specific (
<S2SV_ModStart> ? PSW_MASK_RI : 0 ; if ( ( data ^ PSW_USER_BITS ) & ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return - EINVAL ; if ( ( data
<S2SV_ModStart> * inode , struct f2fs_extent * i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext ) ; if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT ) ; return ret <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> alg_sock * ask = alg_sk ( sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> = sizeof ( * ctx ) + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = sock_kmalloc ( sk , len , <S2SV_ModStart> -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL ) ; if ( ! ctx <S2SV_ModStart> ( ctx -> iv , 0 , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private = ctx ; skcipher_request_set_tfm ( & ctx -> req , skcipher ) ; skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ; <S2SV_ModEnd> sk -> sk_destruct = skcipher_sock_destruct ; return 0 ;
<S2SV_ModStart> name , u32 type , u32 mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_ModStart> crypto_alloc_skcipher ( name , type , mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ;
<S2SV_ModStart> static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u8 * key , unsigned int keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher , key , keylen ) ; tfm -> has_key = ! err ; return err ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; struct hns_roce_ucontext * context ; struct hns_roce_ib_alloc_ucontext_resp resp = { }
<S2SV_ModStart> ( & loopback_queue ) ) != NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> frametype = skb -> data [ 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> ( rose_address * ) ( skb -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i
<S2SV_ModStart> ) ; } } else umount_tree ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; } unlock_mount_hash ( ) ; put_mountpoint (
<S2SV_ModStart> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || IS_MNT_LOCKED_AND_LAZY ( p ) <S2SV_ModEnd> ) ; pin_insert_group ( & p -> mnt_umount ,
<S2SV_ModStart> -> flags ) ) { rfcomm_dlc_accept ( d ) ; msg -> msg_namelen = 0
<S2SV_ModStart> } inode -> i_generation = iinfo -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> f = & hci_pi ( sk ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
<S2SV_ModStart> pathComponent * ) ( from + elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> : if ( pc -> lengthComponentIdent > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : if ( tolen == 0 ) <S2SV_ModStart> tolen -= 2 ; break ; case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> = '/' ; tolen -- ; break ; } <S2SV_ModEnd> } if ( p > to + 1 )
<S2SV_ModStart> id ) ; if ( uid_eq ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return true ; } else if ( <S2SV_ModStart> id ) ; if ( gid_eq ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return true ; } } if (
<S2SV_ModStart> ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> user_alloc ) ; if ( r ) goto out_free <S2SV_ModEnd> ; r = - ENOMEM ; slots = kmemdup <S2SV_ModStart> ( ! slots ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> ) ; kfree ( old_memslots ) ; return 0 ; out_slots : kfree ( slots )
<S2SV_ModStart> ( & current -> mm -> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
<S2SV_ModStart> rq_proc ) ; proc = rqstp -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> struct media_entity * ent ; struct media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;
<S2SV_ModStart> -> private_data ; struct ib_ucm_cmd_hdr hdr ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; int srcu_key ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
<S2SV_ModStart> = 0 ; void * dest ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> int uctxt_required = 1 ; int must_be_root = 0 ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES
<S2SV_ModStart> next ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> ) ; if ( ret ) goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> struct pstore * ps = get_info ( store ) <S2SV_ModEnd> ; sector_t size = get_dev_size ( dm_snap_cow ( store <S2SV_ModStart> ; e -> new_chunk = ps -> next_free ; ps -> next_free ++ ; skip_metadata ( ps ) <S2SV_ModEnd> ; atomic_inc ( & ps -> pending_count ) ;
<S2SV_ModStart> return r ; } ps -> current_area -- ; skip_metadata ( ps ) ;
<S2SV_ModStart> env , "invalid<S2SV_blank>variable<S2SV_blank>stack<S2SV_blank>read<S2SV_blank>R%d<S2SV_blank>var_off=%s\\n" , regno , tn_buf ) ; return - EACCES ;
<S2SV_ModStart> ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) <S2SV_ModEnd> ; } split_node : pr_devel ( "split<S2SV_blank>node\\n" ) ; <S2SV_ModStart> = assoc_array_node_to_ptr ( node ) ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n" <S2SV_ModEnd> , __func__ ) ; return true ; all_leaves_cluster_together :
<S2SV_ModStart> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; xfs_daddr_t eofs <S2SV_ModStart> ( xfs_off_t ) btp -> bt_smask ) ) ; eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , "%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>" , __func__ , blkno , eofs ) ; return NULL ; }
<S2SV_ModStart> struct flakey_c * fc = ti -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , <S2SV_ModEnd> dev -> mode , cmd , arg ) ;
<S2SV_ModStart> ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , <S2SV_ModEnd> dev -> mode , cmd , arg ) ;
<S2SV_ModStart> ( & m -> lock , flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
<S2SV_ModStart> salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_ModEnd> while ( walk . nbytes >= 64 ) {
<S2SV_ModStart> ret ; if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
<S2SV_ModStart> ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
<S2SV_ModStart> ) { struct task_struct * task = current ; <S2SV_ModEnd> BUG_ON ( ! ( task -> flags & PF_KTHREAD
<S2SV_ModStart> ) return handle_machine_check ( vcpu ) ; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1 ; if ( is_no_device ( intr_info
<S2SV_ModStart> ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( is_nmi <S2SV_ModEnd> ( intr_info ) ) return false ; else if
<S2SV_ModStart> exit_intr_info ) ) kvm_machine_check ( ) ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) { kvm_before_handle_nmi ( & vmx -> vcpu
<S2SV_ModStart> ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> static ssize_t pipe_write ( struct kiocb * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct file * filp = iocb -> <S2SV_ModStart> * pipe = filp -> private_data ; ssize_t ret = 0 ; int do_wakeup = 0 ; size_t total_len = iov_iter_count ( from ) ; ssize_t chars ; <S2SV_ModEnd> if ( unlikely ( total_len == 0 ) ) <S2SV_ModStart> ( unlikely ( total_len == 0 ) ) return <S2SV_ModEnd> 0 ; __pipe_lock ( pipe ) ; if ( <S2SV_ModStart> offset + chars <= PAGE_SIZE ) { int error <S2SV_ModEnd> = ops -> confirm ( pipe , buf ) <S2SV_ModStart> ) ; if ( error ) goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; goto out ; } do_wakeup = 1 ; buf -> len += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out ; } } for ( ; <S2SV_ModStart> struct page * page = pipe -> tmp_page ; int copied <S2SV_ModEnd> ; if ( ! page ) { page = <S2SV_ModStart> tmp_page = page ; } do_wakeup = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ; if ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT ; break ; } ret += copied <S2SV_ModEnd> ; buf -> page = page ; buf -> <S2SV_ModStart> -> offset = 0 ; buf -> len = copied <S2SV_ModEnd> ; buf -> flags = 0 ; if ( <S2SV_ModStart> ++ bufs ; pipe -> tmp_page = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ; } if ( bufs < pipe
<S2SV_ModStart> op , file , & opened ) ; goto out2 <S2SV_ModEnd> ; } error = path_init ( dfd , pathname <S2SV_ModStart> ; } out : path_cleanup ( nd ) ; out2 :
<S2SV_ModStart> = intel_snb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_ivb_pebs_event_constraints ; x86_pmu . pebs_aliases = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
<S2SV_ModStart> ppos ) { struct usb_yurex * dev ; int len <S2SV_ModEnd> = 0 ; char in_buffer [ 20 ] ; <S2SV_ModStart> ; if ( ! dev -> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave ( & dev -> lock , <S2SV_ModStart> ( & dev -> lock , flags ) ; len <S2SV_ModEnd> = snprintf ( in_buffer , 20 , "%lld\\n" , <S2SV_ModStart> ( & dev -> lock , flags ) ; <S2SV_ModEnd> mutex_unlock ( & dev -> io_mutex ) ; return <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0x00 , 0x00 , 0x00 , 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
<S2SV_ModStart> ret ; if ( rs -> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> 0 ) ; if ( ( ctxt -> mode != X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) && ( efer & EFER_LMA ) && ! <S2SV_ModStart> ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <S2SV_ModEnd> if ( ( msr_data & 0xfffc ) == 0x0 <S2SV_ModStart> ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModEnd> ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF <S2SV_ModStart> EFLG_IF ) ; cs_sel = ( u16 ) msr_data & <S2SV_ModEnd> ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <S2SV_ModStart> ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; if ( efer & EFER_LMA <S2SV_ModEnd> ) { cs . d = 0 ; cs <S2SV_ModStart> , & msr_data ) ; ctxt -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> ; * reg_write ( ctxt , VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
<S2SV_ModStart> < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk ) ; if ( ctx ->
<S2SV_ModStart> long copied = 0 ; lock_sock ( sk ) <S2SV_ModEnd> ; for ( iov = msg -> msg_iov ,
<S2SV_ModStart> struct sock * sk = sock -> sk ; <S2SV_ModEnd> int copied , err ; if ( * debug <S2SV_ModStart> skb ) return err ; if ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name ; maddr -> family = AF_ISDN <S2SV_ModStart> . addr >> 8 ) & 0xFF ; } msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied = skb -> len + MISDN_HEADER_LEN
<S2SV_ModStart> { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; } copied = skb -> len <S2SV_ModStart> -> msg_name , & msg -> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram ( sk , skb ) ; return
<S2SV_ModStart> ( flags & MSG_OOB ) return - EOPNOTSUPP ; <S2SV_ModEnd> BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu" , sk , size ) ;
<S2SV_ModStart> ; if ( ! skb ) return err ; <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> -> flags ) ) { rfcomm_dlc_accept ( d ) <S2SV_ModEnd> ; return 0 ; } len = bt_sock_stream_recvmsg (
<S2SV_ModStart> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk ) ; return 0 ; }
<S2SV_ModStart> IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram ( sk , flags & ~
<S2SV_ModStart> timeo = sock_rcvtimeo ( sk , noblock ) ; <S2SV_ModEnd> do { int chunk ; struct sk_buff * skb
<S2SV_ModStart> cskb ; int err = 0 ; u32 offset <S2SV_ModEnd> ; if ( ( sk -> sk_state == IUCV_DISCONN
<S2SV_ModStart> unsigned long used ; int target ; long timeo <S2SV_ModEnd> ; lock_sock ( sk ) ; copied = -
<S2SV_ModStart> ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) <S2SV_ModEnd> ; lock_sock ( sk ) ; if ( sk
<S2SV_ModStart> ; if ( ! skb ) return rc ; <S2SV_ModEnd> copied = skb -> len ; if ( len
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp . type , "acomp" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher . type , "akcipher" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . type , "cipher" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . type , "compression" , sizeof (
<S2SV_ModStart> crypto_alg * alg ) { struct crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp . type , "kpp" , sizeof (
<S2SV_ModStart> * ualg , struct sk_buff * skb ) { strncpy <S2SV_ModEnd> ( ualg -> cru_name , alg -> cra_name , <S2SV_ModStart> , sizeof ( ualg -> cru_name ) ) ; strncpy <S2SV_ModEnd> ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_ModStart> , sizeof ( ualg -> cru_driver_name ) ) ; strncpy <S2SV_ModEnd> ( ualg -> cru_module_name , module_name ( alg -> <S2SV_ModStart> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . type , "larval" , sizeof (
<S2SV_ModStart> sb ) ) return ERR_CAST ( sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;
<S2SV_ModStart> goto out ; } ret = - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
<S2SV_ModStart> const struct ieee80211_radiotap_vendor_namespaces * vns ) { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> _arg - ( unsigned long ) iterator -> _rtheader + sizeof ( uint32_t )
<S2SV_ModStart> load_sp0 ( tss , next ) ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> ) ) loadsegment ( ds , next -> ds <S2SV_ModEnd> ) ; if ( unlikely ( fsindex | next
<S2SV_ModStart> -> sk_bound_dev_if = ireq6 -> iif ; newinet -> inet_opt <S2SV_ModEnd> = NULL ; newnp -> rxopt . all =
<S2SV_ModStart> nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> struct timespec * tp ) { u64 nsec ; u32 <S2SV_ModEnd> rem ; nsec = rtc_time ( ) * sgi_clock_period <S2SV_ModStart> ; sgi_clock_offset . tv_sec = tp -> tv_sec - div_u64_rem <S2SV_ModEnd> ( nsec , NSEC_PER_SEC , & rem ) ;
<S2SV_ModStart> it_value . tv_sec = 0 ; return ; } cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it . mmtimer . incr * sgi_clock_period <S2SV_ModStart> it . mmtimer . incr * sgi_clock_period ) ; cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> it . mmtimer . expires - <S2SV_ModStart> - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> sgi_timer_del ( timr ) ; when = timespec_to_ns ( & <S2SV_ModStart> new_setting -> it_value ) ; period = timespec_to_ns ( & <S2SV_ModStart> ( & n ) ; now = timespec_to_ns ( &
<S2SV_ModStart> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu . cpu , tp ) ; <S2SV_ModStart> cputime_to_timespec ( cpu . cpu , tp ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> long jiffies , struct timespec * value ) { u32 rem ; value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> long jiffies , struct timeval * value ) { u32 rem ; value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ; value -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( const s64 nsec ) { struct timespec ts ; s32 rem <S2SV_ModStart> 0 , 0 } ; ts . tv_sec = div_s64_rem ( nsec , NSEC_PER_SEC , & rem ) ; if ( unlikely ( rem < 0 ) ) { ts . tv_sec -- ; rem += NSEC_PER_SEC ; } ts . tv_nsec = rem <S2SV_ModEnd> ; return ts ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> timex * txc ) { long mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj ; int result ; if ( <S2SV_ModStart> ( s64 ) - MAXFREQ_NSEC ) ; time_offset = div_s64 ( time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset <<= SHIFT_UPDATE ; } } if
<S2SV_ModStart> * sizeof ( * di ) ; dl = kzalloc <S2SV_ModEnd> ( size , GFP_KERNEL ) ; if ( !
<S2SV_ModStart> ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size <S2SV_ModEnd> ) ) ) goto out ; if ( mem
<S2SV_ModStart> addr ) ) return - EFAULT ; r = __copy_from_user <S2SV_ModEnd> ( data , ( void __user * ) addr
<S2SV_ModStart> i ; count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
<S2SV_ModStart> 1 ; struct packet_offload * ptype ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
<S2SV_ModStart> 1 ; if ( NAPI_GRO_CB ( skb ) -> encap_mark <S2SV_ModEnd> || ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB <S2SV_ModStart> ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark <S2SV_ModEnd> = 1 ; rcu_read_lock ( ) ; uo_priv =
<S2SV_ModStart> this , * next ; DEFINE_WAKE_Q ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> ) ; struct fb_ops * fb ; unsigned long mmio_pgoff <S2SV_ModEnd> ; unsigned long start ; u32 len ; if <S2SV_ModStart> ; if ( ! info ) return - ENODEV <S2SV_ModEnd> ; fb = info -> fbops ; if ( <S2SV_ModStart> = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = <S2SV_ModStart> PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; <S2SV_ModEnd> start = info -> fix . mmio_start ; len <S2SV_ModStart> = info -> fix . mmio_start ; len = info -> fix . mmio_len <S2SV_ModEnd> ; } mutex_unlock ( & info -> mm_lock ) <S2SV_ModStart> } mutex_unlock ( & info -> mm_lock ) ; <S2SV_ModEnd> vma -> vm_page_prot = vm_get_page_prot ( vma -> vm_flags <S2SV_ModStart> vm_flags ) ; fb_pgprotect ( file , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; <S2SV_ModStart> ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; for ( idx = 0 ; idx < <S2SV_ModEnd> count ; idx ++ , id . index ++
<S2SV_ModStart> ; } if ( result > 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> ) ; snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ; return 0 ; } } up_read
<S2SV_ModStart> kcontrol , bool add_on_replace ) { struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; for ( idx = 0 ; idx < <S2SV_ModEnd> count ; idx ++ , id . index ++
<S2SV_ModStart> ) ; if ( err > 0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> ) ; snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ; return 0 ; } } else
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr <S2SV_ModStart> struct kvm_vcpu * vcpu , gpa_t vapic_addr ) { if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . <S2SV_ModStart> , & vcpu -> arch . apic_attention ) ; } else { <S2SV_ModEnd> __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . <S2SV_ModStart> , & vcpu -> arch . apic_attention ) ; } vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ;
<S2SV_ModStart> ( struct kvm_vcpu * vcpu ) { u32 data <S2SV_ModEnd> ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu <S2SV_ModStart> vcpu -> arch . apic_attention ) ) return ; kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr ( vcpu -> arch . apic
<S2SV_ModStart> kvm_lapic * apic = vcpu -> arch . apic <S2SV_ModEnd> ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if <S2SV_ModStart> 8 ) | ( max_irr << 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> if ( th -> syn ) { if ( th -> fin ) goto discard ; if (
<S2SV_ModStart> ] = ( __u16 ) ei -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
<S2SV_ModStart> break ; } parameters -> csty |= 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> parameters -> prch_init [ i ] = 256 ; }
<S2SV_ModStart> tileno / p_cp -> tw ; * p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> tx0 + p * p_cp -> <S2SV_ModStart> p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ; * p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> tx0 + ( p + 1 <S2SV_ModStart> ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ; * p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> ty0 + q * p_cp -> <S2SV_ModStart> p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ; * p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> ty0 + ( q + 1 <S2SV_ModStart> ( q + 1 ) * p_cp -> tdy , <S2SV_ModEnd> p_image -> y1 ) ; * p_max_prec = 0
<S2SV_ModStart> . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_ModEnd> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if <S2SV_ModStart> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
<S2SV_ModStart> ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> * l_step_l , sizeof ( OPJ_INT16 ) ) ; }
<S2SV_ModStart> != 00 ) ; OPJ_UNUSED ( p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream <S2SV_ModEnd> ) ; if ( p_total_data_size < 12 ) {
<S2SV_ModStart> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 2 ) ; } return OPJ_FALSE ; }
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> = res -> pdy + levelno ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , <S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size ,
<S2SV_ModStart> if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size ,
<S2SV_ModStart> opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size <S2SV_ModStart> ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> include = ( OPJ_INT16 * ) opj_calloc ( ( size_t ) ( l_tcp -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l , sizeof ( OPJ_INT16 ) )
<S2SV_ModStart> , int dir_len , char * ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( "invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( dir , dir_len , "" , 0 ) <S2SV_ModEnd> ; char * dst = ptr ; if ( <S2SV_ModStart> ( ! ptr ) free ( dst ) ; free ( src ) ; return NULL ; } free ( src ) ; <S2SV_ModEnd> return dst ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> name ) ; return 0 ; } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> <S2SV_null> void * _TIFFmalloc ( tmsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> , op0 , occ0 , s ) ) { return <S2SV_ModStart> ) ( tif , op0 , occ0 ) ; <S2SV_ModEnd> } else return 0 ; } <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rowsize ; assert ( rowsize > 0 ) ; if ( ( occ0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorDecodeTile" , "%s" , "occ0%rowsize<S2SV_blank>!=<S2SV_blank>0" ) ; return 0 ; } <S2SV_ModEnd> assert ( sp -> decodepfunc != NULL ) ; <S2SV_ModStart> ) ; while ( occ0 > 0 ) { if ( ! <S2SV_ModStart> decodepfunc ) ( tif , op0 , rowsize ) ) return 0
<S2SV_ModStart> assert ( sp -> encoderow != NULL ) ; if ( ! <S2SV_ModStart> encodepfunc ) ( tif , bp , cc ) ) return 0
<S2SV_ModStart> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } <S2SV_ModEnd> while ( cc > 0 ) { ( *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpAcc ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> ( uint8 * ) _TIFFmalloc ( cc ) ; if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } if ( ! tmp ) return 0 <S2SV_ModEnd> ; while ( count > stride ) { REPEAT4 <S2SV_ModStart> # endif } } _TIFFfree ( tmp ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpDiff ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> ( uint8 * ) _TIFFmalloc ( cc ) ; if <S2SV_ModEnd> ( ( cc % ( bps * stride ) <S2SV_ModStart> ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } if ( ! tmp ) return 0 <S2SV_ModEnd> ; _TIFFmemcpy ( tmp , cp0 , cc ) <S2SV_ModStart> ] ) & 0xff ) ; cp -- ) return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if <S2SV_ModEnd> ( ( cc % ( 2 * stride ) <S2SV_ModStart> ( cc % ( 2 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc16" , "%s" , "cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if <S2SV_ModEnd> ( ( cc % ( 4 * stride ) <S2SV_ModStart> ( cc % ( 4 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc32" , "%s" , "cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc > stride ) { if ( <S2SV_ModStart> while ( cc > 0 ) ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if <S2SV_ModEnd> ( ( cc % ( 2 * stride ) <S2SV_ModStart> ( cc % ( 2 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if <S2SV_ModEnd> ( ( cc % ( 4 * stride ) <S2SV_ModStart> ( cc % ( 4 * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff32" , "%s" , "(cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc > stride ) { wc -= <S2SV_ModStart> } while ( wc > 0 ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff8 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc > stride ) { cc -= <S2SV_ModStart> -= stride ) > 0 ) ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> 4 ; TIFFSwabArrayOfLong ( wp , wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 2 ; if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ; TIFFSwabArrayOfShort ( wp , wc ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff32 ( TIFF * tif , uint8 * cp0 <S2SV_ModStart> cp0 ; tmsize_t wc = cc / 4 ; if ( ! horDiff32 ( tif , cp0 , cc ) ) return 0 ; TIFFSwabArrayOfLong ( wp , wc ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) rowsperstrip = td -> td_imagelength ; stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ; stripinplane = ( strip % stripsperplane
<S2SV_ModStart> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; _TIFFfree ( working_copy ) ;
<S2SV_ModStart> ( uint8 * ) cp0 ; uint8 * tmp <S2SV_ModEnd> ; if ( cc % ( bps * stride <S2SV_ModStart> "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> ( uint8 * ) cp0 ; uint8 * tmp <S2SV_ModEnd> ; if ( ( cc % ( bps * <S2SV_ModStart> "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> tif -> tif_rawdata , tif -> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; return ( 0 ) ; } <S2SV_ModEnd> tif -> tif_rawcc = 0 ; tif -> tif_rawcp
<S2SV_ModStart> uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 <S2SV_ModStart> ( rowsperstrip >= td -> td_rowsperstrip ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips == 0 ) return ; <S2SV_ModEnd> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif <S2SV_ModStart> = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips <S2SV_ModEnd> , sizeof ( uint64 ) , "for<S2SV_blank>chopped<S2SV_blank>\\"StripByteCounts\\"<S2SV_blank>array" ) ; <S2SV_ModStart> = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips <S2SV_ModEnd> , sizeof ( uint64 ) , "for<S2SV_blank>chopped<S2SV_blank>\\"StripOffsets\\"<S2SV_blank>array" ) ; <S2SV_ModStart> } for ( strip = 0 ; strip < nstrips <S2SV_ModEnd> ; strip ++ ) { if ( stripbytes > <S2SV_ModStart> ] = stripbytes ; newoffsets [ strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += stripbytes ; bytecount -= stripbytes ; <S2SV_ModStart> } td -> td_stripsperimage = td -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip )
<S2SV_ModStart> td = & tif -> tif_dir ; uint32 nstrips <S2SV_ModEnd> ; nstrips = ( td -> td_rowsperstrip == (
<S2SV_ModStart> , & ptr ) != VFP_OK ) break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if ( ! ValidateIOBufferSize ( Irp , sizeof <S2SV_ModStart> ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ; if ( NT_SUCCESS ( ntStatus ) ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & offset , NULL ) ; if ( <S2SV_ModStart> NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ntStatus ; Irp -> IoStatus . Information = 0 ; } TCfree ( readBuffer )
<S2SV_ModStart> num_properties = GETINT32 ( buf + idx ) ; assert ( ( num_properties + 1 ) != 0 ) ; <S2SV_ModStart> -> names [ i ] . len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> buf + idx ) ; idx += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> if ( a -> type == szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
<S2SV_ModStart> ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
<S2SV_ModStart> ; j < a -> num_values ; j ++ ) { if ( a -> type == szMAPI_BINARY <S2SV_ModStart> body [ j ] -> len ) ; } }
<S2SV_ModStart> mapi_attrs [ i ] ; if ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> = a -> num_values ; } else if ( a -> type == szMAPI_BINARY &&
<S2SV_ModStart> checked_xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; alloc_limit_assert ( "checked_xcalloc" , ( res <S2SV_ModEnd> ) ) ; return xcalloc ( num , size
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void * checked_xmalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; alloc_limit_assert ( "checked_xmalloc" , res ) ; return xmalloc ( num , <S2SV_ModEnd> size ) ; } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; ptr = malloc ( res <S2SV_ModEnd> ) ; if ( ptr ) { memset ( <S2SV_ModStart> ) { memset ( ptr , '\\0' , ( res <S2SV_ModEnd> ) ) ; } return ptr ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> void * xmalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr = malloc ( res <S2SV_ModEnd> ) ; if ( ! ptr && ( size
<S2SV_ModStart> 0 ; guint32 pkt_len , rectype , dlt ; int wtap_encap ; struct eth_phdr eth ; void * phdr ; <S2SV_ModStart> next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ; wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new ( wtap_encap_dissector_table , wtap_encap , next_tvb , pinfo , tree , TRUE , phdr <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> len_remain , ampdu_len = 0 ; struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> tree , & phdr ) ; } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new ( wtap_encap_dissector_table , wtap_encap , next_tvb , pinfo , tree , TRUE , phdrp <S2SV_ModEnd> ) ; } } <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> guint caplen , len , frame_no ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , <S2SV_ModStart> wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree , TRUE , phdr
<S2SV_ModStart> , u3v_conv_info_t ) ; usb_conv_info -> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
<S2SV_ModStart> audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
<S2SV_ModStart> ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
<S2SV_ModStart> ) ) ; usb_conv_info -> class_data = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
<S2SV_ModStart> j + chan ] = TRUE ; c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf <S2SV_ModEnd> ; macinf -> lchid [ j + chan ] <S2SV_ModStart> -> lchid [ j + chan ] = c_t <S2SV_ModEnd> ; macinf -> content [ j + chan ] <S2SV_ModStart> [ j + chan ] = lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf -> mode [ j + chan <S2SV_ModStart> [ j + chan ] = lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; } } else { fake_lchid = make_fake_lchid
<S2SV_ModStart> + offset + 2 ) ; if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) <S2SV_ModEnd> ) { AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short" , AIRPDCAP_DEBUG_LEVEL_3
<S2SV_ModStart> offset ) + 1 ; } while ( offset > 0 && offset < end_offset ) { <S2SV_ModEnd> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo <S2SV_ModStart> tree , drep , NULL , hf_keybuffer ) ; }
<S2SV_ModStart> - ( offset % 2 ) ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb , offset ) ; if ( remaining
<S2SV_ModStart> ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } if ( ( key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) <S2SV_ModStart> key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) )
<S2SV_ModStart> EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr -> unary . child
<S2SV_ModStart> ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text (
<S2SV_ModStart> xkb_atom_text ( ctx , field ) ; if ( ! str ) return false ; if (
<S2SV_ModStart> FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , "Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n" ) ; } else { <S2SV_ModStart> , xkb_file_type_to_string ( file -> file_type ) ) ; }
<S2SV_ModStart> ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> ; if ( ! key_aliases ) return false ; <S2SV_ModEnd> i = 0 ; darray_foreach ( alias , info <S2SV_ModStart> alias -> real ; i ++ ; } } }
<S2SV_ModStart> field ) ; * index_rtrn = NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( <S2SV_ModStart> * index_rtrn = expr -> array_ref . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
<S2SV_ModStart> syms ) ; FreeStmt ( ( ParseCommon * ) <S2SV_ModEnd> append ) ; return expr ; } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; exit ( 0 ) ; } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) { http_response_set_status ( res , 404 ,
<S2SV_ModStart> http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page ) && <S2SV_ModStart> , "page" ) ) != NULL ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ) ; http_response_send ( res ) ; return ; } <S2SV_ModStart> http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page ) && <S2SV_ModStart> = http_request_get_query_string ( req ) ; if ( page && page_name_is_good ( page )
<S2SV_ModStart> * req = NULL ; struct printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 ; int isform = 0 ; <S2SV_ModStart> isspace ( * sb ) ) sb ++ ; sscanf ( sb , "%u" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else if ( i > 13 && <S2SV_ModStart> , "<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>" ) ; printstr ( & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"<S2SV_blank>enctype=\\"application/x-www-form-urlencoded\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" <S2SV_ModEnd> ) ; while ( fgets ( buf , 256 <S2SV_ModStart> ) ; break ; } case 'U' : { unsigned <S2SV_ModEnd> l = 0 ; int error = 0 ; <S2SV_ModStart> error = 0 ; if ( ! writable || ! contentlen || <S2SV_ModStart> ) { error = 1 ; } while ( l < contentlen && <S2SV_ModStart> CLIENT , ( unsigned char * ) buf , ( contentlen - l ) > LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModEnd> , '+' , conf . timeouts [ STRING_S ] <S2SV_ModStart> ) i = ( contentlen - l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf , "conffile=" , 9 ) ) <S2SV_ModStart> 1 ; } if ( ! error ) { buf [ i ] = 0 ; <S2SV_ModStart> buf + 9 ) ; } l += i <S2SV_ModEnd> ; } if ( writable && ! error )
<S2SV_ModStart> "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" <S2SV_ModStart> ( r , "poll" , & s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char * redirect_uri = oidc_get_redirect_uri ( r <S2SV_ModStart> , origin , client_id , session_state , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri , redirect_uri ) ; return oidc_util_html_send (
